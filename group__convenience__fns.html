<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.4 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Things to make life easier with the GSL</div>  </div>
</div>
<div class="contents">
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li>#define <a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(in)&#160;&#160;&#160;apop_vector_sum(in)
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>char * <a class="el" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a> (char const *in, char strip_type)
<li>gsl_rng * <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)
<li>void <a class="el" href="group__convenience__fns.html#ga6c6853616a59a1bd26765c7ef08fb86c">apop_vector_increment</a> (gsl_vector *v, int i, double amt)
<li>void <a class="el" href="group__convenience__fns.html#ga30db74bbed6bcc9cf4fa4cdbc68313b8">apop_matrix_increment</a> (gsl_matrix *m, int i, int j, double amt)
<li>void <a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> (gsl_vector *v1, gsl_vector *v2, char inplace)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)
<li>int <a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)
<li>long double <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)
<li>double <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)
<li>double <a class="el" href="group__convenience__fns.html#gac3b9f35ed990dd35f34ba1f072da3dd5">apop_vector_grid_distance</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>long double <a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)
<li>double <a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7f85a98b61078ba3dc273f17eddd34a7"></a><!-- doxytag: member="stats.h::apop_sum" ref="ga7f85a98b61078ba3dc273f17eddd34a7" args="(in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_sum</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in</td><td>)</td>
          <td>&#160;&#160;&#160;apop_vector_sum(in)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An alias for <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>. Returns the sum of the data in the given vector. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga45bb322b9f491c46feb1e24025b6301f"></a><!-- doxytag: member="apop_conversions.c::apop_matrix_copy" ref="ga45bb322b9f491c46feb1e24025b6301f" args="(const gsl_matrix *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <code>gsl_matrix</code> to another. That is, all data is duplicated. Unlike <code>gsl_matrix_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><pre class="fragment"> gsl_matrix *a_copy = <a class="code" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a>(original);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill </dd></dl>

</div>
</div>
<a class="anchor" id="ga30db74bbed6bcc9cf4fa4cdbc68313b8"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_increment" ref="ga30db74bbed6bcc9cf4fa4cdbc68313b8" args="(gsl_matrix *m, int i, int j, double amt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_increment </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Just add <code>amt</code> to a <code>gsl_matrix</code> element. This is a readable convenience function that does some checks along the way. If you need speed, try, e.g.,</p>
<div class="fragment"><pre class="fragment">  *gsl_matrix_ptr(v, i, j) += amt;
</pre></div><p>which is roughly 25% faster by my tests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>gsl_matrix</code> in question (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">i</td><td>The row of the element to be incremented. (No default) </td></tr>
    <tr><td class="paramname">j</td><td>The column of the element to be incremented. (No default) </td></tr>
    <tr><td class="paramname">amt</td><td>The amount by which to increment. Of course, one can decrement by specifying a negative amount. (default = 1. Please note that it is impossible to increment by zero. If that glitch is a possibility, use <code>apop_vector_increment_base</code>.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga040b9e9fea1abe105de86081bf396d40"></a><!-- doxytag: member="apop_stats.c::apop_matrix_mean" ref="ga040b9e9fea1abe105de86081bf396d40" args="(const gsl_matrix *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_mean </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the mean of all elements of a matrix.</p>
<p>Calculated to avoid overflow errors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf794cc2491ef147e0c67eb05feed7a87"></a><!-- doxytag: member="apop_stats.c::apop_matrix_mean_and_var" ref="gaf794cc2491ef147e0c67eb05feed7a87" args="(const gsl_matrix *data, double *mean, double *var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_mean_and_var </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the mean and variance of all elements of a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the matrix to be averaged. </td></tr>
    <tr><td class="paramname">mean</td><td>where to put the mean to be calculated </td></tr>
    <tr><td class="paramname">var</td><td>where to put the variance to be calculated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae50bc918e0d8b6ee913596f68ab731a8"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_stack" ref="gae50bc918e0d8b6ee913596f68ab731a8" args="(gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first matrix either on top of or to the right of the second matrix. The fn returns a new matrix, meaning that at the end of this function, until you gsl_matrix_free() the original matrices, you will be taking up twice as much memory. Plan accordingly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost matrix (default=<code>NULL</code>, in which case this basically copies <code>m2</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second matrix (default = <code>NULL</code>, in which case <code>m1</code> is returned) </td></tr>
    <tr><td class="paramname">posn</td><td>if 'r', stack rows on top of other rows, else, e.g. 'c' stack columns next to columns. (default ='r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If one, use <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> to modify <code>m1</code> in place; see the caveats on that function. Otherwise, allocate a new matrix, leaving <code>m1</code> unmolested. (default=0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stacked data, either in a new matrix or a pointer to <code>m1</code>.</dd></dl>
<p>For example, here is a little function to merge four matrices into a single two-part-by-two-part matrix. The original matrices are unchanged. </p>
<div class="fragment"><pre class="fragment">gsl_matrix *apop_stack_two_by_two(gsl_matrix *ul, gsl_matrix *ur, gsl_matrix *dl, gsl_matrix *dr){
  gsl_matrix *output, *t;
    output = <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(ul, ur, <span class="charliteral">&#39;c&#39;</span>);
    t = <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(dl, dr, <span class="charliteral">&#39;c&#39;</span>);
    <a class="code" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a>(output, t, <span class="charliteral">&#39;r&#39;</span>, .inplace=1);
    gsl_matrix_free(t);
    <span class="keywordflow">return</span> output;
}
</pre></div><p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="ga369c774aac917e56d8e32f9c66d9c2a0"></a><!-- doxytag: member="apop_stats.c::apop_matrix_sum" ref="ga369c774aac917e56d8e32f9c66d9c2a0" args="(const gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_matrix_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sum of the elements of a matrix. Occasionally convenient.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to be summed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada044cf02135422a9f9292b6054c86dd"></a><!-- doxytag: member="apop_bootstrap.c::apop_rng_alloc" ref="gada044cf02135422a9f9292b6054c86dd" args="(int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_rng* apop_rng_alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a <code>gsl_rng</code>.</p>
<p>Uses the Tausworth routine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed. No need to get funny with it: 0, 1, and 2 will produce wholly different streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The RNG ready for your use. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e82db6a61febe39f2037879eec6f285"></a><!-- doxytag: member="apop_asst.c::apop_strip_dots" ref="ga9e82db6a61febe39f2037879eec6f285" args="(char const *in, char strip_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* apop_strip_dots </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>strip_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Strip dots from a name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A string </td></tr>
    <tr><td class="paramname">strip_type</td><td>'d': replace all '.' with '_'.<br/>
 'b': return only the string before the '.', so 'table.col' becomes 'table'. If there are multiple dots, cuts off at the first dot. 'a': return only the string after the '.', so 'table.col' becomes 'col'. If there are multiple dots, cuts off at the last dot.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> test_strip_dots(<span class="keywordtype">void</span>){
    <span class="comment">/* 0: replace all dots with _</span>
<span class="comment">      1: everything before the last dot.</span>
<span class="comment">      2: everything after the first dot.</span>
<span class="comment">      */</span>
<span class="keywordtype">char</span> teapot[]   = <span class="stringliteral">&quot;tea.pot&quot;</span>;
<span class="keywordtype">char</span> many_dots[]   = <span class="stringliteral">&quot;tea.pot.csv&quot;</span>;
<span class="keywordtype">char</span> *out;
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(teapot, 0);
    assert(!strcmp(out, <span class="stringliteral">&quot;tea_pot&quot;</span>));
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(teapot, 1);
    assert(!strcmp(out, <span class="stringliteral">&quot;tea&quot;</span>));
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(teapot, 2);
    assert(!strcmp(out, <span class="stringliteral">&quot;pot&quot;</span>));
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(many_dots, 0);
    assert(!strcmp(out, <span class="stringliteral">&quot;tea_pot_csv&quot;</span>));
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(many_dots, 1);
    assert(!strcmp(out, <span class="stringliteral">&quot;tea.pot&quot;</span>));
    out = <a class="code" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a>(many_dots, 2);
    assert(!strcmp(out, <span class="stringliteral">&quot;pot.csv&quot;</span>));
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ga136ded2b6d190739deca064701cf5ca1"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_bounded" ref="ga136ded2b6d190739deca064701cf5ca1" args="(const gsl_vector *in, long double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_vector_bounded </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test for a situation when a vector is diverging, so you can preempt a procedure that is about to break on infinite values.</p>
<p>Alternatively, set <code>max</code> to <code>INFINITY</code> (or <code>GSL_INF</code>) to just test whether all of the matrix's elements are finite.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> </td></tr>
    <tr><td class="paramname">max</td><td>An upper and lower bound to the elements of the vector. (default: GSL_POSINF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if everything is bounded: not Inf, -Inf, or NaN, and <img class="formulaInl" alt="$-\max < x < \max$" src="form_21.png"/>; zero otherwise. A <code>NULL</code> vector has no unbounded elements, so <code>NULL</code> input returns 1.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="ga5baf0e8717a30fdcfba350da904c1825"></a><!-- doxytag: member="apop_conversions.c::apop_vector_copy" ref="ga5baf0e8717a30fdcfba350da904c1825" args="(const gsl_vector *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_copy </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <code>gsl_vector</code> to another. That is, all data is duplicated. Unlike <code>gsl_vector_memcpy</code>, this function allocates and returns the destination, so you can use it like this:</p>
<div class="fragment"><pre class="fragment"> gsl_vector *a_copy = <a class="code" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a>(original);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill </dd></dl>

</div>
</div>
<a class="anchor" id="ga44a77f5e6867c627fd313f3f6e252ff8"></a><!-- doxytag: member="apop_stats.c::apop_vector_distance" ref="ga44a77f5e6867c627fd313f3f6e252ff8" args="(const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_distance </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the distance between two vectors, where distance is defined based on the third (optional) parameter:</p>
<ul>
<li>'e' or 'E' (the default): scalar distance (standard Euclidean metric) between two vectors. Simply <img class="formulaInl" alt="$\sqrt{\sum_i{(a_i - b_i)^2}},$" src="form_56.png"/> where <img class="formulaInl" alt="$i$" src="form_29.png"/> iterates over dimensions.</li>
</ul>
<ul>
<li>'m' or 'M' Returns the Manhattan metric distance between two vectors: <img class="formulaInl" alt="$\sum_i{|a_i - b_i|},$" src="form_57.png"/> where <img class="formulaInl" alt="$i$" src="form_29.png"/> iterates over dimensions.</li>
</ul>
<ul>
<li>'d' or 'D' The discrete norm: if <img class="formulaInl" alt="$a = b$" src="form_58.png"/>, return zero, else return one.</li>
</ul>
<ul>
<li>'s' or 'S' The sup norm: find the dimension where <img class="formulaInl" alt="$|a_i - b_i|$" src="form_59.png"/> is largest, return the distance along that one dimension.</li>
<li>'l' or 'L' The <img class="formulaInl" alt="$L_p$" src="form_60.png"/> norm, <img class="formulaInl" alt="$\left(\sum_i{(a_i - b_i)^2}\right)^{1/p},$" src="form_61.png"/>. The value of <img class="formulaInl" alt="$p$" src="form_18.png"/> is set by the fourth (optional) argument.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ina</td><td>First vector (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">inb</td><td>Second vector (Default = zero) </td></tr>
    <tr><td class="paramname">metric</td><td>The type of metric, as above. </td></tr>
    <tr><td class="paramname">norm</td><td>If you are using an <img class="formulaInl" alt="$L_p$" src="form_60.png"/> norm, this is <img class="formulaInl" alt="$p$" src="form_18.png"/>. Must be strictly greater than zero. (default = 2)</td></tr>
  </table>
  </dd>
</dl>
<p>Notice that the defaults are such that </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v);
 <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v, .metric = <span class="charliteral">&#39;s&#39;</span>);
</pre></div><p> gives you the standard Euclidean length of <code>v</code> and its longest element.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/* Test distance calculations using a 3-4-5 triangle */</span>
<span class="keywordtype">void</span> test_distances(){
    gsl_vector *v1 = gsl_vector_alloc(2);
    gsl_vector *v2 = gsl_vector_alloc(2);
    gsl_vector_set(v1, 0,2);
    gsl_vector_set(v1, 1,2);
    gsl_vector_set(v2, 0,5);
    gsl_vector_set(v2, 1,6);
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v1, <span class="charliteral">&#39;d&#39;</span>) == 0);     <span class="comment">//discrete: if vectors are equal d==0;</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, v2, <span class="charliteral">&#39;d&#39;</span>) == 1);     <span class="comment">//          if vectors differ d ==1</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1, NULL, <span class="charliteral">&#39;m&#39;</span>) == 4.);  <span class="comment">//length of v1, Manhattan metric</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2) == 5.);          <span class="comment">//the hypotenuse of the 3-4-5 triangle</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v2, NULL, <span class="charliteral">&#39;s&#39;</span>) == 6);   <span class="comment">//length of v2, sup norm</span>
    assert(<a class="code" href="group__convenience__fns.html#gac3b9f35ed990dd35f34ba1f072da3dd5">apop_vector_grid_distance</a>(v1,v2) == 7.);     <span class="comment">//distance v1 to v2 in Manhattan</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;m&#39;</span>) == 7.);     <span class="comment">//same</span>
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v1,v2, <span class="charliteral">&#39;L&#39;</span>, 2) == 5.);  <span class="comment">//L_2 norm == Euclidean</span>
}
</pre></div><p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="ga032dcecb67155c527c884dd2c1cc6a6e"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_exp" ref="ga032dcecb67155c527c884dd2c1cc6a6e" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_exp </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace every vector element <img class="formulaInl" alt="$v_i$" src="form_20.png"/> with exp( <img class="formulaInl" alt="$v_i$" src="form_20.png"/>). </p>

</div>
</div>
<a class="anchor" id="gac3b9f35ed990dd35f34ba1f072da3dd5"></a><!-- doxytag: member="apop_stats.c::apop_vector_grid_distance" ref="gac3b9f35ed990dd35f34ba1f072da3dd5" args="(const gsl_vector *ina, const gsl_vector *inb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_grid_distance </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>ina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>inb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the scalar Manhattan metric distance between two vectors. Simply <img class="formulaInl" alt="$\sum_i{|a_i - b_i|},$" src="form_57.png"/> where <img class="formulaInl" alt="$i$" src="form_29.png"/> iterates over dimensions.</p>
<p>Equivalent to <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a><code>(ina, inb, .metric='M')</code>. </p>

</div>
</div>
<a class="anchor" id="ga6c6853616a59a1bd26765c7ef08fb86c"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_increment" ref="ga6c6853616a59a1bd26765c7ef08fb86c" args="(gsl_vector *v, int i, double amt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_increment </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Just add <code>amt</code> to a <code>gsl_vector</code> element. This is a readable convenience function that does some checks along the way. If you need speed, try, e.g.,</p>
<div class="fragment"><pre class="fragment">  *gsl_vector_ptr(v, i) += amt;
</pre></div><p>which is roughly 25% faster by my tests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <code>gsl_vector</code> in question (No default, must not be NULL) </td></tr>
    <tr><td class="paramname">i</td><td>The location in the vector to be incremented. (No default) </td></tr>
    <tr><td class="paramname">amt</td><td>The amount by which to increment. Of course, one can decrement by specifying a negative amount. (default = 1. Please note that it is impossible to increment by zero. If that glitch is a possibility, use <code>apop_vector_increment_base</code>.)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="ga5a622b8360eba63795a6049c30ac54a2"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_log" ref="ga5a622b8360eba63795a6049c30ac54a2" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take the natural log of every element in a vector. </p>

</div>
</div>
<a class="anchor" id="ga1a4a67e0b0bec8205cfe75bd3786c30e"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_log10" ref="ga1a4a67e0b0bec8205cfe75bd3786c30e" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_log10 </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take the log (base ten) of every element in a vector. </p>

</div>
</div>
<a class="anchor" id="gae603a7d511cf40b022f99dc69faa616a"></a><!-- doxytag: member="apop_linear_algebra.c::apop_vector_stack" ref="gae603a7d511cf40b022f99dc69faa616a" args="(gsl_vector *v1, gsl_vector *v2, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_stack </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first vector on top of the second vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the upper vector (default=<code>NULL</code>, in which case this basically copies <code>v2</code>) </td></tr>
    <tr><td class="paramname">v2</td><td>the second vector (default=<code>NULL</code>, in which case nothing is added) </td></tr>
    <tr><td class="paramname">inplace</td><td>If one, use <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>v1</code> in place; see the caveats on that function. Otherwise, allocate a new vector, leaving <code>v1</code> unmolested. (default=0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stacked data, either in a new vector or a pointer to <code>v1</code>.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="gaf6182181dd424bc4de98b4bfbd349b4e"></a><!-- doxytag: member="apop_stats.c::apop_vector_sum" ref="gaf6182181dd424bc4de98b4bfbd349b4e" args="(const gsl_vector *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double apop_vector_sum </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sum of the data in the given vector. </p>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Fri Jan 27 2012.</div></body></html>
