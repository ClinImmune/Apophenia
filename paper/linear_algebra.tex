\chapter[Linear Algebra]{Linear algebra} \label{linear_algebra} 

Recall the philosophy of C: the language provides only the most basic of
basics, such as addition and division, and everything else one would
want to do is provided by a function library. Most of statistical analysis is
described as operations on matrices and vectors, so the first key
extension a mathematician needs is a package to do basic vector and
matrix maintenance and linear algebra.

\index{GSL|see{GNU Scientific Library}}
There are many on the market; this chapter uses the \ind{GNU Scientific
Library} (GSL). The GSL is recommended because it is actively supported
and will work on about as many platforms as C itself. Apophenia is built
on the GSL, and many of its structures have GSL matrices or vectors at
their core, so low-level operations on \cinline{apop\_data} sets become
\cinline{gsl\_matrix} operations.

\section{The GSL's matrices and vectors}
As you saw in Chapter \ref{c_crash}, arrays and matrices can be directly implemented in C, but for
the rest of the book, I'll be sticking to the GSL's matrix and vector objects.
If you like using raw arrays better, it's easy to switch back and forth; see
section \ref{asst_conversions}.


\cindex{gsl\_matrix}
\cindex{gsl\_matrix\_set}
\cindex{gsl\_matrix\_set\_row}
\cindex{gsl\_matrix\_set\_col}
\cindex{gsl\_matrix\_alloc}
\cindex{gsl\_matrix\_get}
\cindex{gsl\_vector\_alloc}
\cindex{gsl\_matrix\_free}
\cindex{gsl\_vector\_free}
\index{declaration!of gsl\_matrix@of \cinline{gsl\_matrix}}
\index{declaration!of gsl\_vector@of \cinline{gsl\_vector}}
\index{for@\cinline{for}!example of}
Here is a complete program that will do a few useless things to a few sample
objects:\label{gslexample}
\begin{lstlisting}
#include <gsl/gsl_matrix.h>
#include <stdio.h>

int main(void){
   gsl_matrix   *m = gsl_matrix_alloc(10,10);
   gsl_vector   *v = gsl_vector_calloc(10);
   int  i;

   for (i=0;i< m->size1; i++){
      gsl_matrix_set(m, i, 0, i) ;
   }
   printf("Here is point (3,0): %g\n", gsl_matrix_get(m, 3,0));
   gsl_matrix_set_row(m, 3, v);
   printf("Here is point (3,0) again: %g", gsl_matrix_get(m, 3,0));
   gsl_matrix_free(m);
   gsl_vector_free(v);
   return 0;
}
\end{lstlisting}
\paragraph{A walk through the code}
Here is what just happened: we allocated a 10$\times$10 matrix and a vector of
length 10.  For the sake of variety, we  allocated the two differently.
\cinline{gsl\_matrix\_alloc} simply set aside a block of memory for the matrix,
and that block may have garbage in it. Meanwhile, \cinline{gsl\_vector\_calloc} set
aside some space for the vector \cinline{v}, and set all the values of \cinline{v} to
zero.  We were able to do these allocations in the declaration itself.

That done, the \cinline{for} loop put some values in the first column of the matrix (leaving garbage in the rest of the matrix). 
The syntax should be familiar to you from subsection \ref{for_loops}: we start at
zero, not one, and increment up to the size of the matrix, which in this case is
\cinline{m-$>$size1}. You will recognize this as accessing a structure, which is exactly
what we are doing: the declaration \cinline{gsl\_matrix *m} means that
\cinline{m} is a pointer to a \cinline{gsl\_matrix}, which is a structure
whose definition you can look up if you are so inclined. If you do, you
will see that it includes elements \cinline{size1} and \cinline{size2},
for the row and column sizes of the matrix. [Row always comes first,
then Column, just like the order in Roman Catholic, Randy Choirboy,
or RC Cola.] Since the vector has only one dimension, the analogous
element of the vector structure is \cinline{v-$>$size}.

Next, we copied the vector to the third row of the matrix using \cinline{gsl\_\-ma\-trix\_\-set\_\-row(m, 3, v)}. Notice that in so doing, we
overwrote the three at the point (3,0) of the matrix with a zero from
the third element of \cinline{v}.

Finally, we freed the memory used for the vectors. This is not 
necessary for a small program,
but it's a good habit to get into for
when you start getting the monolithic analyses, which you may not be
able to run on your PC if you don't keep the memory clear of debris.

\paragraph{Naming conventions}  \index{naming functions}
Every function in the GSL library will begin with \cinline{gsl\_}, and
the first argument of all of these functions will be the object to be acted upon.
Every function which affects a matrix will begin with \cinline{gsl\_matrix\_}
and similarly with vectors and their functions, which all begin with \cinline{gsl\_vector\_}. 
Apophenia generally sticks to this as well, and 100\% of its functions
begin with \cinline{apop\_} and a great majority of them begin with a data
type such as \cinline{apop\_data\_}, \cinline{apop\_est\-i\-mate\_}, \&c.

The consistency of the naming means that you have more to type, but
less to memorize. Given the package-object-verb form, you can likely
guess the name of the function you want. Your text editor probably has
some sort of name completion command, which you may want to look up. E.g.,
vim users, try $<$ctrl-n$>$ after typing a few characters. Also, they
make the index very helpful: the index of the GSL's online reference
gives a complete list of functions that operate on vectors alphabetized
under \ci{gsl\_vector\_...}, and the index of this book gives a partial
list of the most useful functions.

\exercise{Don't delay---have a look at the \ci{gsl\_vector\_...}
and \ci{gsl\_matrix\_...} sections of the index to this book or the GSL's online
reference and skim over the sort of operations you can do. The Apophenia
package has a number of higher-level operations that are also worth
getting to know, so have a look at the \ci{apop\_vector\_...}
and \ci{apop\_matrix\_...} sections as well.}

Another alternative is to start writing your own functions. For example, you
could write a file \cinline{my\_convenience\_fns.c}, which could include:

\cindex{gsl\_matrix\_get}
\cindex{gsl\_matrix\_set}
%\begin{verbatim}
\begin{lstlisting}
double mget(gsl_matrix *m, int row, int col){
   return gsl_matrix_get(m, row, col);
}

double vget(gsl_vector *v, int row){
   return gsl_vector_get(v, row);
}
\end{lstlisting}
%\end{verbatim}

You will also need a header file, \cinline{my\_convenience\_fns.h}:
%\begin{verbatim}
\begin{lstlisting}
double mget(gsl_matrix *m, int row, int col);
double vget(gsl_vector *v, int row);
\end{lstlisting}
%\end{verbatim}

After throwing an \cinline{\#include "my\_convenience\_fns.h"} at the top of your
program, you will be able to use your abbreviated syntax such as \cinline{mget(v,3)}.
It's up to your \ae sthetics as to whether your code will be more or less
legible after you make these changes, but you will need to remember to
bring your convenience functions with you everywhere you go.


\subsection{The easy stuff} The simplest operations on matrices and
vectors are element-by-element, such as adding the elements of one
matrix to those of another. The GSL provides the functions you would
expect to do such things. Each modifies its first argument.
\cindex{gsl\_matrix\_add} \cindex{gsl\_matrix\_sub}
\cindex{gsl\_matrix\_mul\_elements} \cindex{gsl\_matrix\_div\_elements}
\cindex{gsl\_vector\_add} \cindex{gsl\_vector\_sub}
\cindex{gsl\_vector\_mul} \cindex{gsl\_vector\_div}
\cindex{gsl\_matrix\_scale} \cindex{gsl\_matrix\_add\_constant}
\cindex{gsl\_vector\_scale} \cindex{gsl\_vector\_add\_constant}
\lstset{texcl=true} %For this whole section.
\begin{lstlisting}
gsl_matrix_add (a,b);   // $a_{ij} = a_{ij} + b_{ij}, \forall\ i, j$
gsl_matrix_sub (a,b);   // $a_{ij} = a_{ij} - b_{ij}, \forall\ i, j$
gsl_matrix_mul_elements (a,b);  // $a_{ij} = a_{ij} \cdot b_{ij}, \forall\ i, j$
gsl_matrix_div_elements (a,b);// $a_{ij} = a_{ij} / b_{ij}, \forall\ i, j$
gsl_vector_add (a,b);   // $a_{i} = a_{i} + b_{i}, \forall\ i$
gsl_vector_sub (a,b);   // $a_{i} = a_{i} - b_{ij}, \forall\ i$
gsl_vector_mul (a,b);  // $a_{i} = a_{i} \cdot b_{i}, \forall\ i$
gsl_vector_div (a,b);   // $a_{i} = a_{i} / b_{i}, \forall\ i$

gsl_matrix_scale (a,x); // $a_{ij} = a_{ij} \cdot x, \forall\ i, j$
gsl_matrix_add_constant (a,x);  // $a_{ij} = a_{ij} + x, \forall\ i, j$
gsl_vector_scale (a,x); // $a_{i} = a_{i} \cdot x, \forall\ i$
gsl_vector_add_constant (a,x);  // $a_{i} = a_{i} + x, \forall\ i$
\end{lstlisting}

Notice that the functions to multiply and divide two matrices are given
slightly lengthier names to minimize the potential that they will be
confused with the process of multiplying a matrix with another matrix,
${\bf A}{\bf B}$, or its inverse, 
${\bf A}{\bf B}^{-1}$. Those operations require more computational firepower, which
is provided by the BLAS.

\summary{
\item You can express matrices and vectors via \ci{gsl\_matrix} and
\ci{gsl\_vector} structures.
\item Allocate these structures using \ci{gsl\_matrix\_alloc(size1,
size2)} and \ci{gsl\_vector\_alloc(size)}; free them using
\ci{gsl\_matrix\_free(m)} and \ci{gsl\_vector\_free(v)}.
\item Refer to elements using \ci{gsl\_matrix\_set} and
\ci{gsl\_matrix\_get} (and similarly for vectors).
\item Once your data is in these forms, you can operate on the matrix or
vector as a whole using functions like
\ci{gsl\_matrix\_add (a,b)} or \ci{gsl\_vector\_scale (a,x)}.
}

\section{The \ind{BLAS}} 
\index{matrices!dot product|(} \index{dot product|(}
Before there was the GSL, there was the BLAS---the basic linear algebra
system. The GSL has a few functions to interact with the BLAS. In fact,
it has 86. This section covers the three that you will actually 
use.\footnote{The names of the functions here fit in with the system
for the other 83 functions you won't ever use. They are a combination
of D=double precision, GE=general, M=matrix, V=vector.}

Apophenia provides a convenience function, \cind{apop\_dot}, that can
save you from a great deal of the below (see page \pageref{apopdot}).
Therefore, you may prefer to skim this section, and are again
discouraged from memorizing any of it.

\paragraph{Matrix $\cdot$ vector} Here is the function you will use to calculate the dot product of a
matrix and a vector:
\cindex{gsl\_blas\_dgemv|(}
\begin{lstlisting}
int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransX, float alpha, 
          const gsl_matrix * X, const gsl_vector * v, 
          float beta, gsl_vector * y)
\end{lstlisting}

This will put into the vector $y$ either the value 
$\alpha X v + \beta y$ or $\alpha X' v + \beta y$, as determined by the
first argument.
\cinline{CBLAS\_TRANSPOSE\_t} is a type defined by the GSL that can take
one of two values: \cinline{CblasNoTrans} and \cinline{CblasTrans}. If
it takes the former value, then $X$ is left alone;
if it takes the latter, it is transposed to $X'$.

To give a concrete example, assume you have already got some vectors and matrices which have the following
declarations:
\begin{lstlisting}
gsl_vector *beta, *gamma;     
gsl_matrix *x, *y;           
\end{lstlisting}

Then, to calculate $X\cdot \beta$, we'd need:

\begin{lstlisting}
gsl_vector *beta_dot_x      = gsl_vector_calloc(x->size1);
gsl_blas_dgemv (CblasNoTrans, 1.0, x, beta, 0.0, beta_dot_x);
\end{lstlisting}

Notice that we used \cinline{calloc}, instead of just \cinline{alloc}, because
the system will add $x\beta$ to \cinline{beta\_dot\_x}, not just write it in,
so \cinline{beta\_dot\_x} needs to start as all zeros.
\cindex{gsl\_blas\_dgemv|)}

\paragraph{Vector $\cdot$ vector}
To find the dot product of two vectors, use this function:
\cindex{gsl\_blas\_ddot}
\begin{lstlisting}
int gsl_blas_ddot (const gsl_vector * x, const gsl_vector * y, double * result);
\end{lstlisting}

For example, \label{ddot}

\begin{lstlisting}
double *beta_dot_gamma;
gsl_blas_ddot (beta, gamma, beta_dot_gamma);
\end{lstlisting}

\paragraph{Matrix $\cdot$ matrix}
Finally, to take the dot product of two matrices, use:
\cindex{gsl\_blas\_dgemm|(}
\begin{lstlisting}
int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransX, 
    CBLAS_TRANSPOSE_t TransY, 
    double alpha, const gsl_matrix * X, const gsl_matrix * Y, 
    double beta, gsl_matrix * dot_product);
\end{lstlisting}
which will calculate \cinline{dot\_product} $= \alpha op(X) op(Y) + \beta$ \cinline{dot\_product}. $op(X)$ and
$op(Y)$ will be either the matrix or its transpose, as above, depending on whether you choose \cinline{CblasTrans}
or \cinline{CblasNoTrans}. For example, here is $X'Y$:

\begin{lstlisting}
gsl_matrix *x_dot_y      = gsl_matrix_calloc(x->size2, y->size2);
gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, x, y, 0, x_dot_y);
\end{lstlisting}

To give a more extended example, let us say that we have a \ind{transition matrix}, showing whether one can go from a row state to a
column state. Omitting the labels for now, here is a sample:
\label{twostep}\lstinputlisting{sources/markov_data} 
[This is not really a \ind{Markov matrix}, because its
columns are not normalized to one; the reader will see below that it
still is a valid description of a set of transitions.]

Here is a complete program to read in this matrix and then output this
count of two-step transitions. The steps should be clear: read the data,
allocate a space for the output, calculate the dot product, and print
the result. It introduces a new data type, \cind{apop\_data} to be
discussed fully in Chapter \ref{apop}. For now, just take it to be a
\cinline{gsl\_matrix} with labels.
\lstinputlisting{sources/markov.c}
Here is the output:
\begin{lstlisting}
    2       3       1       1       2       3
    3       4       3       3       4       4
    2       2       3       3       3       2
    4       5       4       4       5       5
    4       5       4       4       5       5
    3       4       3       3       4       4
\end{lstlisting}
This tells us, for example, that there are three ways to transition from state one to
state two in two steps (1 $\Rightarrow$ 1 $\Rightarrow$ 2, 
1 $\Rightarrow$ 2 $\Rightarrow$ 2,  and 1 $\Rightarrow$ 6 $\Rightarrow$
2).

\exercise{\label{quadq}The quadratic form $\Xv'\Yv\Xv$ appears very frequently in
statistical work. Write a function with the header
\cinline{gsl\_matrix *quadratic\_form(gsl\_matrix *x, gsl\_matrix *y);} 
that takes two \cinline{gsl\_matrix}es and returns the quadratic form as above. Be sure to check that \cinline{y} is square and has the same dimension as \cinline{x-$>$size1}.}

\cindex{gsl\_blas\_dgemm|)}

\index{matrices!dot product|)}
\index{dot product|)}
\comment{
\paragraph{Scalars} The GSL provides predictable functions for
interacting vectors or matrices with scalars. Here is code to add one to
and then double all the elements of a matrix and a vector:
\begin{lstlisting}
gsl_matrix_add_constant(a_matrix, 1);
gsl_matrix_scale(a_matrix, 2);

gsl_vector_add_constant(a_vector, 1);
gsl_vector_scale(a_vector, 2);
\end{lstlisting}
\cindex{gsl\_matrix\_add\_constant} \cindex{gsl\_matrix\_scale}
\cindex{gsl\_vector\_add\_constant} \cindex{gsl\_vector\_scale}
}

\summary{
\item Matrix $\cdot$ vector: \ci{gsl\_blas\_dgemv}.
\item Matrix $\cdot$ matrix: \ci{gsl\_blas\_dgemm}.
\item Vector $\cdot$ vector: \ci{gsl\_blas\_ddot}.
}

\section{Matrix inversion and equation solving}  \index{matrices!inversion}\index{matrices!determinants}
Matrix inversion is one of the most computationally intensive problems
around. In fact, some will tell you it is the problem for which computers were invented.

\codefig{invertmatrix}{A function that inverts a matrix using via an LU decomposition}

The GSL does not include a function to directly invert a general matrix:
instead, the user has to go through a triangular decomposition. Figure
\ref{invertmatrix} shows a function to do all of the steps for us.
Examples for using this function are located throughout the book; for
example, see the calculation of OLS coefficients on page \pageref{ols}.

Figure \ref{invertmatrix} is cut and pasted from the Apophenia source
code; \cind{apop\_det\_and\_inv} does indeed invert and calculate the
determinant of an input matrix. This is what \ttind{apop\_OLS} will use if
you ask for covariances.

\index{Householder solver}
Because inversion is so computationally intensive, you are better off
not doing so.  For example, we often write the OLS parameters as $\beta
=(X'X)^{-1}(X'Y)$, but you could implement this as solving
$(X'X)\beta = X'Y$, which involves no inversion. If \cinline{xpx} is the
matrix $X'X$ and \cinline{xpy} is the vector $X'Y$, then 
\cind{gsl\_linalg\_HH\_solve}\cinline{(xpx, xpy, out-$>$parameters)} will
return $\beta$. This is how \cinline{apop\_OLS} will find $\beta$ if it
is all you ask for.

\summary{
\item You can often avoid inverting matrices, but when you must, you can use
\ci{apop\_det\_and\_inv}.
}

\section{Shunting data} \label{asst_conversions} 
There are many facets to dealing with a computer that one would call
tedious, but for me, the most tedious of all is converting data formats.
You can describe the process easily, say `pull the data and find
$\Xv'\Xv$', but the data is in a text file and your function to take dot
products accepts \cinline{gsl\_vectors}, and going from one
to the other will take you much more time than calling the function in
the end.

To that end, this section presents
suggestions for converting among the various data formats used in this
book. It is not an exciting
read, and outside of Method V, there is little new material; you may
prefer to take this section as a reference to refer to as necessary. Table
\ref{conversiontab} provides the key to the method most appropriate for
each given conversion. 

From/to pairs marked with a dot are
left as an exercise for the reader; none are particularly difficult, but
may require going through another format; for example, one can go from a
\cinline{double[ ]} to an \cinline{apop\_data} set via \cinline{double[
]} $\Rightarrow$ \cinline{gsl\_matrix} $\Rightarrow$ \cinline{apop\_data}.
One can go from any format to any other in two steps, as proven above
using the transition matrix on page \pageref{twostep}. 

\def\rcap#1{\rotatebox{45}{#1}\hskip -15pt }
\def\rcapc#1{\rotatebox{45}{\cinline{#1}}\hskip -15pt }
\def\cd{$\cdot$}
\begin{figure} \begin{center}
\begin{tabular}{ll}
\rotatebox[x=15mm]{90}{From}&
\begin{tabular}{lp{0.4cm}p{0.4cm}p{0.4cm}p{0.4cm}p{0.4cm}p{0.4cm}}
   &   &&&To\\
    & \rcap{Text file} & \rcap{Db table} & \rcapc{double[]} 
        & \rcapc{gsl\_vector} & \rcapc{gsl\_matrix}& \rcapc{apop\_data}\\
Text file               & C & F & \cd & \cd & \cd &  F                   \\
Db table                & \cd & Q & \cd & Q & Q & Q                  \\
\cinline{double[ ]}      & \cd & \cd & C & F & F & \cd                  \\
\cinline{gsl\_vector}   & P  & P & F & C & F & F                    \\
\cinline{gsl\_matrix}   &  P & P & F & V &C &  F               \\
\cinline{apop\_data}    & P & P & F & \cd & S &C
\end{tabular}
\end{tabular}
\caption{Methods of conversion} \label{conversiontab}
\end{center}\end{figure} 


\paragraph{Method C: Copying} There are two styles of copying.
One is the family of functions with \cind{memcpy} in the name, that are
of the form \cinline{memcpy(dest, src)}. The assume that \cinline{dest}
is already allocated.  
Apophenia provides functions to allocate and copy in one step, with
names of the form \cinline{apop\_...\_copy}.

\cindex{gsl\_vector\_memcpy} \cindex{gsl\_matrix\_memcpy}
\cindex{apop\_data\_memcpy} \cindex{apop\_data\_memcpy} \cindex{system}
\begin{lstlisting}
//Text file $\Rightarrow$ Text file
//Just use the system's file copy command.
    system("cp %s %s", from_file_name, to_file_name);
//\cinline{gsl\_vector} $\Rightarrow$ \cinline{gsl\_vector}
    gsl_vector *copy   = gsl_vector_alloc(original->size);
    gsl_vector_memcpy(copy, original);
    gsl_vector *copy2 = apop_vector_copy(original);
//\cinline{double[ ]} $\Rightarrow$ \cinline{double[ ]}
//You need to know the size of the original.
    double *copy1 = malloc(sizeof(double) * original_size);
    memcpy(copy1, original, sizeof(double) * original_size);
    double *copy2[original_size];
    memcpy(copy2, original, sizeof(double) * original_size);
//\cinline{gsl\_matrix} $\Rightarrow$ \cinline{gsl\_matrix}
    gsl_matrix *copy   = gsl_matrix_alloc(original->size1, original->size2);
    gsl_matrix_memcpy(copy, original);
    gsl_matrix *copy2 = apop_matrix_copy(original);
//\cinline{apop\_data} $\Rightarrow$ \cinline{apop\_data}
    apop_data *copy1 = apop_data_alloc(original->matrix->size1, original->matrix->size2);
    apop_data_memcpy(copy1, original);
    apop_data *copy2 = apop_data_copy(original);
\end{lstlisting}

\paragraph{Method F: Function call}
\cindex{apop\_vector\_to\_matrix}\cindex{apop\_vector\_to\_data}\cindex{apop\_matrix\_to\_data}
\cindex{apop\_text\_to\_data} \cindex{apop\_text\_to\_db}
\cindex{apop\_array\_to\_matrix} \cindex{apop\_array\_to\_vector}
\cindex{apop\_line\_to\_matrix} \cindex{apop\_line\_to\_data}
\index{arrays}

These are functions designed to convert one format to another.

There are two ways to express an array of \cinline{double}s. One is to
declare a pointer to pointers to \cinline{double}s, and the other is to
declare double-subscripts:
\begin{lstlisting}
double **method_one = malloc(sizeof(double*)*size_1);
double method_two[size_one][size_two] = {{2,3,4},{5,6,7}};
\end{lstlisting}
The second method seems convenient, because it lets you allocate the
matrix at once. But due to minuti\ae{} that will not be discussed here
(see \citet[p 113]{kandr:c}), method two is too much of a hassle to
be worth anything. 

Instead, declare your data as a single line, listing the entire first
row, then the second, et cetera, with no intervening brackets. Then, use
the \cinline{apop\_line...} functions to convert to a matrix. Below, the
first set of examples convert from an array declared as in method one
above, and the second set shows an array declared as a single line and
then converted to a $2 \times 3$ matrix.
\begin{lstlisting}
//text $\Rightarrow$ db table
//The first number states whether the file has row names; the second
//whether it has column names. Finally, if no colnames are present,
//you can provide them in the last argument as a \cinline{char **}
    apop_text_to_db("original.txt", "tablename", 0 , 1, NULL);
//text $\Rightarrow$ \cinline{apop\_data}
    apop_data *copy = apop_text_to_data("original.txt", 0 , 1);
//\cinline{*double} $\Rightarrow$ \cinline{gsl\_vector}
    gsl_vector  *copy = apop_array_to_vector(original, original_size);
//\cinline{**double} $\Rightarrow$ \cinline{gsl\_matrix}
    gsl_matrix *copy = apop_array_to_matrix(original, original_size1, original_size2);

//\cinline{double[ ]} $\Rightarrow$ \cinline{gsl\_matrix}
    double original[] = {2,3,4,5,6,7};
    gsl_matrix *copy = apop_line_to_matrix(original, original_size1, original_size2);
//\cinline{double[ ]} $\Rightarrow$ \cinline{apop\_data}
    apop_data *copy = apop_line_to_data(original, original_size1, original_size2);

//\cinline{gsl\_vector} $\Rightarrow$ \cinline{double[ ]}
    double *copy;
    int copy_size   = original_vec->size;
    apop_vector_to_array(original_vec, &copy);
//\cinline{gsl\_vector} $\Rightarrow$ \cinline{gsl\_matrix}
    gsl_matrix   *copy = apop_vector_to_matrix(original_vec);
//\cinline{gsl\_vector} $\Rightarrow$ \cinline{apop\_data}
    apop_data   *copy = apop_vector_to_data(original_vec);
//\cinline{gsl\_matrix} $\Rightarrow$ \cinline{apop\_data}
    apop_data   *copy = apop_matrix_to_data(original_matrix);
\end{lstlisting}

\paragraph{Method P: Printing}
\cindex{apop\_vector\_print} \cindex{apop\_matrix\_print} \cindex{apop\_data\_print}
Apophenia's printing functions will print to screen, text file, or
database, depending on the value of \cind{apop\_opts.output\_type}.
\begin{lstlisting}
//\cinline{gsl\_vector} $\Rightarrow$ text file
//\cinline{gsl\_matrix} $\Rightarrow$ text file
//\cinline{apop\_data} $\Rightarrow$ text file
    apop_opts.output_type = 't'
    apop_vector_print(original_vector, "text_file_copy");
    apop_matrix_print(original_matrix, "text_file_copy");
    apop_data_print(original_data, "text_file_copy");
//\cinline{gsl\_vector} $\Rightarrow$ db table
//\cinline{gsl\_matrix} $\Rightarrow$ db table
//\cinline{apop\_data} $\Rightarrow$ db table
    apop_opts.output_type = 'd'
    apop_vector_print(original_vector, "db_copy");
    apop_matrix_print(original_matrix, "db_copy");
    apop_data_print(original_data, "db_copy");
\end{lstlisting}


\paragraph{Method Q: Querying}
\cindex{apop\_query} \cindex{apop\_query\_to\_vector}
\cindex{apop\_query\_to\_matrix} \cindex{apop\_query\_to\_data}
The only way to get data out of a database is to query it out. Apophenia
provides a function that will produce the appropriate output.

\begin{lstlisting}
//db table $\Rightarrow$ db table
    apop_query("create table copy as \
    select * from original");
//db table $\Rightarrow$ \cinline{gsl\_vector}
    apop_query_to_vector("select * from original");
//db table $\Rightarrow$ \cinline{gsl\_matrix}
    apop_query_to_matrix("select * from original");
//db table $\Rightarrow$ \cinline{apop\_data}
    apop_query_to_data("select * from original");
\end{lstlisting}


\paragraph{Method S: Subelements} Sometimes, even a function is just
overkill; you can just pull a subelement from the main data item.

Notice, by the way, that the \cinline{data} subelement of a
\cinline{gsl\_vector} can not necessarily be copied to a
\cinline{double[ ]}---the \airq{stride} may be wrong; see the GSL manual
for details. Instead, use the copying functions from Method F above.

\begin{lstlisting}
//\cinline{apop\_data} $\Rightarrow$ \cinline{gsl\_matrix}:
    my_data_set -> matrix
\end{lstlisting}
\lstset{texcl=false}

%\eject

\comment{
\marginaliafixed{18}{Allocating and using at once}{    \index{declaration}
One slight convenience that helps with the annoyance of shunting data from
one type to another is that you can declare a variable and assign it at the
same time. Let us say that you have already filled a \cinline{gsl\_matrix
*m} with data and want it to be an \cinline{apop\_data} structure. Then
you can declare and allocate your new structure with one line:\\
%\begin{lstlisting}
\cinline{apop\_data   *mdata  = apop\_matrix\_to\_data(m);}\\
%\end{lstlisting}
On the left-hand side, we are allocating an \cinline{apop\_data *} pointer, and
on the left-hand side, \cind{apop\_data\_from\_matrix} returns an 
\cinline{apop\_data *} pointer. As in the example on page \pageref{gslexample}, the same can be
done with any function with \cinline{alloc} in the name, because they will also
return a pointer to the appropriate type.
}
}

\paragraph{Method V: Views}\index{views}\index{matrices!views}
The GSL includes a convenient structure for pulling a vector from a
matrix. Here is how to get the fifth row of \cinline{a\_matrix} into a vector view:

\begin{lstlisting}
gsl_vector v;
v = gsl_matrix_col(a_matrix, 4).vector;
apop_vector_show(&v);
\end{lstlisting}
[Notice that this function is named \cinline{col}, not \cinline{column}.]
For the fifth row, use \cinline{gsl\_matrix\_row(a\_\-ma\-trix, 4)}. 
\cindex{gsl\_matrix\_row} 

The vector view is a nice test of your comprehension of the details of
pointers and memory allocation from Section \ref{pointers}.
\cinline{gsl\_ma\-trix\_col} returns a
\cind{gsl\_vector\_view}---not a vector, but the actual
structure.  Inside the \cinline{gsl\_vec\-tor\_view}, you will find 
an element named \cinline{vector}, which is again not a pointer but an
automatically allocated structure. Inside that \cinline{.vector}
element, one would find a pointer to the data.

When the function ends, all of the automatically-allocated data is
thrown out, including \cinline{gsl\_\-vec\-tor\_\-view} and its
\cinline{vector} element, but the data itself is untouched.

Notice further that every function that handles a
\cinline{gsl\_\-vec\-tor} actually takes a {\em pointer} to a 
\cinline{gsl\_\-vec\-tor}. Thus, the fact that you have an actual 
\cinline{gsl\_\-vec\-tor} on your hands means that you will have to pass
its address to the various functions, as in the call to
\cinline{apop\_\-vec\-tor\_\-show} above.
\cindex{apop\_vector\_show}

If you want to retain the vector after the function exits, your best bet
is to just copy it to another vector:

\cindex{gsl\_vector\_alloc}
\cindex{gsl\_vector\_memcpy}
\cindex{gsl\_matrix\_col}
\begin{lstlisting}
gsl_vector *a_new_vector = gsl_vector_alloc(a_matrix->size1);
gsl_vector v = gsl_matrix_col(a_matrix, 4).vector;
gsl_vector_memcpy(a_new_vector, &v);
\end{lstlisting}

\paragraph{The jackknife}
The typical means of doing a jackknife estimation (as discussed in
Chapter \ref{boot}) involves re-estimating a parameter for the data set
excluding the first row, re-estimating it for the data set excluding the
second row, et cetera.  Figure \ref{jack_iteration}
shows how this can be done using views.  First, it uses
\cind{gsl\_matrix\_submatrix} to produce a view of the main matrix
starting at the position (1,0), and with size (\ci{in-$>$size1 -1,
in-$>$size2})---that is, the original matrix with the first row missing,
and then copies that to a new matrix. The \ci{for} loop then repeats
the view-and-copy procedure row by row.  It begins with row zero, which
was omitted before, and overwrites row zero in the copy, aka row one of
the original. It then copies over original row one, overwriting original
row two, and so on to the end of the matrix.

\codefig{jack_iteration}{Iteratively produce \ci{in->size1} submatrices,
each with one omitted row of data.\index{jackknife}}

\section{\treesymbol Numbers} \index{infinity} \index{NaN|see{not a number}} \index{not a number} \cindex{GSL\_NEGINF} \cindex{GSL\_POSINF} \cindex{GSL\_NAN} \label{numbers}
Floating-point numbers (both \cind{float} and \cind{double}) can take three special values: \cinline{Inf}, \cinline{-Inf}, and \cinline{NaN}. Data-oriented readers will mostly be
interested in \cinline{NaN} (read: not a number), which is an appropriate way to represent missing data. Here is a
program to show you the syntax. All four \cinline{if} statements will be true, and print their associated
statements.
\cindex{gsl\_finite}
\cindex{gsl\_isnan}
\cindex{gsl\_isinf}
\ns{19}
\begin{lstlisting}
#include <gsl/gsl_math.h>   //NaN handlers
#include <stdio.h>          //printf

int main(){
double missing_data = GSL_NAN;
float big_number = GSL_POSINF;
float negative_big_number = GSL_NEGINF;
if (gsl_isnan(missing_data))
    printf("I'm missing a data point.");
if (gsl_finite(big_number)== 0)
    printf("big_number is not finite.");
if (gsl_finite(missing_data)== 0)
    printf("missing_data isn't finite either.");
if (gsl_isinf(negative_big_number)== -1)
    printf("negative_big_number is negative infinity");
return 0;
}
\end{lstlisting}

Since floating-point numbers can take these values, division by zero
won't crash your program. \cinline{float f = 1.0/0.0} will result in
\cinline{f == GSL\_POSINF} and \cinline{f = 0.0/0.0} will result in \cinline{f ==
GSL\_NAN}. However, integers have none of these luxuries: run \cinline{int
i = 1/0} and you will get \cind{Arithmetic exception (core dumped)}.

\subsection{Precision}\index{precision, numerical} 
As with any finite means of writing real numbers,
there is a round off error to the computer's internal representation of
numbers. The computer basically stores non-integer numbers using
\ind{scientific notation}. For those who have forgotten this notation, one
would write  $\pi$ as $3.14159 \times 10^0$, or \ci{3.14159e0}, 
and $100\pi = 3.14159 \times 10^2$, or \ci{3.14159e2}. 
Numbers always have exactly one digit before the decimal point, and the
exponent is chosen to ensure that this is the case.

Your computer works in binary, so numbers are of the form $d \times
2^n$, where $d$ is a string of ones and zeros and $n$ is an
exponent.\footnote{This oversimplifies some details that are
basically irrelevant for users. For example, the first digit of $d$
is always one, and therefore the computer doesn't bother storing it.}
Multiplying a number by $1024=2^{10}$ will leave $d$ entirely unchanged
but add ten to $n$, so operations like doubling or halving a number
will not change the precision of the number (until $n$ exceeds the space
given to it, typically around $\pm 512$).

To give you a more concrete idea of the relative precision options
you have before you, Figure \ref{precision} shows a program to print $\pi$ in various
formats. Notice that the constant has an \ci{L} appended to indicate
to the compiler that it needs to reserve extra space for the constant
right from the start. 

\index{printf}
The program uses more advanced format specifiers than the basic specifiers
on page \pageref{printf}. Here are the atoms used in the code.  Every
format specifier will end with a type specifier (\ci{i}, \ci{g}, \ci{f},
\ci{lf}, and so on), but between the percent sign and the type specifier,
you may insert some other symbols to further describe how the variable
should print.

\begin{center}
\label{printftwo}
\fbox{
\begin{tabular}{rl}
\ci{\%f}	& insert a \ci{float} here\\
\ci{\%lf}	& insert a \ci{double} (formerly long float) here\\
\ci{\%Lf}	& insert a \ci{long double} here\\
\ci{\%-}	& left-justify\\
\ci{\%}$n$		& allow $n$ spaces for the number\\
\ci{\%.}$n$	&  allow $n$ spaces after the decimal
\end{tabular}
}
\end{center}

\codefig{precision}{Print $\pi$ as four types of increasing precision.}
\comment{
\begin{lstlisting}
#include <math.h>
#include <stdio.h>

int main(){
long double pi = 3.1415926535897932384626433832795028841971693993751058209749445923L;
printf("Pi, integer:\t\t %-65i\n",  (int) pi);
printf("Pi, float:\t\t %-65.63f\n",  (float) pi);
printf("Pi, double:\t\t %-65.63lf\n",  (double) pi);
printf("Pi, long double:\t %-65.63Lf\n",  pi);
return 0;
}
\end{lstlisting}
}

Here is the output:
\begin{lstlisting}[language={}]
Pi, integer: 3
Pi, float:  3.14159274101257324218750000000000000000000000000000000000000000000000
Pi, double:      3.14159265358979311599796346854418516159057617187500000000000000000000
Pi, long double: 3.14159265358979323851280895940618620443274267017841339111328125000000
\end{lstlisting}
The floating-point version is accurate up to six digits after the
decimal, and then goes astray. The double-precision version is right up to 15
digits, and the long double precision scores another four digits before
losing its way.

Errors compound, so adding ten numbers
with four significant digits can leave you with only three significant
digits. As a general rule of thumb, if you are writing an internal
function to act on a \ci{float}, use \ci{double} variables internally,
and if you are taking in \ci{double}s, use \ci{long double} internally.

\label{precisionproblem}
Multiplying large columns of numbers is also to be avoided. This is
discussed in the chapter on maximum likelihood estimation, because the
likelihood function involves exactly such multiplication. Say that we
have a column of a thousand values each around $\frac{1}{2}$. Then the
product of a thousand of these is about $2^{-1000}$, which strains what
a \ci{double} can represent. Here is a table of powers of two, as
represented by a \ci{double}. For $i>1,000$, a
modest number of data points, the system throws in the towel and just
calls $2^i = \infty$ and $2^{-i} = 0$; these are referred to as
\vocab{overflow errors} and \vocab{undeflow errors}, respectively. For those who would like
to try this at home, the code to produce the body of this table is:
\cindex{ldexp}
\begin{lstlisting}
int i;
for(i=0; i< 1400; i+=100)
    printf("%i\t %lg \t %lg\n", i, ldexp(1,i), ldexp(1,-i));
\end{lstlisting}


\begin{center}
\vspace{\baselineskip}
\hspace{-1.4cm} 
\fbox{
\begin{tabular}{lll}
$i$ & $2^i$ & $2^{-i}$\\
\hline
100&      1.26765e+30     &7.88861e-31\\
200&      1.60694e+60&     6.22302e-61\\
300&      2.03704e+90&     4.90909e-91\\
400&      2.58225e+120&    3.87259e-121\\
500&      3.27339e+150&    3.05494e-151\\
600&      4.14952e+180&    2.40992e-181\\
700&      5.26014e+210&    1.90109e-211\\
800&      6.66801e+240&    1.4997e-241\\
900&      8.45271e+270&    1.18305e-271\\
1000&     1.07151e+301&    9.33264e-302\\
1100&     inf&     0\\
1200&     inf&     0
\end{tabular}
}
\vspace{\baselineskip}
\end{center}

The solution to the problem of finding the product of a large number of
elements, as shown on page \pageref{precisionfix}, is to calculate
the log of the product rather than the product itself.

If you need to calculate $\pi$ to a million decimal points, you
will need to find a library that can work with numbers to \ind{arbitrary
precision}. Such libraries typically work by representing all numbers
as a data structure listing each decimal point, and then extending the
list in either direction as necessary. Rather than using C's built-in
add/subtract/multiply/divide, the library provides its own to act on
its data structure. Unfortunately, the added layer of complexity means
that what had been fast procedures (often implemented via
special-purpose registers on the processor hardware itself) are now a
long series of library calls.

So to do math efficiently on large matrices, we are stuck with finite
precision, and therefore must not
rely too heavily on numbers after around four significant digits. 
Fortunately, for the purposes of estimating and testing
the parameters of a model using real-world data, this is OK. If two
numbers differ only after eight significant digits (say, 3.14159265
versus 3.14159268), there is rarely any reason to take these numbers are
significantly different. Even if the hypothesis test indicates that they
are different, it will be difficult to convince a referee of this.


\paragraph{Conditioning}\index{data!conditioning} Most numerical routines do badly when the
determinant is near zero, or when eigenvalues are different orders of magnitude.
One way to cause such problems with your own data is
to have one column that is of the order of $1 \times 10^{10}$ and
another that is on the order of $1 \times 10^{-10}$. In
finite-precision arithmetic on two numbers of such wide range, the
smaller number is often simply swallowed: $3.14 \times 10^{10} + 5.92
\times 10^{-10} = 3.14 \times 10^{10}$. 

Thus, try to ensure that each column of the data is
approximately of the same order of magnitude before doing calculations.
Say that you have a theory that mean fingernail thickness is influenced by
a location's population.
You could modify the scale when pulling data from the database,
\begin{lstlisting}[language=sql]
select population/1000., nail_thickness*1000.
from health_data;
\end{lstlisting}
or you could modify it in the \ci{gsl\_matrix}:
\begin{lstlisting}
gsl_vector v = gsl_matrix_col(data, 0).vector;
gsl_vector_scale(&v, 1/1000.);
gsl_vector v = gsl_matrix_col(data, 1).vector;
gsl_vector_scale(&v, 1000.);
\end{lstlisting}

These notes about conditioning are not C-specific. Any mathematics
package that hopes to efficiently work with large matrices must use
finite-precision arithmetic, and will therefore have the same problems
with ill-conditioned data matrices. For much more information about
precision issues and the IEEE standard, see \citet{goldberg:floating}.

\summary{
\item Floating-point numbers can take on values of \ci{-Inf}, \ci{Inf},
and \ci{NaN}.
\item Try to keep the scale of your variables within about a thousand of
each other.
\item Multiplying together a column of a thousand numbers will break.
\item Reporting results based on the fifth significant digit (or so) is spurious.
}
