\chapter[Linear Algebra]{Linear algebra} \label{linear_algebra}
%@-     so lgrind will play nice with makeindex

Recall the philosophy of C: the language provides only the most basic of
basics, such as addition and division, and everything else one would
want to do is provided by a package. Most of statisical analysis is
described as operations on matrices and vectors, so the first key
extension a mathematician needs is a package to do basic vector and
matrix maintenance and linear algebra.

\index{GSL|see{GNU Scientific Library}}
There are many on the market; this chapter uses the \ind{GNU Scientific
Library} (GSL). The GSL is recommended because it is actively supported
and will work on about as many platforms as C itself. Apophenia is built
on the GSL, and many of its structures have GSL matrices or vectors at
their core, so low-level operations on {\tt apop\_\-data} sets become
{\tt gsl\_\-matrix} operations.

\section{The GSL's matrices and vectors}
As you saw in the last chapter, arrays can be directly implemented in C, but for
the rest of the book, I'll be sticking to the GSL's matrix and vector objects.
If you like using raw arrays better, it's easy to switch back and forth; see
section \ref{asst_conversions}.


\ttindex{gsl\_matrix}
\ttindex{gsl\_matrix\_set}
\ttindex{gsl\_matrix\_set\_row}
\ttindex{gsl\_matrix\_alloc}
\ttindex{gsl\_matrix\_get}
\ttindex{gsl\_vector\_alloc}
\ttindex{gsl\_matrix\_free}
\ttindex{gsl\_vector\_free}
\index{declaration!of gsl\_matrix@of {\tt gsl\_matrix}}
\index{declaration!of gsl\_vector@of {\tt gsl\_vector}}
\index{for@{\tt for}!example of}
Here's some sample code which will do a few useless things to a few sample
objects:\label{gslexample}
%\begin{verbatim}
%[
#include <gsl/gsl_matrix.h>
#include <stdio.h>


int main(void){
   gsl_matrix   *m = gsl_matrix_alloc(10,10);
   gsl_vector   *v = gsl_vector_calloc(10);
   int  i;

   for (i=0;i< m->size1; i++){
      gsl_matrix_set(m, i, 0, i) ;
   }
   printf("Here's point (3,0): %g\n", gsl_matrix_get(m, 3,0));
   gsl_matrix_set_row(m, 3, v);
   printf("Here's point (3,0) again: %g", gsl_matrix_get(m, 3,0));
   gsl_matrix_free(m);
   gsl_vector_free(v);
}
%]
%\end{verbatim}

\paragraph{A walk through the code}
Here's what just happened: we allocated a 10$\times$10 matrix and a vector of
length 10.  For the sake of variety, we  allocated the two differently.
{\tt gsl\_matrix\_alloc} simply set aside a block of memory for the matrix,
and that block may have garbage in it. Meanwhile, {\tt gsl\_vector\_calloc} set
aside some space for the vector {\tt v}, and set all the values of {\tt v} to
zero.  We were able to do these allocations in the declaration itself.

That done, the {\tt for} loop put some values in the first column of the matrix. 
The syntax should be familiar to you from subsection \ref{for_loops}: we start at
zero, not one, and increment up to the size of the matrix, which in this case is
{\tt m-$>$size1}. You'll recognize this as accessing a struct, which is exactly
what we're doing: the declaration {\tt gsl\_matrix *m} means that {\tt m} is a
pointer to a {\tt gsl\_matrix}, which is a structure whose definition you can
look up if you're so inclined. If you do so, you'll see that it includes 
elements {\tt size1} and {\tt size2}, for the row and column sizes of the
matrix. [Row always comes first, then Column, just like the order in Roman Catholic, 
Randy Choirboy, or RC Cola.] Since the vector has only one dimension, the analagous element
of the vector structure is {\tt v-$>$size}.

Next, we copied the vector to the third row of the matrix using {\tt
gsl\-\_matrix\-\_set\-\_row(m, 3, v)}. Notice that in so doing, we
overwrote the three at the point (3,0) of the matrix with a zero from
the third element of {\tt v}.

Finally, we freed the memory used for the vectors. This is not strictly
necessary for a small program, since the operating system
will clean up some of your mess. But it's a good habit to get into for
when you start getting the monolithic analyses, which you may not be
able to run on your PC if you don't keep the memory clear of debris.

\paragraph{Naming conventions}  \index{naming functions}
Notice the consistency of
the GSL's naming scheme. Every function in the GSL library will begin with {\tt
gsl\_}. 
Further, the first argument of all of these functions will be the object to be acted upon.
Every function which affects a matrix will begin with {\tt gsl\_matrix\_}
and similarly with vectors and their functions, which all begin with {\tt gsl\_vector\_}. 
Apophenia generally sticks to this as well, and 100\% of its functions
begin with {\tt apop\_} and a great majority of them begin with a data
type such as {\tt apop\_data}, {\tt apop\_estimate}, \&c.

You'll see this form over and over again: the library gives us an interesting
object, which we'll mostly treat as a black box, and it gives us functions which
will allow us to do useful things to that black box. The consistency of the
naming means that you'll have more to type, but less to memorize. Given
the package-object-verb form, you can likely guess the name of the
function you want. Your text editor probably has some sort of name
completion command, which you may want to look up. E.g., vim users,
try $<$ctrl-n$>$ after typing a few characters.

Another alternative is to start writing your own functions. For example, you
could write a file {\tt my\_convenience\_fns.c}, which would include:

\ttindex{gsl\_matrix\_get}
\ttindex{gsl\_matrix\_set}
%\begin{verbatim}
%[
double mget(gsl_matrix *m, int row, int col){
   return gsl_matrix_get(m, row, col);
}

double vget(gsl_vector *v, int row){
   return gsl_vector_get(v, row);
}
%]
%\end{verbatim}

You'll also want a header file, {\tt my\_convenience\_fns.h}:
%\begin{verbatim}
%[
double mget(gsl_matrix *m, int row, int col);
double vget(gsl_vector *v, int row);
%]
%\end{verbatim}

After throwing an {\tt \#include "my\_convenience\_fns.h"} up at the top of your
program, you'll be able to use your abbreviated syntax such as {\tt mget(v,3)}.
It's up to your \ae sthetics as to whether your code will be more or less
legible after you make these changes, but you will need to remember to
bring your convenience functions with you everywhere you go.


\section{Numbers} \index{infinity} \index{NaN|see{not a number}} \index{not a number} \ttindex{GSL\_NEGINF} \ttindex{GSL\_POSINF} \ttindex{GSL\_NAN}
Floating-point numbers can take three special values: {\tt Inf}, {\tt -Inf}, {\tt NaN}. We will mostly be
interested in {\tt NaN} (read: not a number), which is an appropriate way to represent missing data. Here is a
program to show you the syntax. All four {\tt if} statements will be true, and print their associated
statements.
%\begin{verbatim}
%[
#include <gsl/gsl_math.h>   //NaN handlers
#include <stdio.h>          //printf

int main(){
float data_point, big_number, negative_big_number;
missing_data = GSL_NAN;
big_nuber = GSL_POSINF;
negative_big_number = GSL_NEGINF;
if (gsl_isnan(missing_data))
    printf("I'm missing a data point.");
if (gsl_finite(big_number)== 0)
    printf("big_number is not finite.");
if (gsl_finite(missing_data)== 0)
    printf("missing_data isn't finite either.");
if (gsl_isinf(negative_big_number)== -1)
    printf("negative_big_number is negative infinity");
return 0;
}
%]
%\end{verbatim}
Since floating-point nubers can take these values, division by zero
won't crash your program. {\tt float f = 1.0/0.0} will result in
{\tt f == GSL\_POSINF} and {\tt f = 0.0/0.0} will result in {\tt f ==
GSL\_NAN}. However, integers have none of these luxuries: run {\tt int
i = 1/0} and you'll get {\tt Arithmetic exception (core dumped)}.


\section{Shunting data} \label{asst_conversions} \index{matrices!dot product|(} \index{dot product|(}

More to come; for now, just have a look at the {\sl conversions} section
of the reference for a good number of conversion functions.

\paragraph{Allocating and using at once}    \index{declaration}
One slight convenience that helps with the annoyance of shunting data from
one type to another is that you can declare a variable and assign it at the
same time. Let us say that you have already filled a {\tt gsl\_\-matrix
*m} with data and want it to be an {\tt apop\_\-data} structure. Then
you can declare and allocate your new structure with one line:
%[
apop_data   *mdata  = apop_matrix_to_data(m);
%]
On the left-hand side, we are allocating an {\tt apop\_\-data *} pointer, and
on the left-hand side, \ttind{apop\_data\_from\_matrix} returns an 
{\tt apop\_\-data *} pointer. As in the example on page \pageref{gslexample}, the same can be
done with any function with {\tt alloc} in the name, because they will also
return a pointer to the appropriate type.

\paragraph{Using views}\index{views}\index{matrices!views}
The GSL includes a convenient structure for pulling a vector from a
matrix. Here's how to get the fifth row of {\tt a\_matrix} into a vector view:

%[
gsl_vector_view v;
v = gsl_matrix_col(a_matrix, 4);
%]
[Notice that this function is named {\tt col}, not {\tt column}.]
For the fifth row, use \ttind{gsl\_matrix\_row}{\tt (a\_\-ma\-trix, 4)}. 

The vector view is a data structure which includes an element of type {\tt gsl\_vector}
named vector; this is the only element you will be interested in. The
expression {\tt \&(v.vector)} is of type {\tt gsl\_vector *}, and therefore can
be used as you would any other pointer to a {\tt gsl\_vector}. For example,
try \ttind{apop\_mean}{\tt (\&(v.vector))};.

The view is intended to be a common (automatically allocated) variable,
not a pointer. If you want to retain the data after the function exits,
copy it to another vector:

%[
gsl_vector_view v;
gsl_vector *a_new_vector = gsl_vector_alloc(a_matrix->size1);
v = gsl_matrix_col(a_matrix, 4);
gsl_vector_memcpy(a_new_vector, &(v.vector));
%]

\section{The \ind{BLAS}} 
Before there was the GSL, there was the BLAS---the basic linear algebra
system. The GSL has a few functions to interact with the BLAS. In fact,
it has 86. Here are the three that you'll actually use.\footnote{
The names of the functions below fit in with the system for the other 83
functions you won't ever use. They're a combination of D=double precision,
GE=general, M=matrix, V=vector.}

\paragraph{Matrix $\cdot$ vector} Here's the function you'll use to calculate the dot product of a
matrix and a vector:
%\begin{verbatim}
%[
int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransX, float alpha, 
          const gsl_matrix * X, const gsl_vector * x, 
          float beta, gsl_vector * y)
%]
%\end{verbatim}

This will put into the vector $y$ the value $\alpha op(X) x + \beta y$. 
If {\tt TransX} is ``{\tt CblasNoTrans}'',  then $op(X)=X$; if it is
``{\tt CblasTrans}'' then $op(X)=X'$, the transpose of X.


To give a concrete example, assume you've already got some vectors and matrices which have the following
declarations:
%\begin{verbatim}
%[
gsl_vector beta, gamma;     
gsl_matrix x, y;           
%]
%\end{verbatim}

Then, to calculate $X\cdot \beta$, we'd need:

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
gsl_vector *beta_dot_x      = gsl_vector_calloc(x->size1);
gsl_blas_dgemv (CblasNoTrans, 1.0, x, beta, 0.0, beta_dot_x);
%]
%\end{verbatim}

Notice that we used {\tt calloc}, instead of just {\tt alloc}, because
the system will add $x\beta$ to {\tt beta\_dot\_x}, not just write it in,
so {\tt beta\_dot\_x} needs to start as all zeros.

\paragraph{Vector $\cdot$ vector}
To find the dot product of two vectors, use this function:
%[
int gsl_blas_ddot (const gsl_vector * x, const gsl_vector * y, 
                                        double * result);
%]

\comment{{\tt
int gsl\_blas\_ddot (const gsl\_vector * x, const gsl\_vector * y, double * result);
}}

For example,

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
double *beta_dot_gamma;
gsl_blas_ddot (beta, gamma, beta_dot_gamma);
%]
%\end{verbatim}

\paragraph{Matrix $\cdot$ matrix}
Finally, to take the dot product of two matrices, you'll need:
%[
int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransX, 
    CBLAS_TRANSPOSE_t TransY, 
    double alpha, const gsl_matrix * X, const gsl_matrix * Y, 
    double beta, gsl_matrix * dot_product)}
%]
\comment{
{\tt
int gsl\_blas\_dgemm (CBLAS\_TRANSPOSE\_t TransX, CBLAS\_TRANSPOSE\_t TransY, double $\alpha$, const
gsl\_matrix * X, const gsl\_matrix * Y, double $\beta$, gsl\_matrix * dot\_product)}
}

which will calculate {\tt dot\_product} $= \alpha op(X) op(Y) + \beta$ {\tt dot\_product}. $op(X)$ and
$op(Y)$ will be either the matrix or its transpose, as above, depending on whether you choose {\tt CblasTrans}
or {\tt CblasNoTrans}. For example, here's $X'Y$:

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
gsl_matrix *x_dot_y      = gsl_matrix_calloc(x->size1, y->size2);
gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, x, y, 0, x_dot_y);
%]
%\end{verbatim}

\index{matrices!dot product|)}
\index{dot product|)}

\section{Matrix inversion and equation solving}  \index{matrices!inversion}\index{matrices!determinants}
Matrix inversion is one of the most computationally intensive problems
around. In fact, some will tell you it is the problem for which computers were invented.

The GSL does not include a function to directly invert a general matrix:
instead, we have to go through a triangular decomposition. Figure
\ref{invertmatrix} shows a function to do all of the steps for us.
Examples for using this function are located throughout the book; for
example, see the calculation of OLS coefficients on page \pageref{ols}.

\codefig{invertmatrix}{A function which inverts a matrix using via an LU decomposition}

Figure \ref{invertmatrix} is cut and pasted from the Apophenia source
code; \ttind{apop\_\-det\_\-and\_\-inv} does indeed invert and calculate the
determinant of an input matrix. This is what \ttind{apop\_OLS} will use if
you ask for covariances.

Because inversion is so computationally intensive, you are better off
not doing so.  For example, we often write the OLS parameters as $\beta
=(X'X)^{-1}(X'Y)$, but you could implement this as solving
$(X'X)\beta = X'Y$, which involves no inversion. If {\tt xpx} is the
matrix $X'X$ and {\tt xpy} is the vector $X'Y$, then 
\ttind{gsl\_linalg\_HH\_solve}{\tt (xpx, xpy, out->parameters)} will
return $\beta$. This is how {\tt apop\_OLS} will find $\beta$ if $\beta$
is all you ask for.

