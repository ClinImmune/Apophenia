\chapter[Linear Algebra]{Linear algebra prerequisites} \label{linear_algebra}
%@-     so lgrind will play nice with makeindex

To tell you the truth, this will be the least fun chapter of the book,
because it is nothing but prerequisites for the actual applications that
will follow. But once you have this stuff down, the sky's the limit. 

\section{the GSL's matrices and vectors}
As you saw in the last chapter, arrays can be directly implemented in C, but for
the rest of the book, I'll be sticking to the GSL's matrix and vector objects.
If you like using raw arrays better, it's easy to switch back and forth; see
section \ref{asst_conversions}.


\ttindex{gsl\_matrix}
\ttindex{gsl\_matrix\_set}
\ttindex{gsl\_matrix\_set\_row}
\ttindex{gsl\_matrix\_alloc}
\ttindex{gsl\_matrix\_get}
\ttindex{gsl\_vector\_alloc}
\ttindex{gsl\_matrix\_free}
\ttindex{gsl\_vector\_free}
\index{declaration!of gsl\_matrix@of {\tt gsl\_matrix}}
\index{declaration!of gsl\_vector@of {\tt gsl\_vector}}
\index{for@{\tt for}!example of}
Here's some sample code which will do a few useless things to a few sample
objects:
%\begin{verbatim}
%[
#include <gsl/gsl_matrix.h>
#include <stdio.h>


int main(void){
   gsl_matrix   *m = gsl_matrix_alloc(10,10);
   gsl_vector   *v = gsl_vector_calloc(10);
   int  i;

   for (i=0;i< m->size1; i++){
      gsl_matrix_set(m, i, 0, i) ;
   }
   printf("Here's point (3,0): %g\n", gsl_matrix_get(m, 3,0));
   gsl_matrix_set_row(m, 3, v);
   printf("Here's point (3,0) again: %g", gsl_matrix_get(m, 3,0));
   gsl_matrix_free(m);
   gsl_vector_free(v);
}
%]
%\end{verbatim}

\paragraph{A walk through the code}
Here's what just happened: we allocated a 10$\times$10 matrix and a vector of
length 10.  For the sake of variety, we  allocated the two differently.
{\tt gsl\_matrix\_alloc} simply set aside a block of memory for the matrix,
and that block may have garbage in it. Meanwhile, {\tt gsl\_vector\_calloc} set
aside some space for the vector {\tt v}, and set all the values of {\tt v} to
zero.  We were able to do these allocations in the declaration itself.

That done, the {\tt for} loop put some values in the first column of the matrix. 
The syntax should be familiar to you from subsection \ref{for_loops}: we start at
zero, not one, and increment up to the size of the matrix, which in this case is
{\tt m-$>$size1}. You'll recognize this as accessing a struct, which is exactly
what we're doing: the declaration {\tt gsl\_matrix *m} means that {\tt m} is a
pointer to a {\tt gsl\_matrix}, which is a structure whose definition you can
look up if you're so inclined. If you do so, you'll see that it includes 
elements {\tt size1} and {\tt size2}, for the row and column sizes of the
matrix. [Row always comes first, then Column, just like the order in Roman Catholic, 
Randy Choirboy, or RC Cola.] Since the vector has only one dimension, the analagous element
of the vector structure is {\tt v-$>$size}.

Next, we copied the vector to the third row of the matrix using {\tt
gsl\-\_matrix\-\_set\-\_row(m, 3, v)}. Notice that in so doing, we
overwrote the three at the point (3,0) of the matrix with a zero from
the third element of {\tt v}.

Finally, we freed the memory used for the vectors. This is not strictly
necessary for a small program, since the GLS and the operating system
will clean up some of your mess. But it's a good habit to get into for
when you start getting the monolithic analyses, which you may not be
able to run on your PC if you don't keep the memory clear of debris.

\paragraph{Naming conventions}
Notice the consistency of
the GSL's naming scheme. Every function in the GSL library will begin with {\tt
gsl\_}. Every function which affects a matrix will begin with {\tt gsl\_matrix\_}
and similarly with vectors and their functions, which all begin with {\tt gsl\_vector\_}. Further, the
first argument of all of these functions will be the object to be acted upon.

You'll see this form over and over again: the library gives us an interesting
object, which we'll mostly treat as a black box, and it gives us functions which
will allow us to do useful things to that black box. The consistency of the
naming means that you'll have more to type, but less to memorize. Your text
editor probably has some sort of name completion command, which you may want to
look up. E.g., vim users, try $<$ctrl-n$>$.

Another alternative is to start writing your own functions. For example, you
could write a file {\tt my\_convenience\_fns.c}, which would include:

\ttindex{gsl\_matrix\_get}
\ttindex{gsl\_matrix\_set}
%\begin{verbatim}
%[
double mget(gsl_matrix *m, int row, int col){
   return gsl_matrix_get(m, row, col);
}

double vget(gsl_vector *v, int row){
   return gsl_vector_get(v, row);
}
%]
%\end{verbatim}

You'll also want a header file, {\tt my\_convenience\_fns.h}:
%\begin{verbatim}
%[
double mget(gsl_matrix *m, int row, int col);
double vget(gsl_vector *v, int row);
%]
%\end{verbatim}

Notice that this depends on compiling with gpp instead of gcc; if you want to
stick to C, then you'll need to rename that second function {\tt vget}.

After throwing an {\tt \#include "my\_convenience\_fns.h"} up at the top of your
program, you'll be able to use your abbreviated syntax such as {\tt mget(v,3)}.
It's up to your aesthetics as to whether your code will be more or less
legible after you make these changes. 


\section{Numbers} \index{infinity} \index{NaN|see{not a number}} \index{not a number}
Floating-point numbers can take three special values: {\tt Inf}, {\tt -Inf}, {\tt NaN}. We will mostly be
interested in {\tt NaN} (read: not a number), which is an appropriate way to represent missing data. Here is a
program to show you the syntax. All four {\tt if} statements will be true, and print their associated
statements.
%\begin{verbatim}
%[
#include <gsl/gsl_math.h>   //NaN handlers
#include <stdio.h>          //printf

int main(){
float data_point, big_number, negative_big_number;
data_point = GSL_NAN;
big_nuber = GSL_POSINF;
negative_big_number = GSL_NEGINF;
if (gsl_isnan(missing_data))
    printf("I'm missing a data point.");
if (gsl_finite(big_number)== 0)
    printf("big_number is not finite.");
if (gsl_finite(missing_data)== 0)
    printf("missing_data isn't finite either.");
if (gsl_isinf(negative_big_number)== -1)
    printf("negative_big_number is negative infinity");
return 0;
}
%]
%\end{verbatim}
Since floating-point nubers can take these values, division by zero
won't crash your program. {\tt float f = 1.0/0.0} will result in
{\tt f == GSL\_POSINF} and {\tt f = 0.0/0.0} will result in {\tt f ==
GSL\_NAN}. However, integers have none of these luxuries: run {\tt int
i = 1/0} and you'll get {\tt Arithmetic exception (core dumped)}.


\section{Shunting data} \label{asst_conversions} \index{matrices!dot product|(} \index{dot product|(}

Featuring such conversions as: matrix to vector, array to matrix, and reading data into an array from a
text file.


\section{The BLAS} 
Before there was the GSL, there was the BLAS---the basic linear algebra system. The GSL has a few
functions to interact with the BLAS. In fact, it has 86. Here are the three that you'll
actually use.

\paragraph{matrix $\cdot$ vector} Here's the function you'll use to calculate the dot product of a
matrix and a vector:
%\begin{verbatim}
%[
int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransX, float alpha, 
          const gsl_matrix * X, const gsl_vector * x, 
          float beta, gsl_vector * y)
%]
%\end{verbatim}

This will put into the vector $y$ the value $\alpha op(X) x + \beta y$. 
If {\tt TransX} is ``{\tt CblasNoTrans}'',  then $op(X)=X$; if it is
``{\tt CblasTrans}'' then $op(X)=X'$, the transpose of X.


To give a concrete example, assume you've already got some vectors and matrices which have the following
declarations:
%\begin{verbatim}
%[
gsl_vector beta, gamma;     
gsl_matrix x, y;           
%]
%\end{verbatim}

Then, to calculate $X\cdot \beta$, we'd need:

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
gsl_vector *beta_dot_x      = gsl_vector_calloc(x->size1);
gsl_blas_dgemv (CblasNoTrans, 1.0, x, beta, 0.0, beta_dot_x);
%]
%\end{verbatim}

Notice that we used {\tt calloc}, instead of just {\tt alloc}, because
the system will add $x\beta$ to {\tt beta\_dot\_x}, not just write it in,
so {\tt beta\_dot\_x} needs to start as all zeros.

\paragraph{vector $\cdot$ vector}
To find the dot product of two vectors, use this function:
%[
int gsl_blas_ddot (const gsl_vector * x, const gsl_vector * y, double * result);
%]

\comment{{\tt
int gsl\_blas\_ddot (const gsl\_vector * x, const gsl\_vector * y, double * result);
}}

For example,

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
double *beta_dot_gamma;
gsl_blas_ddot (beta, gamma, beta_dot_gamma);
%]
%\end{verbatim}

\paragraph{matrix $\cdot$ matrix}
Finally, to take the dot product of two matrices, you'll need:
%[
int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransX, CBLAS_TRANSPOSE_t TransY, 
    double alpha, const gsl_matrix * X, const gsl_matrix * Y, 
    double beta, gsl_matrix * dot_product)}
%]
\comment{
{\tt
int gsl\_blas\_dgemm (CBLAS\_TRANSPOSE\_t TransX, CBLAS\_TRANSPOSE\_t TransY, double $\alpha$, const
gsl\_matrix * X, const gsl\_matrix * Y, double $\beta$, gsl\_matrix * dot\_product)}
}

which will calculate {\tt dot\_product} $= \alpha op(X) op(Y) + \beta$ {\tt dot\_product}. $op(X)$ and
$op(Y)$ will be either the matrix or its transpose, as above, depending on whether you choose {\tt CblasTrans}
or {\tt CblasNoTrans}. For example, heres $X'Y$:

%\begin{verbatim}
%[
#include <gsl/gsl_blas.h>
gsl_matrix *x_dot_y      = gsl_matrix_calloc(x->size1, y->size2);
gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, x, y, 0, x_dot_y);
%]
%\end{verbatim}

\comment{
[The names, by the way, fit in with the system for the other 83 functions
you won't ever use. They're a combination of D=double precision,
GE=general, M=matrix, V=vector.]
}
\index{matrices!dot product|)}
\index{dot product|)}

\section{Matrix inversion and equation solving}  \index{matrices!inverting}
Matrix inversion is one of the most computationally intensive problems
around. In fact, some will tell you it is the problem for which computers were invented.
The GSL discourages you from taking inverses directly, since
you often don't need to. For example, we often write the OLS parameters as $\beta
=(X'X)^{-1}(X'Y)$, but you could implement this as solving
$(X'X)\beta = X'Y$, which involves no inversion.

There is no function to directly invert a general matrix: instead, we have to go through a triangular
decomposition. Figure \ref{invertmatrix} shows a function to do all of the steps for us.
Examples for using this function are located throughout the book; for example, see the calculation of
OLS coefficients on page \pageref{ols}. 
\codefig{invertmatrix}{A function which inverts a matrix using via an LU decomposition}
