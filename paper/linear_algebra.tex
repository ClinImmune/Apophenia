\chapter[Linear Algebra]{Linear algebra} \label{linear_algebra}

Recall the philosophy of C: the language provides only the most basic of
basics, such as addition and division, and everything else one would
want to do is provided by a function library. Most of statisical analysis is
described as operations on matrices and vectors, so the first key
extension a mathematician needs is a package to do basic vector and
matrix maintenance and linear algebra.

\index{GSL|see{GNU Scientific Library}}
There are many on the market; this chapter uses the \ind{GNU Scientific
Library} (GSL). The GSL is recommended because it is actively supported
and will work on about as many platforms as C itself. Apophenia is built
on the GSL, and many of its structures have GSL matrices or vectors at
their core, so low-level operations on \cinline{apop\_data} sets become
\cinline{gsl\_matrix} operations.

\section{The GSL's matrices and vectors}
As you saw in Chapter \ref{ccrash}, arrays and matrices can be directly implemented in C, but for
the rest of the book, I'll be sticking to the GSL's matrix and vector objects.
If you like using raw arrays better, it's easy to switch back and forth; see
section \ref{asst_conversions}.


\cindex{gsl\_matrix}
\cindex{gsl\_matrix\_set}
\cindex{gsl\_matrix\_set\_row}
\cindex{gsl\_matrix\_set\_col}
\cindex{gsl\_matrix\_alloc}
\cindex{gsl\_matrix\_get}
\cindex{gsl\_vector\_alloc}
\cindex{gsl\_matrix\_free}
\cindex{gsl\_vector\_free}
\index{declaration!of gsl\_matrix@of \cinline{gsl\_matrix}}
\index{declaration!of gsl\_vector@of \cinline{gsl\_vector}}
\index{for@\cinline{for}!example of}
Here is a complete program that will do a few useless things to a few sample
objects:\label{gslexample}
\begin{lstlisting}
#include <gsl/gsl_matrix.h>
#include <stdio.h>

int main(void){
   gsl_matrix   *m = gsl_matrix_alloc(10,10);
   gsl_vector   *v = gsl_vector_calloc(10);
   int  i;

   for (i=0;i< m->size1; i++){
      gsl_matrix_set(m, i, 0, i) ;
   }
   printf("Here is point (3,0): %g\n", gsl_matrix_get(m, 3,0));
   gsl_matrix_set_row(m, 3, v);
   printf("Here is point (3,0) again: %g", gsl_matrix_get(m, 3,0));
   gsl_matrix_free(m);
   gsl_vector_free(v);
   return 0;
}
\end{lstlisting}
\paragraph{A walk through the code}
Here is what just happened: we allocated a 10$\times$10 matrix and a vector of
length 10.  For the sake of variety, we  allocated the two differently.
\cinline{gsl\_matrix\_alloc} simply set aside a block of memory for the matrix,
and that block may have garbage in it. Meanwhile, \cinline{gsl\_vector\_calloc} set
aside some space for the vector \cinline{v}, and set all the values of \cinline{v} to
zero.  We were able to do these allocations in the declaration itself.

That done, the \cinline{for} loop put some values in the first column of the matrix (leaving garbage in the rest of the matrix). 
The syntax should be familiar to you from subsection \ref{for_loops}: we start at
zero, not one, and increment up to the size of the matrix, which in this case is
\cinline{m-$>$size1}. You will recognize this as accessing a struct, which is exactly
what we are doing: the declaration \cinline{gsl\_matrix *m} means that \cinline{m} is a
pointer to a \cinline{gsl\_matrix}, which is a structure whose definition you can
look up if you're so inclined. If you do, you will see that it includes 
elements \cinline{size1} and \cinline{size2}, for the row and column sizes of the
matrix. [Row always comes first, then Column, just like the order in Roman Catholic, 
Randy Choirboy, or RC Cola.] Since the vector has only one dimension, the analagous element
of the vector structure is \cinline{v-$>$size}.

Next, we copied the vector to the third row of the matrix using \cinline{gsl\_\-ma\-trix\_\-set\_\-row(m, 3, v)}. Notice that in so doing, we
overwrote the three at the point (3,0) of the matrix with a zero from
the third element of \cinline{v}.

Finally, we freed the memory used for the vectors. This is not 
necessary for a small program, since the operating system
will clean up some of your mess. But it's a good habit to get into for
when you start getting the monolithic analyses, which you may not be
able to run on your PC if you don't keep the memory clear of debris.

\paragraph{Naming conventions}  \index{naming functions}
Every function in the GSL library will begin with \cinline{gsl\_}, and
the first argument of all of these functions will be the object to be acted upon.
Every function which affects a matrix will begin with \cinline{gsl\_matrix\_}
and similarly with vectors and their functions, which all begin with \cinline{gsl\_vector\_}. 
Apophenia generally sticks to this as well, and 100\% of its functions
begin with \cinline{apop\_} and a great majority of them begin with a data
type such as \cinline{apop\_data\_}, \cinline{apop\_est\-i\-mate\_}, \&c.

The consistency of the naming means that you have more to type, but
less to memorize. Given the package-object-verb form, you can likely
guess the name of the function you want. Your text editor probably has
some sort of name completion command, which you may want to look up. E.g.,
vim users, try $<$ctrl-n$>$ after typing a few characters.

Another alternative is to start writing your own functions. For example, you
could write a file \cinline{my\_convenience\_fns.c}, which could include:

\cindex{gsl\_matrix\_get}
\cindex{gsl\_matrix\_set}
%\begin{verbatim}
\begin{lstlisting}
double mget(gsl_matrix *m, int row, int col){
   return gsl_matrix_get(m, row, col);
}

double vget(gsl_vector *v, int row){
   return gsl_vector_get(v, row);
}
\end{lstlisting}
%\end{verbatim}

You will also need a header file, \cinline{my\_convenience\_fns.h}:
%\begin{verbatim}
\begin{lstlisting}
double mget(gsl_matrix *m, int row, int col);
double vget(gsl_vector *v, int row);
\end{lstlisting}
%\end{verbatim}

After throwing an \cinline{\#include "my\_convenience\_fns.h"} at the top of your
program, you will be able to use your abbreviated syntax such as \cinline{mget(v,3)}.
It's up to your \ae sthetics as to whether your code will be more or less
legible after you make these changes, but you will need to remember to
bring your convenience functions with you everywhere you go.


\section{Numbers} \index{infinity} \index{NaN|see{not a number}} \index{not a number} \cindex{GSL\_NEGINF} \cindex{GSL\_POSINF} \cindex{GSL\_NAN}
Floating-point numbers can take three special values: \cinline{Inf}, \cinline{-Inf}, \cinline{NaN}. We will mostly be
interested in \cinline{NaN} (read: not a number), which is an appropriate way to represent missing data. Here is a
program to show you the syntax. All four \cinline{if} statements will be true, and print their associated
statements.
\cindex{gsl\_finite}
\cindex{gsl\_isnan}
\cindex{gsl\_isinf}
\begin{lstlisting}
#include <gsl/gsl_math.h>   //NaN handlers
#include <stdio.h>          //printf

int main(){
float data_point, big_number, negative_big_number;
missing_data = GSL_NAN;
big_nuber = GSL_POSINF;
negative_big_number = GSL_NEGINF;
if (gsl_isnan(missing_data))
    printf("I'm missing a data point.");
if (gsl_finite(big_number)== 0)
    printf("big_number is not finite.");
if (gsl_finite(missing_data)== 0)
    printf("missing_data isn't finite either.");
if (gsl_isinf(negative_big_number)== -1)
    printf("negative_big_number is negative infinity");
return 0;
}
\end{lstlisting}
Since floating-point nubers can take these values, division by zero
won't crash your program. \cinline{float f = 1.0/0.0} will result in
\cinline{f == GSL\_POSINF} and \cinline{f = 0.0/0.0} will result in \cinline{f ==
GSL\_NAN}. However, integers have none of these luxuries: run \cinline{int
i = 1/0} and you will get \cinline{Arithmetic exception (core dumped)}.


\section{Shunting data} \label{asst_conversions} \index{matrices!dot product|(} \index{dot product|(}

More to come; for now, just have a look at the {\sl conversions} section
of the reference for a good number of conversion functions.

\marginaliafixed{17}{Allocating and using at once}{    \index{declaration}
One slight convenience that helps with the annoyance of shunting data from
one type to another is that you can declare a variable and assign it at the
same time. Let us say that you have already filled a \cinline{gsl\_matrix
*m} with data and want it to be an \cinline{apop\_data} structure. Then
you can declare and allocate your new structure with one line:\\
%\begin{lstlisting}
\cinline{apop\_data   *mdata  = apop\_matrix\_to\_data(m);}\\
%\end{lstlisting}
On the left-hand side, we are allocating an \cinline{apop\_data *} pointer, and
on the left-hand side, \cind{apop\_data\_from\_matrix} returns an 
\cinline{apop\_data *} pointer. As in the example on page \pageref{gslexample}, the same can be
done with any function with \cinline{alloc} in the name, because they will also
return a pointer to the appropriate type.
}

\paragraph{Using views}\index{views}\index{matrices!views}
The GSL includes a convenient structure for pulling a vector from a
matrix. Here is how to get the fifth row of \cinline{a\_matrix} into a vector view:

\begin{lstlisting}
gsl_vector v;
v = gsl_matrix_col(a_matrix, 4).vector;
apop_vector_show(&v);
\end{lstlisting}
[Notice that this function is named \cinline{col}, not \cinline{column}.]
For the fifth row, use \cinline{gsl\_matrix\_row(a\_\-ma\-trix, 4)}. 
\cindex{gsl\_matrix\_row} 

The vector view is a nice test of your comprehension of the details of
pointers and memory allocation from Section \ref{pointers}.
\cinline{gsl\_ma\-trix\_} returns a
\cind{gsl\_vector\_view}---not a vector, but the actual
structure.  Inside the \cinline{gsl\_vec\-tor\_view}, you will find 
an element named \cinline{vector}, which is again not a pointer but an
automatically allocated structure. Inside that \cinline{.vector}
element, one would find a pointer to the data.

When the function ends, all of the automatically-allocated data is
thrown out, including \cinline{gsl\_\-vec\-tor\_\-view} and its
\cinline{vector} element, but the data itself is untouched.

Notice further that every function that handles a
\cinline{gsl\_\-vec\-tor} actually takes a {\em pointer} to a 
\cinline{gsl\_\-vec\-tor}. Thus, the fact that you have an actual 
\cinline{gsl\_\-vec\-tor} on your hands means that you will have to pass
its address to the various functions, as in the call to
\cinline{apop\_\-vec\-tor\_\-show} above.
\cindex{apop\_vector\_show}

If you want to retain the vector after the function exits, your best bet
is to just copy it to another vector:

\cindex{gsl\_vector\_alloc}
\cindex{gsl\_vector\_memcpy}
\cindex{gsl\_matrix\_col}
\begin{lstlisting}
gsl_vector *a_new_vector = gsl_vector_alloc(a_matrix->size1);
gsl_vector v = gsl_matrix_col(a_matrix, 4).vector;
gsl_vector_memcpy(a_new_vector, &v);
\end{lstlisting}

\section{The \ind{BLAS}} 
Before there was the GSL, there was the BLAS---the basic linear algebra
system. The GSL has a few functions to interact with the BLAS. In fact,
it has 86. Here are the three that you will actually use.\footnote{
The names of the functions below fit in with the system for the other 83
functions you won't ever use. They're a combination of D=double precision,
GE=general, M=matrix, V=vector.}

\paragraph{Matrix $\cdot$ vector} Here is the function you will use to calculate the dot product of a
matrix and a vector:
\cindex{gsl\_blas\_dgemv|(}
\begin{lstlisting}
int gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransX, float alpha, 
          const gsl_matrix * X, const gsl_vector * x, 
          float beta, gsl_vector * y)
\end{lstlisting}

This will put into the vector $y$ the value $\alpha op(X) x + \beta y$. 
If \cinline{TransX} is \cinline{CblasNoTrans},  then $op(X)=X$; if it is
\cinline{CblasTrans} then $op(X)=X'$, the transpose of X.


To give a concrete example, assume you have already got some vectors and matrices which have the following
declarations:
\begin{lstlisting}
gsl_vector *beta, *gamma;     
gsl_matrix *x, *y;           
\end{lstlisting}

Then, to calculate $X\cdot \beta$, we'd need:

\begin{lstlisting}
gsl_vector *beta_dot_x      = gsl_vector_calloc(x->size1);
gsl_blas_dgemv (CblasNoTrans, 1.0, x, beta, 0.0, beta_dot_x);
\end{lstlisting}

Notice that we used \cinline{calloc}, instead of just \cinline{alloc}, because
the system will add $x\beta$ to \cinline{beta\_dot\_x}, not just write it in,
so \cinline{beta\_dot\_x} needs to start as all zeros.
\cindex{gsl\_blas\_dgemv|)}

\paragraph{Vector $\cdot$ vector}
To find the dot product of two vectors, use this function:
\cindex{gsl\_blas\_ddot}
\begin{lstlisting}
int gsl_blas_ddot (const gsl_vector * x, const gsl_vector * y, 
                                        double * result);
\end{lstlisting}

For example,

\begin{lstlisting}
double *beta_dot_gamma;
gsl_blas_ddot (beta, gamma, beta_dot_gamma);
\end{lstlisting}

\paragraph{Matrix $\cdot$ matrix}
Finally, to take the dot product of two matrices, use:
\cindex{gsl\_blas\_dgemm|(}
\begin{lstlisting}
int gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransX, 
    CBLAS_TRANSPOSE_t TransY, 
    double alpha, const gsl_matrix * X, const gsl_matrix * Y, 
    double beta, gsl_matrix * dot_product)}
\end{lstlisting}
\comment{
{\tt
int gsl\_blas\_dgemm (CBLAS\_TRANSPOSE\_t TransX, CBLAS\_TRANSPOSE\_t TransY, double $\alpha$, const
gsl\_matrix * X, const gsl\_matrix * Y, double $\beta$, gsl\_matrix * dot\_product)}
}

which will calculate \cinline{dot\_product} $= \alpha op(X) op(Y) + \beta$ \cinline{dot\_product}. $op(X)$ and
$op(Y)$ will be either the matrix or its transpose, as above, depending on whether you choose \cinline{CblasTrans}
or \cinline{CblasNoTrans}. For example, here is $X'Y$:

\begin{lstlisting}
gsl_matrix *x_dot_y      = gsl_matrix_calloc(x->size2, y->size2);
gsl_blas_dgemm (CblasTrans,CblasNoTrans, 1, x, y, 0, x_dot_y);
\end{lstlisting}
\cindex{gsl\_blas\_dgemm|)}

\index{matrices!dot product|)}
\index{dot product|)}
\paragraph{scalars} The GSL provides predictable functions for
interacting vectors or matrices with scalars. Here is code to add one
and then double a matrix and a vector:
\begin{lstlisting}
gsl_matrix_add_constant(a_matrix, 1);
gsl_matrix_scale(a_matrix, 2);

gsl_vector_add_constant(a_vector, 1);
gsl_vector_scale(a_vector, 2);
\end{lstlisting}
\cindex{gsl\_matrix\_add\_constant} \cindex{gsl\_matrix\_scale}
\cindex{gsl\_vector\_add\_constant} \cindex{gsl\_vector\_scale}

\section{Matrix inversion and equation solving}  \index{matrices!inversion}\index{matrices!determinants}
Matrix inversion is one of the most computationally intensive problems
around. In fact, some will tell you it is the problem for which computers were invented.

\codefig{invertmatrix}{A function that inverts a matrix using via an LU decomposition}

The GSL does not include a function to directly invert a general matrix:
instead, we have to go through a triangular decomposition. Figure
\ref{invertmatrix} shows a function to do all of the steps for us.
Examples for using this function are located throughout the book; for
example, see the calculation of OLS coefficients on page \pageref{ols}.

Figure \ref{invertmatrix} is cut and pasted from the Apophenia source
code; \cind{apop\_det\_and\_inv} does indeed invert and calculate the
determinant of an input matrix. This is what \ttind{apop\_OLS} will use if
you ask for covariances.

\index{Householder solver}
Because inversion is so computationally intensive, you are better off
not doing so.  For example, we often write the OLS parameters as $\beta
=(X'X)^{-1}(X'Y)$, but you could implement this as solving
$(X'X)\beta = X'Y$, which involves no inversion. If \cinline{xpx} is the
matrix $X'X$ and \cinline{xpy} is the vector $X'Y$, then 
\cind{gsl\_linalg\_HH\_solve}\cinline{(xpx, xpy, out-$>$parameters)} will
return $\beta$. This is how \cinline{apop\_OLS} will find $\beta$ if it
is all you ask for.

