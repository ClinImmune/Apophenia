\renewcommand\thechapter{\Alph{chapter}}
\setcounter{chapter}{1}
\setcounter{section}{0}
\setcounter{subsection}{0}
\setcounter{ex}{0}
\chapter{Appendix \thechapter: Text processing} \label{textappendix}

If you are lucky, then your data is in exactly the format it needs to be
in to be read by your stats package, Apophenia, Graphviz, \&c.

By definition, you are probably not going to be lucky. This appendix will
explain how one modifies a text file to conform to an input standard. 

You will notice that the book so far has included a great deal on writing
text files via \ci{printf} and family, but not much on the process of
modifying existing files. That is because modifying files in place in
C is, simply put, frustrating. Something as simple as replacing \ci{10}
with \ci{100} requires rewriting the entire file from that point on.

Thus, this appendix will look at some means of modifying text via the
command line. Its goal, narrowly defined by the rest of the text, is to
show you how to convert a data file either into the input format required
by a stats package or into a command file in the language of Gnuplot,
a Graphviz-family tool, or SQL.

As with the rest of the analysis, you should be able to do this in a
fully automated manner. This is because you will no doubt receive a
revised data set next week with either corrections or more data, because
you may decide to split your data into a hundred subsets so manual
tweaking is no longer feasible, and because writing down a script
produces an audit trail that you or your colleagues can use to check
your work.

The primary technique covered in this chapter is the parsing of
\vocab{regular expressions}, wherein you specify a certain regularity,
such as `numbers followed by letters', and a program searches for that
regular expression in text and modifies it as per your instructions.

Along the way, you will see how to effectively search your files. As
your projects get large, you will desire tools that find every use of
\ci{buggy\_variable} in your program or every reference to an author in
your documents. Regular expression tools will help you with this.

After some discussion of how one assembles a shell script from small
parts, this appendix will cover simple searching, as an introduction to
regular expressions, and then move on to the main program: writing
scripts to reformat text files into a format appropriate for your
data-handling systems.

\section{Shell scripts} As with Gnuplot or Sqlite's command-line
utility, you can operate the shell (what many just call the command line)
by typing in commands or by writing a script and having the shell read
the script. Thus, you can try the commands below on the command line,
and if they work well, cut and paste them into a script as a permanent
record. 

Typically, your script will not just stop with reformatting text files:
your script will begin with some of the Perl or sed commands below to
reformat the data file, then call your C program to process the file, and
finally call Gnuplot to display a graph. 

In POSIX systems, you need to make a script executable before it can be
run on the command line.\footnote{This is not 100\% true: you can use
the shell's \cind{source} command to read in a text file of commands:
\bi{source myscript}. But if you are going to run the script more than a
few times, you may as well make it executable.} This is not the place
for a full POSIX tutorial, but \bi{chmod 755 myscript} or \bi{chmod +x
myscript} will do the trick. Having made the script executable, you
can call a script in the current directory (aka \bi{./}) from the shell
using \bi{./myscript}.

\subsection{Redirection} 
POSIX systems run like water. Each program has a standard input stream
and a standard output stream, named \cind{STDIN} and
\cind{STDOUT}.\footnote{There is also a third, \cind{STDERR}, to which
errors are written. To redirect \ci{STDERR}, use the form \ci{\&>}. For
example, try \ci{sed -p \&> err}, then open \ci{err} in your text editor
(or try the command \ci{cat err}).}

By default \ci{STDIN} and \ci{STDOUT} are the keyboard and screen. 
For example, the command
\begin{lstlisting}
prompt> sed -n p
\end{lstlisting}
\ci{p}rints to the screen whatever is typed in. If you
try it, you will see that this means simply that \ci{sed} repeats
whatever you type.
\begin{lstlisting}
prompt> sed -n p
Hello.
Hello.
How are you?
How are you?
Stop imitating me.
Stop imitating me.
<ctrl>-C
\end{lstlisting}
Now for the redirection. An \cind{>} tells the system to write whatever
it would have put on the screen to a file. Thus, if you put the
command \bi{sed -n p > outfile} on the command line, then nothing will
print to the screen, but whatever you type (until you hit \ci{<ctrl>-C}
or \ci{<ctrl>-D} will be written to \ci{outfile}. That is, instead of
writing to STDOUT, the system writes to \ci{outfile}.

As a variant, \cind{>> outfile} will append to a file, rather than
overwriting it, as \ci{> outfile} would.

A \cind{<} tells the system that it should take input not from \ci{STDIN}
but from an input file. Thus, \bi{sed -n p < input\_file} will dump the
contents of \ci{input\_file} to the screen. 

\exercise{Use \ci{sed -n p} and input/output redirection to copy a file.}

Your final redirection option is the pipe. The pipe connects \ci{STDOUT}
for one program to \ci{STDIN} for another. 

Question: what exponents of four end in a six?  On page \pageref{getopt}
(and in the code supplement), you will find a program that prints
exponents to \ci{STDOUT}. Below, you will see that \ci{grep} will search
a file for a certain pattern; for example, \ci{grep "6\$" <infile} will
search \ci{infile} for lines ending in a six. Thus, we could send the
output for \ci{getopt} to a file, then input it to \ci{grep}.
\begin{lstlisting}
./getopt 4 > powers_of_four
grep "6$" < powers_of_four
\end{lstlisting}
The pipe, \ci{|}, streamlines this by directly linking \ci{STDOUT} from
the first program and \ci{STDIN} to the second.
\begin{lstlisting}
./getopt 4 | grep "6$" 
\end{lstlisting}
At this point, the pattern in the exponents is eminently clear.

The next section will cover a few tools that one can join together to
filter streams of text.

\paragraph{Streams flowing through C}
As you saw on pages \pageref{fprintf}{\it ff}, you can use \ci{fprintf}
to send data to a file or another program. You may have noticed the
close similarity between opening/writing to a file and opening/writing
to a pipe:
\begin{lstlisting}
FILE *f = fopen("write_to_me", "w");
FILE *g = popen("/usr/local/bin/gnuplot", "w");
fprintf(f, "The waves roll in,\n");
fprintf(g, "The waves roll out.\n");
\end{lstlisting}
By the data-as-water metaphor, the two are identical. One redirects
output to a file, and one to another program. There are fine details of
how the two are implemented in actual memory and hardware (one is a
block device and one a character device) but that is a matter for the
operating system to worry about. At the level of a C program, output is
output.

\section{Regular expressions}
The remainder of this appendix will cover programs to parse regular
expressions.  Many programs support regexes, including standard viewers
like \ttind{less}, a fair number of online search tools, and text editors
like \ttind{vi} and \ttind{emacs}, so knowledge of regexes comes in handy
in a wide variety of situations. Entire books have been written on this
one simple subject, the most comprehensive being \citet{friedl:regex}.

\paragraph{Standard syntax, lack thereof} Regular expressions are
their own language that provides a compact means of summarizing a text
pattern. Unfortunately, there are many variants on the regex syntax,
since so many programs process them, and the author of each program felt
the need to make some sort of tweak to the standard.  Broadly, the basic
regular expression syntax derives from \ttind{ed}, a text editor from back
when the only output available to computers was the line printer. Most
POSIX utilities, such as \ttind{sed}, \ttind{grep} or \ttind{awk},
use this basic regex syntax. The scripting language \ttind{perl}
introduced a somewhat different syntax for regular expressions with
a number of extensions and modifications, and most post-Perl programs
adopted Perl-compatible regular expressions.

Different programs, and even different brands of the same
program, like GNU grep versus Solaris grep, have frustrating
differences: one may support the \ci{?} symbol and one may not; 
one takes \ci{+} as a plus sign and  \ci{\textbs+} as a special
character, while the other reads \ci{+} as special and \ci{\textbs+}
as a plain plus sign. This chapter covers Perl and GNU grep and sed as they exist as
of this writing, and you are encouraged to check the manual pages or
online references for the subtle shifts in backslashes among other
regular expression systems.


This chapter will use grep and sed because it is trivial to do regular
expression parsing and substitution from the command line. Other
systems, such as C or \ind{Python}, require a regex compilation step
before usage, which is nothing but an extra step in a script or program,
but makes one-line commands difficult. 

\subsection{The basic search}
The simplest search is for a literal string of text. Let us say that we
have a C program, and we are searching for every use of a variable,
\ci{var}. You can use the command-line program \ci{grep} (general
regular expression parser) to search for \ci{var} among your files. The
syntax is simple: \bi{grep var *.c} will search all files in the current
directory ending in \bi{.c} for the string \ci{var}, and print the result
on the command line.

\exercise{Let us say you would like some examples of how to use
\ci{printf}. Use \bi{grep} to search all of your .c files for uses
of \ci{printf}. 

The \ci{-C n} option (as in \ci{grep -C n} outputs $n$ context lines
before and after the match; repeat your search with two context lines
before and after each \ci{printf}.  }


\paragraph{Bracket expressions} Now we start to add special characters
from the regex language. The expression \ci{[fs]} will match either
\ci{f} or \ci{s}. Thus, the expression \ci{[fs]printf} will match both
\ci{fprintf} or \ci{sprintf} (but not \ci{printf}). Thus, \ci{grep
[fs]printf *.c} will find all such uses in your C files. More bits of
bracket expression syntax:

\begin{itemize}
\item You can use ranges: \ci{[A-Z]} searches for all capital letters,
\ci{[A-Za-z]} searches for all lowercase letters, and \ci{[0-9]} matches
any number. 
\item \index{\that!in regex brackets (negation)} Everything after a \ci{\that} is excluded. Thus, \ci{[\that{}fs]} matches
any single character except \ci{f} or \ci{s}, and
\ci{[a-z\that{}fs]} matches any lowercase letter
but \ci{f} or \ci{s}.
\end{itemize}
Brackets can be a bit disorienting because there is nothing in the syntax
to indicate when a group ends or begins, and no matter how many groups are
included, the result still represents exactly one character in the text.
Also, the syntax inside brackets has nothing to do with the syntax
outside brackets, which can also be confusing. A \that{} inside brackets
means negation, while below you will see that a \that{} outside brackets
means the beginning of the line. [By the way,\index{\that!searching for} in the odd event that you are searching for the \that{} character, 
put it last in the bracket: e.g., \bi{grep "[\$*\that]" myfile}.]

\index{regular expressions!case sensitivity}
Regular expressions are vehemently case-sensitive. \bi{grep perl
search\_me} will not turn up any instances of \bi{Perl}. The first
option is to use the \bi{-i} command-line switch to search without case:
\bi{grep -i perl search\_me}. The second option, occasionally useful
for for more control, is to use a bracket: \bi{grep [Pp]erl search\_me}.

\paragraph{Alternatives} 
Recall that Apophenia includes various printing functions, such as
\ci{apop\_data\_print} and \ci{apop\_matrix\_print}. Let us say that you
would like to see all such examples. Alternatives of the form \airq{A or
B} are written in basic regex notation as \ci{(A|B)}. Notice how this
form analogizes nicely with C's \ci{(A||B)} form.

However, there are several complications. First, in the
\ci{grep} regex syntax (but not in Perl's), the actual form is not
not \ci{(A|B)} but \ci{\textbs(A\textbs|B\textbs)}---the
parens and pipe all need a backslash before them. For any given
implementation of regular expressions, some subset of \ci{+ ? | ( ) \{}
and \ci{\}} will be special characters; in others, the special characters are
\ci{\textbs+ \textbs? \textbs| \textbs( \textbs) \textbs\{} and \ci{\textbs\}}.
That is, if you were hoping a character would do something special and it
doesn't,  or if you type a character hoping
it would just be a literal \ci{+} or \ci{|} and you get an odd error,
the solution to both problems is probably to prepend the character with a backslash.

If you type \ci{$\backslash$|} on the command line, then it will send a
simple \ci{|} to grep. To send a literal backslash to grep, you will
need to double it. Further, all of this will confuse your shell unless
you put it in quotes. Having taken all these considerations into
account, you can now search for alternatives. This command will search
for both \ci{apop\_data\_print} and \ci{apop\_matrix\_print}:
\begin{lstlisting}
grep "apop_\\(data\\|matrix\\)_print" *.c
\end{lstlisting}

\paragraph{A few special symbols}
You sometimes won't care at all about a certain segment. A 
dot matches any character, and you will see below that a star 
repeats the prior atom. Therefore
\begin{lstlisting}
grep "apop_.*_print" *.c
\end{lstlisting}
will find any line that has \ci{apop\_}, followed by anything,
eventually followed by \ci{\_print}. Notice that, once again, the
symbols \ci{.} and \ci{*} mean different things in different contexts.
In a regex, the dot represents any character, and the star represents
repetition; on the command line (where wildcard matching is referred to
as \vocab{globbing}), the dot is just a dot, and the star represents any
charater.

\index{\that!out of regex brackets (head of line)}
Finally, the caret and dollar sign indicate the beginning and end of the
line, respectively.  \ci{grep "\that{}int" *.c} will only match
lines where \ci{int} is right at the beginning of the line, and 
\ci{grep "\{\$" *.c} will only match open-braces at the very end of the
line. 

\index{regular expressions!white space}
A single space or tab are both characters, meaning that a dot will
match them. The atom \bi{\textbs{}W} will match any single space or tab,
and the atom \bi{\textbs{}w} will match anything that is not whitespace.
Since there are frequently an unknown bunch of tabs and spaces at the
head of code files, the correct way to search for all \ci{int}
declarations is therefore
\begin{lstlisting}
grep "^\W*int" *.c
\end{lstlisting}

\summary{
\item The quickest way to search on the command line is via grep. The
syntax is \bi{grep "regular expression" files\_to\_search}.
\item Without special characters, grep simply searches for every line
that matches the given text. To find every instance of \bi{fixme} in a
file: \bi{grep "fixme" filename}.
\item  A bracketed set indicates a single character.
    \begin{itemize}
        \item The set can include single characters: \bi{[Pp]erl} matches
both \bi{Perl} and \bi{perl} (though you maybe want a case-insensitive
search with \bi{grep -i}).
        \item The set can include ranges: \bi{[A-Za-z]} will match any
standard English letter.
        \item The set can exclude elements: \bi{[A-Z\that{}P-S]} will
find any capital letter except P, Q, R, and S.
    \end{itemize}
}
\summarynoitems{(continued)
\begin{itemize}
\item Alternatives are expressed in the form \bi{(A|B)}.
\item Different systems have different rules about what is a special
character. The Perl form for alternation is \bi{(A|B)}, as above; the
grep form is \bi{\textbs(A\textbs|B\textbs)}.
\item A single dot (\bi{.}) represents any character including a single
space or tab, and grep understands \bi{\textbs{}W} to mean any whitespace
character and \bi{\textbs{}w} to mean any non-whitespace character.
\end{itemize}
}

\subsection{Replacing}

Grep is wonderful for searching, but is a purely read-only program. If
you want to change what you find, you will need to use a more complex
program, such as Perl or \ttind{sed} (the stream editor). This section
will use sed, because it is somewhat more versatile when used on the
command line, as below. Perl adds many very useful features to regular
expression parsing, so if you find yourself using regexes frequently,
you may want to get to know how they are handled in a full
Perl-compatible regex scripting system like Python or Perl.

\paragraph{Perl and sed syntax} 
Sed is certainly installed on your system, since it is part of the
POSIX standard; Perl is almost certainly installed, since many modern
system utilities use it. If it is not installed, you can install it via
your package manager.

Both programs generally expect that you will use a command file, but you
can also give a command directly on the command line via the \bi{-e}
command.

For example,
\begin{lstlisting}
perl -e "print \"Hello, world.\n\""
\end{lstlisting}
will run the Perl command \bi{print "Hello, world.\textbs{}n"}. Notice
that we had to use \bi{\textbs"} instead of a plain \bi{"} on the
command line to prevent the string from ending prematurely.

\bi{sed} always operates on an input file, so we might as well start by 
emulating grep:\footnote{As you saw in the \bi{sed} examples in the
section on redirection, the \ci{-e} flag is optional using this form,
but it never hurts.}
\label{sedintro}
\begin{lstlisting}
sed -n -e "/regex/p" < file_to_search
\end{lstlisting}
There are many things to note here. Sed likes its regexes between
slashes, and the \ci{p} is short for \airq{print}, so the command
\ci{/regex/p} means `print every line that matches \ci{regex}.'
Sed's default is to print every single input line, and then the print
command will repeat lines that match \ci{regex}, which leads for massive
redundancy. The \ci{-n} command sets sed to no-print mode, so only
matches print.

The basic syntax for a search and replace is \ci{s/replace me/with me/g}.
The slashes distinguish the command (\ci{s}), the text to search
(\ci{replace me}), the text for replacement (\ci{with me}), and the
modifiers (the \ci{g}, which you will always want).\footnote{Back when
regexes were used for real-time editing of files, it made sense to
fix only one instance of an expression on a line. Thus, the default was
to modify only the first instance, and one could specify replacing only
the second instance of a match with \ci{s/.../.../2}, the third instance
with \ci{s/.../.../3}, and all instances with \ci{s/.../.../g}. This is
still valid syntax that is occasionally useful, but when filtering a
data file, you will almost always want the \ci{/g} option.}

If you have only one file to scan, you can use these programs as
filters:
\begin{lstlisting}
perl -p -e "s/replace me/with me/g" <file_to_modify >modified\_file
sed -e "s/replace me/with me/g" <file_to_modify >modified\_file
\end{lstlisting}

The \ci{-p} switch is the opposite of sed's \ci{-n} switch.
As opposed to sed, Perl's default is to never print
unless the pattern matches, which means that if you do not give it the
\ci{-p} switch, it will not pass over any line that does not match the regex.
With \ci{-p}, non-matching lines appear as-is and lines that do match
have the appropriate substitutions made, as we want. 
In this case, Sed is doing the right thing by default, and if you specify
the \ci{-n} switch, you will likely erase
most of your file. 


Another alternative is to replace-in-place, using the \ci{-i}
switch:\footnote{The \ci{-i} switch is not standard in \ci{sed}, but
works on GNU \ci{sed}, which you probably have. Bear this in mind if you
are concerned about a script's portability.}
\begin{lstlisting}
perl -p -i.bak -e "s/replace me/with me/g" files_to_modify
sed -i.bak -e "s/replace me/with me/g" files_to_modify
\end{lstlisting}
With the \bi{-i} option, Perl and sed do not write
the substitutions to the screen or the \bi{>} file, but
make them directly on the original file.
The \ci{.bak} extension tells Perl
and \bi{sed} to make a backup before modification that will have a \ci{.bak} extension.
You may use any extension that seems nice: \ci{-i\~{}} will produce
a backup of a file named \ci{test} that would be named \ci{test\~{}}.
If you specify no suffix at all (\ci{-i}), then no backup copy will be
made before the edits are done. It is up to you to decide when (if ever)
you are sufficiently confident to not make backups.\footnote{If editing a file in
place with C is so difficult, how does \bi{sed}, a C program, do it? By
writing a new file and then switching them when it is finished. So if you
are filtering a 1GB file `in place' with no backup and you do not have
1GB of free space on your hard drive, you will get a disk full error.}

Whether you use the in-place form or the filter form depends on whether
you want to keep the original file intact and write a new file (as this
form does) or you want to modify the original file while perhaps making
an unchanged backup (as the \ci{-i} form does).

\exercise{Create a file named \ci{about\_me} with one line, reading \ci{I am a
teapot.} Use either perl or sed to transform
from a teapot to something else, such as a kettle or a toaster.}

You are welcome to include multiple commands on the line, by the way.
In Perl, separate them with a semicolon, as in C. In sed or Perl, you
may simply specify additional \ci{-e} commands, that will be executed in
order---or you can just use a pipe.
\begin{lstlisting}
perl -pi.bak -e "s/replace me/with me/g; s/then replace this/with this/g" files_to_modify
perl -pi.bak -e "s/replace me/with me/g" -e"s/then replace this/with this/g" files_to_modify
sed -i.bak -e "s/replace me/with me/g" -e"s/then replace this/with this/g" files_to_modify

perl -p -e "s/replace me/with me/g" < modify_me | perl -p -e"s/then replace this/with this/g" >modified_version
sed "s/replace me/with me/g" <modify_me | sed "s/then replace this/with this/g"  >modified_version
\end{lstlisting}

\paragraph{Replacing with modifications} Parentheses, used above to
delimit conditional segments, can also be used to store sections for
later use. For example, say that your file reads \ci{There are 4 monkeys
at play}, but your copyeditor feels that the sentence as written is
imprecise. You forgot the number of monkeys, so you are tempted to use
the substitution \ci{s/[0-9] monkeys/Callimico goeldii/g}---but this will
lose the number of monkeys.

However, you can put a segment of the search term in parentheses, and
then use \ci{\textbs{}1} in sed or \ci{\$1} in Perl to refer to it in the replacement. Thus, the
correct command lines for replacing an unknown number of monkeys are:
\begin{lstlisting}
sed -i~ -e "s/\\([0-9]\\) monkeys/\\1 Callimico goeldii/g" monkey_file
perl -p -i~ -e "s/([0-9]) monkeys/\$1 Callimico goeldii/g" monkey_file
\end{lstlisting}
The \ci{\textbs{}1} or \ci{\$1} will be replaced by whatever was found in the
\ci{([0-9])} portion of the search.

If there are multiple substitutions to be made, you will need higher
numbers. Say that we would like to formalize the sentence \ci{the 7 monkeys are fighting the 4 lab
owners}. We could do this via:
\begin{lstlisting}
sed -i~ -e "s/\\([0-9]\\) monkeys are fighting the \\([0-9]\\) lab owners/\\1 Callimico goeldii are fighting the \\2 Homo sapiens/g" monkey_file
\end{lstlisting}

\subsection{Selecting in detail}
Let us say that values under ten in the data are suspect, and should be
replaced with \ci{"NaN"}. The search \ci{s/[0-9]/"NaN"/g} won't work,
because \ci{45} will be replaced by \ci{"NaN""NaN"}, since both \ci{4}
and \ci{5} count as separate matches. 

Let us say that values over ten are suspect. The search
\ci{s/[1-9][0-9]/"NaN"/g} won't work, because \ci{100} would be replaced by
\ci{"NaN"0}.

In short, to successfully search and replace, we need to be able to
specify a segment of text in great detail. This section will provide a
few more tools and a lot of notes about how one specifies exactly the
right text.

\paragraph{Repetition} 
Here are some symbols to match repetitions.
\begin{center}
\fbox{
\begin{tabular}{rl}
\ci{*}	& the last atom appears zero or more times\\
\ci{+}	& the last atom appears one or more times (GNU grep/sed: \ci{$\backslash$+})\\
\ci{?}	& the last atom appears zero or one times (GNU grep/sed: \ci{$\backslash$?})
\end{tabular}
}
\end{center}

To replace all of the numbers less than 100 in a file:
\begin{lstlisting}
perl -pi~  "s/([^0-9]|^)([0-9][0-9]\\?)([^0-9]|\$)/\\$1NaN\\$3/g" search_me
\end{lstlisting}
This is a mess, but a very precise mess. The first part,
\ci{([\that 0-9]|\that)} will match either a non-numeric character
or the beginning of the line. The second part,
\ci{([0-9][0-9]\textbs{}?)},
matches either one or two digits (but never three). The third part, 
\ci{([\that0-9]|\$)} will match either a non-numeric character
or the end of the line. Thus, we have precisely communicated that we
want something, then a number under 100, then something else.
Since the search string used three sets of parens, the output string
can refer to all three. It repeats the first and last verbatim, and
replaces the second with \ci{NaN}, as we had desired.

\exercise{Modify the search to include an optional decimal of arbitrary
length. Write up a test file and test that your modification works
correctly.}


\section{Adding and deleting}

Recall the format for the command to print a line from page
\pageref{sedintro}: \ci{/find\_me/p}. This consists of a location and a
command. With the slashes, the location is: those lines that match
\ci{find\_me}. You can also explicitly specify a line number or a range
of lines. To print line seven, use \ci{7p}. Just as the \ci{\$} indicates the
end of the line, as a line number it indicates the last line in the
file, so use \ci{sed -n "\$p" < infile} to print the last line of
\ci{infile}.  To specify a range, use a comma. Thus, 
\ci{sed -n "1,\$p" < infile} prints the entire file.

There are more commands than just \ci{p} for print. You could use \ci{d}
to delete, \ci{i} to insert above the given line, and \ci{a} to append
after the given line. \ci{d} will accept a range of
addresses, and generally behaves like \ci{p}.
But \ci{i} and \ci{a} will work on only one line at a time, so they may
not be preceded by a comma-separated range. They are immediately followed
by the text to insert, so like regexes, they have a disconcerting lack of
delimiters between the address, command, and text elements.

\begin{lstlisting}
#Add a pause after a Gnuplot data block
sed -i~ -e "/^e$/apause pauselength." plotfile
#Put the text plot '-' at the head of a file.
sed -i~ -e "1iplot '-'" plotfile
#Pretend missing data does not exist
sed -i~ -e "/NaN/d" plotfile
\end{lstlisting}

By the way, if you really want to get sed to print ``Hello, world'' you
can do it by inserting at one line and ignoring the rest of the file:
\begin{lstlisting}
sed -n -e "1iHello, world." < any_random_file
\end{lstlisting}

Perl can do all of these things easily from inside a Perl script,
but inserting and deleting lines from the command line is not as
pleasant as using \bi{sed}.\footnote{\label{dchperl}
A reader recommends the following for deleting a line:\\
        \bi{perl -n -e 'print unless /NaN/'}\\
For inserting a line:\\
        \bi{perl -n -e 'print; print "pause pauselength." if /\that{}e\$/'}\\
For adding a line at the top of a file:\\
        \bi{perl -p -e 'print "plot \'-\'\textbs{}n" unless \$a; \$a=1'}\\
}


\exercise{\label{classextwo} 
Refer to the exercise on page \pageref{classex}, which read in
a text file and produced a Graphviz-readable output file. That exercise
read the text to an \ci{apop\_data} set and then wrote the output, which
is sensible when pulling many classes from a database. But if you have
the text file \bi{data-classroom}, you can modify it directly into 
Graphviz's format. Write a sed script to:
\begin{itemize}
\item Delete the header line.
\item Replace each pipe with a \ci{->}.
\item Replace each number $n$ with \ci{node}$n$.
\item Add a header (as on page \pageref{graphhead}).
\item Add the end-brace on the last line.
\end{itemize}
Pipe your output through \bi{neato} to check that your processing produced
a correctly \bi{neato}-readable file.
}

\exercise{Turn the \bi{data-classroom} file into an SQL script to create
a table.
\begin{itemize}
\item Delete the header line.
\item Add a header \si{create table class(ego, nominee)}. [Bonus points:
write the search-and-replace that converts the existing header into this
form.]
\item Replace each pair of numbers \ci{n|m} with the SQL \si{insert into
class(n, m);}.
\item For added speed, put a \si{begin;}/\si{commit;} wrapper around the entire file.
\end{itemize}
Pipe the output to \bi{sqlite3} to verify that your edits correctly created and populated the table. 
}

\summary{
\item Your best bet for command-line search-and-replace is Perl or sed. Syntax:
\bi{perl -pi~ "s/replace me/with me/g" data\_file} or
\bi{sed -i~ "s/replace me/with me/g" data\_file}.
\item If you have a set of parens in the search portion, you can refer
to it in the replace portion by \ci{\textbs\$1}, \ci{\textbs\$2}, et
cetera.
\item The \ci{*}, \ci{+}, and \ci{?} let you repeat the previous
character or bracketed expression.
}

\section{More examples}

\paragraph{Quoting and unquoting}
Although the dot character seems convenient, it is almost never what you
want. Let us say that we are looking for expressions in quotes,
such as \ci{"anything"}. It may seem that this translates to the regular
expression \ci{".*"}, meaning any character, repeated zero or more
times, enclosed by quotes. Now consider this line: \ci{"first bit",
"second bit"}. You meant to have two matches, but instead will get only
one: \ci{first bit", "second bit}, since this is everything between the
two most extreme quotes. What you meant to say was that you want anything
that is not a \ci{"} between two quotes. That is, \ci{"[\that"]"}. 

Say that the program that produced your data put it all in
quotes, but you are reading it in to a  program that does not like
having quotes. Then this will fix the problem:
\begin{lstlisting}
perl -pi~ "s/\"([^\"])\"/\\$1/g" data_file
\end{lstlisting}
Notice that we need to indicate to the command line that the quotes are
not ending the Perl command, so they are all prepended with backslashes.

\paragraph{Getting rid of commas}
Some data sources improve human readability by separating data by
commas; for example, we see from \ci{data-wb-gdp} that the USA's GDP for
2005 was \$12,455,068 million. Unfortunately, if your program reads
commas as field delimiters, this human-readability convenience ruins
computer readability. But commas in text are entirely valid, so we want
to remove only commas between two numbers. We can do this by searching
for a number-comma-number pattern, and replacing it with only the
numbers. Here is the \ci{sed} command-line version of the process:
\begin{lstlisting}
sed -i~ -e "s/\([0-9]\),\([0-9]\)/\\1\\2/g" fixme
\end{lstlisting}


More forthcoming.


\comment{
Let us say that we have comma-delimited text, and we need any element that
is not a number to be put in quotes. First, let's construct some
numbers. One type of number is just digits, perhaps preceded by
a sign: \ci{([+-]|)[0-9]+}. Another type of number includes a
decimal point, and at least one digit before the decimal:
\ci{([+-]|)[0-9]+\textbs{}.[0-9]*}. Another type has at least one digit after
the decimal: \ci{([+-]|)[0-9]*\textbs{}.[0-9]+}. Another type is in scientific
notation, with a sign, a single digit, then a decimal, then more digits, then an
\ci{e}, then a sign and more digits:
\ci{([+-]|)[0-9]\textbs{}.[0-9]*e[+-][0-9]*}.

We can use the \ci{(A|B|C)} form to combine these into a form that any number will match:
\ci{([+-]|)([0-9]+|{}[0-9]+\textbs{}.[0-9]*|{}[0-9]*\textbs{}.[0-9]+|{}[0-9]\textbs{}.[0-9]*e[+-][0-9]*)}.


Now, let us be precise about what
a non-numeric element is. It:
\begin{itemize}
\item begins with either a beginning-of-line or comma,
\item does not match the monolithic pattern above,
\item and ends with a comma or an end-of-line.
\end{itemize}

The first item translates to 


}
