\renewcommand\thechapter{\Alph{chapter}}
\setcounter{chapter}{1}
\setcounter{section}{0}
\setcounter{subsection}{0}
\setcounter{ex}{0}
\setcounter{lstlisting}{0}
\setcounter{figure}{0}
\chapter{Appendix \thechapter: Paths and Makefiles}

Since C is a standard, and not a product from a single corporation
or foundation, different C environments have minor, potentially maddening
differences. 

The problem of whether a decent compiler and useful libraries 
are available on a given system has basically been surmounted by the
package manager. If something is missing, just ask the package manager
to install it from the Internet.
But then the next question is: where did the package manager put
everything? Some systems like to put libraries in \bi{/usr/local}, some like
to put them in \bi{/opt/}, and neither of these locations even makes
sense for the ever-eccentric Windows operating system.

The solution is to set \vocab{environment variables} that will specify
how your compiler will find the various elements it needs to produce
your program.\label{makeappendix}

\section{Environment variables} If you type \bind{env} at the command
prompt, you will get a list of the environment variables set on your
system. Here is a sampling from my own prompt: 
\begin{lstlisting}[language=sh]
SHELL=/bin/bash
USER=klemens
LD_LIBRARY_PATH=/usr/local/lib:
PATH=/home/klemens/tech/bin:/usr/local/bin:/usr/bin:/sbin:/bin:/usr/games:/sbin
HOME=/home/klemens
\end{lstlisting}

These variables are maintained by the operating system, and every time
a program spawns a new subprogram, the environment variables are duplicated
and passed to the child program.  Notably, when you type a command at the
shell prompt, all of the environment variables you saw when you typed
\bi{env} are passed on to the program.

The \bi{env} command is often used in conjunction with \bi{grep} (see
page \pageref{grep}). For example, to find out which shell you are using,
try \bi{env | grep SHELL}.

\paragraph{Setting}
Now that you know which shell you are using, the syntax for setting environment
variables differs slightly from shell to shell.

\index{bash}
You are probably using \bi{bash} or another variant of the \ind{Bourne
shell}.\footnote{\bi{bash}=Bourne-again shell.} In these systems,
set environment variables using the shell's \bind{export} command:
\begin{lstlisting}[language=sh]
export USER=Steven
\end{lstlisting}
Some shells are picky about spacing, and will complain if
there is a space before or after the equals sign. Others do not even
accept this syntax, and require a two-line version:
\begin{lstlisting}[language=sh]
USER=Steven
export USER
\end{lstlisting}

The other family of shells is the \ind{C shell}, which bears a vague, passing
resemblance to the C programming language. In \bi{csh}, use \bi{setenv}:
\begin{lstlisting}[language=csh]
setenv USER Steven
\end{lstlisting}

\paragraph{Getting} In all shells, and many shell-like programs, one
gets the value of a variable by prepending it with a dollar sign. For
example,
\begin{lstlisting}[language=sh]
echo $USER
\end{lstlisting}
will print the current value of the \bi{USER} variable to the screen.
Further, 
\begin{lstlisting}[language=sh]
export PATH=$PATH:$HOME/bin
\end{lstlisting}
will extend the \bi{PATH}, replacing that variable with a copy of itself
plus another directory at the end. For my own already lengthy path, this command would result in the following new path:
\begin{lstlisting}
PATH=/home/klemens/tech/bin:/usr/local/bin:/usr/bin:/sbin:/bin:/usr/games:/sbin:/home/klemens/bin
\end{lstlisting}

\paragraph{Setting for good}
Every time your shell starts, it reads a number of \ind{configuration files};
see your shell's manual page (\bi{man bash}, \bi{man csh}, \&c) for
details. But almost all of them read a file beginning with a dot and
ending in \bi{rc}, such as \bi{.bashrc} or \bi{.cshrc}. 

\index{hidden files} \index{files!hidden} \index{dot files}
It is a POSIX
custom that if a file begins with a dot, then it is hidden, meaning that the usual
directory listing, such as \bi{ls}, will not show these files. However,
if you explicitly ask for hidden files, via \bi{ls -a}, \bi{ls -d .*}, or your GUI
file browser's ``show hidden'' option, you will certainly find a number
of \bi{.rc} files in your home directory. Also, when making backups of
your home directory, it is worth verifying that hidden files are also
backed up.

The \bi{.rc} files are plain text, and generally look like the sort of
thing one would type on a command line---because that is what they are.
If you put an \bi{export} or \bi{setenv} command in this file, then 
those commands will be read every time your shell starts, and the
variables will thus be set appropriately for all of your
work.\footnote{Remember, when you first edit the file, it is not auto-read, so either exit and
re-enter the shell to see the effects of your edit, or use \bi{source
.bashrc} to explicitly ask the shell to read the file.}

\paragraph{\treesymbol Getting and setting from C}
It will be no surprise that it is very easy to read and write 
environment variables from within a C program. Listing \ref{env}
shows that the \cind{getenv} function will return a string holding the value of the
environment variable, and \cind{setenv} will set the given environment
variable (on line 6, \ci{USER}) to the given value (``Steven''). The third
argument to \ci{setenv} specifies whether an existing environment variable
should be overwritten. There are a few other useful environment-handling
functions; see your standard C library reference for details.\footnote{Why
is it safe to run the program in Listing \ref{env}, which will overwrite
an important environment variable? Because a child process (your program)
can not overwrite the  environment variables of a parent process (the
shell). Overriding this basic security precaution requires explicit
cooperation from the parent process.}

\lstset{numbers=left, numberstyle=\scshape}
\codefig{env}{Getting and setting environment variables.}
\lstset{numbers=none}

\summary{\item The operating system maintains a set of variables
describing the current overall environment, such as the user's name or
the current working directory.
\item These enviornment variables are passed to all child programs.
\item They can be set or read on the command line or from within 
a program.}

\section{Paths} On to the problem of getting your C compiler to
find your libraries. 

You may already be familiar with the shell's \vocab{path}. When you type
a command without an explicit directory, such as \bi{ls}, \bi{gcc}, or
\bi{echo}, the shell checks each directory listed in the \bi{PATH}
environment variable, in sequential order, for the program you
requested. Note well that if the current directory, \bi{./}, is not in
the path, then programs you can see with \bi{ls} can not be run. The
solution is to either give an explicit path, \bi{./run\_me}, or to add
the current directory to your path:\footnote{Including the current
directory in the path is often considered to be a security risk. If the
current directory is at the head of the path, a
malicious user could put a script named \bi{ls} in a common directory,
where the script
contains the command \bi{rm -rf \$HOME}. When you try to get a directory
listing, the shell instead finds the malicious script, and your home
directory is erased. Putting the current directory at the end of the
path provides slightly more protection, but the malicious script could
instead be named after a common typo, such as \bi{c} or \bi{mr}.
But given that many of today's POSIX computers are used by one person
or a few close associates, adding \bi{./} to the path is probably not
a real risk for most users.}
\begin{lstlisting}[language=sh]
export PATH=$PATH:./
\end{lstlisting}

There are two paths that are relevant to compliation of a C program: the
include path and the library path.\footnote{Java users will notice a
close resemblance between these paths and the \bi{CLASSPATH} environment
variable.} The procedure is the same as with the shell's executable
path: when you \cind{\#include} a file using angle brackets (e.g., lines
1 and 2 of Listing \ref{env}), then the preprocessor
searches the include path to find the requested header file. When the
linker needs to get a function or structure from a library, it searches
the libpath for the requested library.

The complication is that there are several ways for a directory to
appear on the include or library path.

\begin{itemize}
\item There is a default include path and a default library path,
precompiled into the system. This typically includes \bi{/usr/include}
\bi{/usr/local/include} in the include path, and \bi{/usr/lib} and \bi{/usr/local/lib}
in the libpath.
\item The environment variables \bi{INCLUDEPATH} and \bi{LIBPATH} are
part of the path. These names are sometimes different, depending on the linker
used: \bi{gcc} uses \bi{ld}, so it looks for
\bi{LD\_LIBRARY\_PATH}---except on Mac systems, where it looks for
\bi{DYLD\_LIBRARY\_PATH}. On HP-UX systems, try \bi{SHLIB\_PATH}. Or more
generally, try \bi{man ld} or \bi{man cc} to find the right environment
variable for your system. Some libraries are \airq{shared}, which in
this context means that they are linked when actually called in
execution. Thus, when you execute your newly-complied program, you could
still get a missing library error; to fix this you would need to add to
your \bi{LIBRARY\_PATH} environment variable.
\item You can add to the paths on the compiler's command line. The flag
\bi{-I/usr/local/include} would add that directory to the include path,
and the flag \bi{-L/usr/local/lib} would add that directory to the
library path. 
\end{itemize}

\paragraph{Assembling the compiler command line} The header files are
all specified in the source code itself, and therefore do not need to
be specified on the command line, so the only addition on the command
line is the paths for include files in nonstandard locations, using the
\bi{-I} flag, as above.

However, there is nothing in your source code that tells the system which
libraries are to be linked in, and the libraries must therefore be listed
on the command line. First, you will list the non-standard directories
to search, using the \bi{-L} flag, then you will need another flag for
each library to be called in.

{\em Order matters when specifying libraries.} Begin with the
most-dependent library, and continue to the least dependent.
The Apophenia library depends on SQLite3 and the GSL library---which
depends on a BLAS library like the GSL's companion CBLAS. If your
program already has an object file named \bi{source.o} and you want the
output program to be named \bi{run\_me}, then you will need to specify
one of 
\begin{lstlisting}
gcc source.o -lapophenia -lgsl -lcblas -lsqlite3
or
gcc source.o  -lsqlite3 -lapophenia -lgsl -lcblas
\end{lstlisting}
The Sqlite3 library is the only one that is not dependent on or a
dependency of other libraries, and therefore is the only one that can be
placed anywhere. The others must be in this order for the compilation to
work.\footnote{With some linkers, order does not matter. If this is the case on your system, consider yourself
lucky, but try to preserve the ordering anyway to ease any potential
transition to another system.} You may also need to specify the location of some of these
libraries; this will have to come first, and the command now looks like:
\begin{lstlisting}
gcc -L/usr/local/lib source.o -lapophenia -lgsl -lcblas -lsqlite3
\end{lstlisting}
This is an immense amout of typing, but fortunately, the next section
offers a
program explcitly designed to save you from such labor.

\summary{
\item Many systems, including the shell, the preprocessor, and the
linker, search a specified directory path for requested items.
\item The default path for the preprocessor and linker can be extended
via both environment variables and instructions on the compiler's command line.
}


\section{Make} \label{make} \index{make@\bi{make}|(}\vocabmarker{make}
The \bi{make} program provides a convenient system for you to specify
flags for warnings and debugging symbols, include paths, libraries to
link to, and who knows what other details.  You write a Makefile (capital
M) that describes what source files are needed for compilation and the
flags the compiler needs on your system, and then \bi{make} assembles the
elaborate command line required to invoke the compiler. Many programs,
such as \bind{gdb}, \ind{vi} and \ind{EMACS}, will even let you run
\bi{make} without leaving the program.  Because assembling that command
line by hand is so time consuming and error-prone, you are strongly
encouraged to have a Makefile for each program.

For concreteness, 
Listing \ref{makefig} is a Makefile for a program named \ci{run\_me},
which has two {\tt .c} files and one header file. It is not very far
removed from the sample Makefile in the online code supplement.

\begin{figure}[htb]
\lstset{float=htb,%
xleftmargin=\mwidth,%
%frameshape={nyn}{nnn}{nnn}{nyn},%
showstringspaces=false,basicstyle=\small, emphstyle=\bf\small,%
caption={A sample Makefile for a program with two source files.},
breaklines=true,label=makefig}
\begin{lstlisting}
OBJECTS = file1.o file2.o           #User-defined
PROGNAME = run_me                   #User-defined
CFLAGS = -g -Wall
LINKFLAGS = -L/usr/local/lib -lgsl -lgslcblas -lsqlite
COMPILE   = gcc $(CFLAGS) -c $< -o $@

$(PROGNAME): $(OBJECTS)
        gcc $(CFLAGS) $(OBJECTS) $(LINKFLAGS) -o$(PROGNAME)

file1.o: file1.c my_headers.h       #User-defined
        $(COMPILE)
file2.o: file2.c my_headers.h       #User-defined
        $(COMPILE)
\end{lstlisting}
    \setlistdefaults
\end{figure}

The \bi{make} program does two types of calculation: expanding variable
names and folowing dependencies. \vocabmarker{dependency}

\paragraph{Variable expansion}
Variable names in a Makefile look much like environment
variables, and behave much like them as well. They are slightly easier to
set---just use \bi{VAR = value}---and when referencing them, use a
dollar sign and parens: \bi{\$(VAR)} will expand to \bi{value}.
The environment variables are also available this way, so
your Makefile can include definitions like \bi{INCLUDEPATH =
\$(INCLUDEPATH):\$(HOME)/includes}.  Like the custom for environment
variables, variables in Makefiles are customarily in all caps, and as
with constants in any program, they are grouped at the top of the file
for ease of reference and adjustment. 

This is where you can place the include path, library path, and included
libraries that works best for your system. Most C-oriented Makefiles
include variables named \bi{CFLAGS} and \bi{LINKFLAGS}, which hold
for the compiler/preprocessor-specific flags, and the library-specific
flags.

The \ci{\$<} and \ci{\$@} variables (in the \bi{COMPILE} variable
definition) are special variables that indicate the dependency and target,
respectively, which brings us to the discussion of dependency handling.

\paragraph{Dependencies}
The remainder of the file is a series of target/dependency pairs and
actions. A \airq{target} is something to be produced. Here the targets
are object
files and an executable, and on page \pageref{latexmake}, there is a Makefile
whose targets are PDFs and graphics. The \airq{dependency} is the file
containing the data used to produce the target. An object file depends
on the C source code defining the functions and structures, an
executable depends on the object files being linked together, and a PDF
document depends on the underlying text. Notice that in most of these
cases, the dependency is data that you yourself wrote, while the target is
always computer generated. 

The lines with colons, such as \ci{file1.o: file1.c my\_headers.h}, are
target/dependency descriptions: the single item on the left is the
target, and the one or several items on the right are the files upon
which the target depends.

After each target line, there are instructions for building the target
from the dependencies. For a simple C program, the instructions are one
line (typically a call to \ci{gcc}). The Makefile on page
\pageref{latexmake} shows some more involved target build scripts that
span several lines. 

An important annoyance: the lines describing the building
process are tab-indented. If your text editor replaces tabs with a set
of spaces, \ci{make} will fail.

Having described the format of the Makefile, let us go over the process
that Make will go through when you type \bi{make} on the command line.
The first target in a Makefile is the default target, and is where
\bi{make} begins if you do not specify a target on the command line. So
\ci{make} looks at the target specification, and, using its powers of
variable expansion, sees that \ci{run\_me} depends on \ci{file1.o} and
\ci{file2.o}. Let us assume that this is the first time the program is
being built, so neither object file exists. Then \ci{make} will search
for a rule to build them, and thus digresses to the later targets.
There, it executes the command specified by \ci{\$(COMPILE)}.
Having created the targets, it then returns to the original target, and
runs the command to link together the two object files. 

Let us say that you then modify \bi{file1.c} (but none of the other
files) and then call \bi{make} again. The program again starts at the
top of the tree of targets, and sees that it needs to check on
\bi{file1.o} and \bi{file2.o}. Checking the dependencies for
\bi{file1.o}, it sees that the file is not up-to-date, because its
dependency has a newer time stamp.\footnote{What should you do if the
time stamp on a file is broken, because it was copied from a computer in
a different time zone or was otherwise mis-stamped? The \bind{touch}
command will update the time stamp on a file to the current time.}
So \bi{file1.o} is recompiled, and \bi{run\_me} then recreated. Notice
that \bi{make} knows that \bi{file2.o} does not need to be recompiled,
and so it does not bother to do so. In a larger project, where
recompilation of the whole project can take several seconds, \bi{make}
will thus save you time as well as typing.


\exercise{Take one of the sample programs you wrote in Chapter
\ref{c_crash} and create a directory for it.
\begin{itemize}
\item Create a new directory, and copy over the \bi{.c} file. 
\item Copy over the sample \bi{Makefile} from the online sample code.
\item Modify the \ci{PROGNAME} and \ci{OBJECTS} line to correspond to
your project. 
\item  You may also need to change the \bi{LINKFLAGS}
line if you get errors from the linker about symbols not found.
\item Type \ci{make} and verify that the commands it prints are what
they should be, and that you get the object and executable files you
expected.
\end{itemize}
}

\summary{\item The Makefile summarizes the method of compiling a program
on your system.
\item At the head of the Makefile, place variables to describe the flags
needed by your complier and linker.
\item The Makefile also specifies what files depend on what others, so
that only the files that need updating are updated.
\item The command-line program \bi{make} will assemble the full command
lines to execute from the Makefile.
}

\index{make@\bi{make}|)}
