\startonecol \chapter{Gnuplot} \label{gnuplot} \endonecol
%@-     so lgrind will play nice with makeindex
\index{Gnuplot|(}
\index{plotting|see{Gnuplot}}
\index{graphing|see{Gnuplot}}

This chapter will give you some tips on plotting using Gnuplot, a graphing
package that is as open and freely available as gcc.\footnote{There is
some politics about how this is not strictly true: the maintainers of
Gnuplot will not allow you to modify their code and then distribute the
modified package independently (i.e., to \airq{fork} the code base). The project is entirely unrelated to the
GNU, and the name is simply a compromise between the names that the two
main authors preferred: nplot and llamaplot.}

\paragraph{The language} Gnuplot does nothing but plot points and
lines. As such, the language only has one verb---\ci{plot}---with
a few variants (\ci{splot}, \ci{replot}). A Gnuplot command
file generally consists of a long string of \ci{set} commands to
indicate what the axes should look like, the point and line formats,
et cetera, and a final \ci{plot} command to do the actual work.


\section{From arrays to plots} \label{gnuprint}
The line \ci{plot '-';} tells Gnuplot to plot the (2-D) data to come. The
command for a 3-D plot is \ci{splot '-'}. That means that the process
of turning a matrix into a basic plot is trivial. Let \ci{data} be an
\ci{apop\_data} set whose first and fifth columns we would like to plot
against each other. Then we need to create a file, put a \ci{plot
'-';} command in the first line, and then fill the remainder with the
data to be plotted.  
\begin{lstlisting}
FILE    *f = fopen("plot_me", 'w');
fprintf("plot '-' using 1:5;\n");
fclose(f);
apop_data_print(data, "plot_me");
\end{lstlisting}

The second option to \cind{fopen} should be either \ci{'a'} for append or
\ci{'w'} for write anew; in this case, we want to start with a clean file so we use \ci{'w'}.
Notice that \cind{apop\_data\_print} defaults to appending; you
would need to set \ci{apop\_opts.output\_append = 0} to overwrite.
\cindex{apop\_opts.output\_append}

The clause \ci{using 1:5} in the plot command tells Gnuplot to use
only the first and fifth columns of the data set---so there is no need to pare
down the data set in memory. Notice that the first column in Gnuplot is
1, not 0. At the end of this, \ci{print\_me} will be executable by
Gnuplot. There are a few ways to get Gnuplot to read the file from the
typical UNIX-style command prompt:
\begin{lstlisting}
gnuplot -persist < plot_me
(or)
gnuplot plot_me -
\end{lstlisting}
The first option will open a window and leave the command line inactive
until you close the window;
the second will give you a Gnuplot command line that you will have to
manually exit
from (by typing \ci{exit} or $<$ctrl$>$-D, or you can send in more
Gnuplot commands). On many systems, you can
interact with the plot, spinning 3-D plots with the mouse or selecting
subregions of 2-D plots to zoom into.

\subsection{Histograms} \index{histograms!plotting|(}
Gnuplot, refusing to do calculations for you,
makes making histograms a pain.  Fortunately, the GSL has you covered,
with the \cind{gsl\_histogram} object, which will also appear
in Section \ref{randomnumbers}, when we needed to generate PDFs from data.

It creates a set of bins, and
then you can call \ci{gsl\_histogram\_increment} to put
data into the right bin. Below is the code for \cind{apop\_plot\_hist\-o\-gram}. 
It allocates a histogram with
\ci{bin\_ct} bins, then sets its range to just past the min and max
of the data. Then the \ci{for} loop pulls data points from the vector and
dumps them to the histogram, without any further calculation on our part.
Once everything is neatly aggregated, the function opens a file and dumps the data to a Gnuplottable file. There is an example of this function in use in Figure \ref{draw_beta_curve}, page \pageref{draw_beta_curve}.
\startonecol
\begin{lstlisting}
void apop_plot_histogram(gsl_vector *data, size_t bin_ct, char *outfile){
int             i;
FILE *          f;
double          min, max, pt;
gsl_histogram   *h      = gsl_histogram_alloc(bin_ct);
    gsl_vector_minmax(data, &min, &max);
        gsl_histogram_set_ranges_uniform(h, min-GSL_DBL_EPSILON, max+GSL_DBL_EPSILON);
    for (i=0; i < data->size; i++){
        pt  = gsl_vector_get(data, i);
        gsl_histogram_increment(h, pt);
        }

    //Now that you have a histogram, print it.
        if (outfile == NULL)    f       = stdout;
        else            f       = fopen(outfile, "a");
    fprintf(f, "set key off                                     ;\n\
                        set style data histograms               ;\n\
                        set style histogram cluster gap 0       ;\n\
                        set xrange [0:%i]                       ;\n\
                        set style fill solid border -1          ;\n\
                        set boxwidth 0.9                        ;\n\
                        plot '-' using 2:xticlabels(1);\n", bin_ct);
    for (i=0; i < bin_ct; i++)
    fprintf(f, "%4f\t %g\n", h->range[i], gsl_histogram_get(h, i));
    if (outfile !=NULL)    fclose(f);
}
\end{lstlisting}
\endonecol
\index{histograms!plotting|)}

\section{Printing} \index{Postscript} 
Once your plot looks nice on the screen, you can put it on paper or a
report by simply setting the right variables. Notably, the commands
\begin{lstlisting}
set terminal postscript;
set out 'outfile.eps';
\end{lstlisting}
at the head of a file will put the plot in \bi{outfile.eps} rather
than posting it to the screen. Since all of the plotting commands append
by default, one could start the file off with this command, and then
call a plotting command to produce a paper-printing Gnuplot command file.\footnote{If you use the \bi{replot} command to print multiple plots, set the terminal to postscript just before the last replot. otherwise, your paper will show a confusing blur of multiple plots.}

The following snippet will erase a file, and
if \ci{print\_to\_paper} is true, place a header setting Gnuplot to
print to \bi{outfile.eps}; if it is false, Gnuplot will default
to printing to screen.

\begin{lstlisting}
char *gnuplot_file = "plot_me";
char *graph_file = "outplot.eps";
FILE    f = fopen(gnuplot_file, "w");//overwrite the file
    if (print_to_paper)
        fprintf(f, "set terminal postscript;\nset out '%s';\n", graph_file);
    fclose(f);
    apop_plot_histogram(data, 1000, gnuplot_file);
\end{lstlisting}

What to do with an \bi{eps} file? For those who just want a quick
printout, your best best is probably to run the command \bi{ps2pdf}
to produce a PDF file, which can be viewed with familiar PDF viewers
such as Acrobat Reader. On a system with GhostScript, the \bi{eps} file
can be viewed and printed directly.

\paragraph{\treesymbol \LaTeX}\index{Latex@\LaTeX} \index{Tex@\TeX}
If you are including the  figure in a \LaTeX{} report, you can use the
\airq{graphicx} package to incorporate the plot. E.g.:
\begin{lstlisting}[language=sql]
\documentclass{article}
\usepackage{graphicx}
\begin{document}
...
\begin{figure}
\rotatebox{-90}{\scalebox{.35}{\includegraphics{outfile.eps}}}}
\caption{This figure was autogenerated by a C program.}
\end{figure}
...
\end{document}
\end{lstlisting}
Notice that you will frequently need to rotate the plot $90^\circ$
and scale the figure down to a reasonable size.

Depending on the system, the reader may be able to generate PDFs with
embedded Postscript images directly using \bi{pdflatex}, or may
need to do it indirectly via Postscript: 
\begin{lstlisting}[language=sql]
latex a_report
dvips < a_report.dvi > a_report.ps
ps2pdf a_report.ps
\end{lstlisting}

This is a lot of typing, but there is a way to automate the process:
\ind{make}. Below is a sample Makefile for producing a \LaTeX{} document
should \bi{pdflatex} be quarrelsome on your system. As with your C
programs, once the Makefile is in place, you can generate final PDF
documents by just typing \bi{make} at the command line. The
creative reader could readily combine this Makefile with the sample C
Makefile from page \pageref{make} to regenerate the final report every
time the analysis is updated.

\begin{lstlisting}[language=make]
DOCNAME = a_report

pdf:	$(DOCNAME).pdf

$(DOCNAME).dvi: $(DOCNAME).tex
	latex $(DOCNAME); latex $(DOCNAME)

$(DOCNAME).ps: $(DOCNAME).dvi
	dvips  -f < $(DOCNAME).dvi > $(DOCNAME).ps

$(DOCNAME).pdf: $(DOCNAME).ps
	ps2pdf $(DOCNAME).ps  $(DOCNAME).pdf

clean:
	rm -f $(DOCNAME).blg $(DOCNAME).log $(DOCNAME).ps
\end{lstlisting}


\section{Animation}\index{animation} Perhaps three dimensions is not
quite enough, and you need one more. Gnuplot easily supports animation:
just stack plots on after the next and call \ci{replot} in between. However,
many media (such as paper) do not yet support animation, meaning that your
output will generally be dependent on your display method. The \ind{GIF} format
provides animation and is supported by all major web browsers, so you
can also put your movies online.\footnote{Also, the U.S. patents on the
compression algorithm upon which the GIF format is based \citep{welch:lzw}
have expired, so the mathematical transformations required to write a
GIF may be executed without seeking a license.}

More detail forthcoming.




\index{Gnuplot|)}
