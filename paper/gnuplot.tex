\chapter{Gnuplot} \label{gnuplot} 
\index{Gnuplot|(}
\index{plotting|see{Gnuplot}}
\index{graphing|see{Gnuplot}}

This chapter will give you some tips on plotting using Gnuplot, a graphing
package that is as open and freely available as gcc.\footnote{There is
some politics about how this is not strictly true: the maintainers of
Gnuplot will not allow you to modify their code and then distribute the
modified package independently (i.e., to \airq{fork} the code base). The project is entirely unrelated to the
GNU, and the name is simply a compromise between the names that the two
main authors preferred: nplot and llamaplot.}

\paragraph{The language} Gnuplot does nothing but plot points and
lines. As such, the language only has one verb---\ci{plot}---with
a few variants (\ci{splot}, \ci{replot}). A Gnuplot command
file generally consists of a long string of \ci{set} commands to
indicate what the axes should look like, the point and line formats,
et cetera, and a final \ci{plot} command to do the actual work.


\section{From arrays to plots} \label{gnuprint}
The line \ci{plot '-';} tells Gnuplot to plot the (2-D) data to come. The
command for a 3-D plot is \ci{splot '-'}. That means that the process
of turning a matrix into a basic plot is trivial. Let \ci{data} be an
\ci{apop\_data} set whose first and fifth columns we would like to plot
against each other. Then we need to create a file, put a \ci{plot
'-';} command in the first line, and then fill the remainder with the
data to be plotted.  \label{fprintf}
\begin{lstlisting}
FILE    *f = fopen("plot_me", 'w');
fprintf("plot '-' using 1:5;\n");
fclose(f);
apop_data_print(data, "plot_me");
\end{lstlisting}

The second option to \cind{fopen} should be either \ci{'a'} for append or
\ci{'w'} for write anew; in this case, we want to start with a clean file so we use \ci{'w'}.
Notice that \cind{apop\_data\_print} defaults to appending; you
would need to set \ci{apop\_opts.output\_append = 0} to overwrite.
\cindex{apop\_opts.output\_append}

The clause \ci{using 1:5} in the plot command tells Gnuplot to use
only the first and fifth columns of the data set---so there is no need to pare
down the data set in memory. Notice that the first column in Gnuplot is
1, not 0. At the end of this, \ci{print\_me} will be executable by
Gnuplot. There are a few ways to get Gnuplot to read the file from the
typical UNIX-style command prompt:
\begin{lstlisting}
gnuplot -persist < plot_me
(or)
gnuplot plot_me -
\end{lstlisting}
The first option will open a window and leave the command line inactive
until you close the window;
the second will give you a Gnuplot command line that you will have to
manually exit
from (by typing \ci{exit} or $<$ctrl$>$-D, or you can send in more
Gnuplot commands). On many systems, you can
interact with the plot, spinning 3-D plots with the mouse or selecting
subregions of 2-D plots to zoom into.

\subsection{Lattices}  \index{lattices}
Perhaps plotting two pairs of columns at a time is not sufficient---you
want bulk, displaying every variable graphed against every other. For
this, use the \ci{apop\_plot\_lattice} function.

\begin{lstlisting}
apop_data *d = apop_text_to_data("indata", 0, 1);
apop_plot_lattice("outfile", d);
\end{lstlisting}
This produces a file that (after \bi{gnuplot -persist outfile}) produces
a plot like the one in Figure \ref{trellis}. Each variable is plotted
against each other, so the upper-left graph shows the SES variable
versus the Hirfindahl index for a set of data points. The lower-right
graph shows a mirror image of the same two variables. Along the diagonal
are plots of a variable against itself, and therefore these plots will
always be along the $45^\circ$ line. They give a quick picture of the
how a variable's density is distributed.

\begin{figure}
\rotatebox{-90}{\scalebox{.45}{\includegraphics{trellis.eps}}}
\caption{Three variables from my hard drive. Each is plotted against the
other.}\label{trellis}
\end{figure}

What is a lattice plot good for? Some call it \airq{getting a lay of the
land}, while others call it \vocab{data snooping}. Given ten perfectly
random variables, there is a good chance that at least one pair of
lattice plots will look to you like it demonstrates a nice correlation.
A formal regression on the chosen pair of variables will likely
verify your initial visual impression. 

One interviewer directly asked the people who first developed
this type of display, Rick Becker and Bill Cleveland,
whether this display method treads too close to data
snooping:\footnote{\url{http://stat.bell-labs.com/project/trellis/interview.html}}

\begin{quote}
{\em Inteviewer:} OK, but there is another way to approach the study of a large database:
develop a statistical model and see if it fits the data. If it does fit,
use the model to learn about the structure of the data.

{\em Becker \& Cleveland:} Yes, and Trellis
display\footnote{\vocab{Trellis display} is a trademarked term; therefore
this book and many common stats packages use the term \airq{lattice}
to refer to similar displays.} is a big help in doing this because it
allows you to make a good guess about an initial model to fit and then
to diagnose how well it fits the data. [\dots]

{\em Inteviewer:} But instead of agonizing over all those panels I could do a bunch of
chi-squared tests for goodness of fit.

{\em Becker \& Cleveland:} You're joking, right? If not, we're leaving.

{\em Inteviewer:} OK, I guess I'm joking.
\end{quote}

Since Becker and Cleveland do not elucidate the difference between their
visualization method and numerical data snooping, it is up to you to
decide whether such wide-reaching plots are a good first hack at the
data or merely facilitators of apophenia.

\subsection{Histograms} \index{histograms!plotting|(}
Gnuplot, refusing to do calculations for you,
makes making histograms a pain.  Fortunately, the GSL has you covered,
with the \cind{gsl\_histogram} object, which will also appear
in Section \ref{randomnumbers}, when we needed to generate PDFs from data.

It creates a set of bins, and
then you can call \ci{gsl\_histogram\_increment} to put
data into the right bin. Below is the code for \cind{apop\_plot\_hist\-o\-gram}. 
It allocates a histogram with
\ci{bin\_ct} bins, then sets its range to just past the min and max
of the data. Then the \ci{for} loop pulls data points from the vector and
dumps them to the histogram, without any further calculation on our part.
Once everything is neatly aggregated, the function opens a file and dumps the data to a Gnuplottable file. There is an example of this function in use in Figure \ref{draw_beta_curve}, page \pageref{draw_beta_curve}.
\begin{lstlisting}
void apop_plot_histogram(gsl_vector *data, size_t bin_ct, char *outfile){
int             i;
FILE *          f;
double          min, max, pt;
gsl_histogram   *h      = gsl_histogram_alloc(bin_ct);
    gsl_vector_minmax(data, &min, &max);
        gsl_histogram_set_ranges_uniform(h, min-GSL_DBL_EPSILON, max+GSL_DBL_EPSILON);
    for (i=0; i < data->size; i++){
        pt  = gsl_vector_get(data, i);
        gsl_histogram_increment(h, pt);
        }

    //Now that you have a histogram, print it.
        if (outfile == NULL)    f       = stdout;
        else            f       = fopen(outfile, "a");
    fprintf(f, "set key off                                     ;\n\
                        set style data histograms               ;\n\
                        set style histogram cluster gap 0       ;\n\
                        set xrange [0:%i]                       ;\n\
                        set style fill solid border -1          ;\n\
                        set boxwidth 0.9                        ;\n\
                        plot '-' using 2:xticlabels(1);\n", bin_ct);
    for (i=0; i < bin_ct; i++)
    fprintf(f, "%4f\t %g\n", h->range[i], gsl_histogram_get(h, i));
    if (outfile !=NULL)    fclose(f);
}
\end{lstlisting}
\index{histograms!plotting|)}

\subsection {Pruning data for display}
Plotting the entire data set may be detrimental for two reasons. The
first is the range problem: that one data point at $Y=$a million throws off the
whole darn plot. If you are using an interactive on-screen graph, you
can select a smaller region, but it would be better to just not plot
that point to begin with. 

The second reason for pruning is when the data set is too large. The black
blob you get from plotting ten million data points on a single piece of
paper is not very informative. In this case, you want to use only a
random subset of the data.

This section forthcoming. Summary: you can do this in SQL using the
typical \sinline{select * from plotme where value < 1e7} form to eliminate
those values greater than a million. 

One could do the same for random
numbers, although SQLite does not provide the friendliest of random
number generators. The \sind{random} function provides a single random
number between -2,147,483,647 and 2,147,483,647, which the reader will
recognize as $\pm 2^{31}-1$. So we need to pull a random number,
divide by $2^{31}-1$, thus producing a number in $[-1,1]$, then shift it
to the familiar $[0,1]$ range, and then compare it to a limit. The
query below does this to remove approximately half of the data set.
It uses the bit-shifting operator which I had promised you would never
need; read \ci{1<<x} as $2^x$.

\sinline{select * from plotme where (random()/(-(1<<31)-1.0)+1)/2  < 0.5}

\summary{
\item A Gnuplot command file basically consists of a group of \ci{set}
commands to specify how the graph will look, and then a single \ci{plot}
(2-D version) or \ci{splot} (3-D version) command. 
\item Using the \ci{plot '-'} form, you can put the data to be plotted
in the command file immediately after the command. You can use this and
\ci{apop\_data\_print} to produce plot files of your data.
}

\section{Printing} \index{Postscript} 
Once your plot looks nice on the screen, you can put it on paper or a
report by simply setting the right variables. Notably, the commands
\begin{lstlisting}
set terminal postscript;
set out 'outfile.eps';
\end{lstlisting}

at the head of a file will put the plot in \bi{outfile.eps} rather
than posting it to the screen. Since all of the plotting commands append
by default, one could start the file off with this command, and then
call a plotting command to produce a paper-printing Gnuplot command file.\footnote{If you use the \bi{replot} command to print multiple plots, set the terminal to Postscript just before the last replot. otherwise, your paper will show a confusing blur of multiple plots.}

The following snippet will erase a file, and
if \ci{print\_to\_paper} is true, place a header setting Gnuplot to
print to \bi{outfile.eps}; if it is false, Gnuplot will default
to printing to screen.

\begin{lstlisting}
char *gnuplot_file = "plot_me";
char *graph_file = "outplot.eps";
FILE    f = fopen(gnuplot_file, "w");//overwrite the file
    if (print_to_paper)
        fprintf(f, "set terminal postscript;\nset out '%s';\n", graph_file);
    fclose(f);
    apop_plot_histogram(data, 1000, gnuplot_file);
\end{lstlisting}

What to do with an \bi{eps} file? For those who just want a quick
printout, your best best is probably to run the command \bi{ps2pdf}
to produce a PDF file, which can be viewed with familiar PDF viewers
such as Acrobat Reader. On a system with GhostScript, the \bi{eps} file
can be viewed and printed directly. Since all of this research will
probably eventually turn into a report or paper, you can also smoothly
include it in \LaTeX{} documents.

\subsection{\treesymbol \LaTeX}\index{Latex@\LaTeX} \index{Tex@\TeX}
You have two options when putting a plot in a \TeX{}ed paper: native
\LaTeX{} and Postscript. 

\paragraph{Native format}
Just as you can set the output device to a screen or a Postscript printer,
you can also send it to a \LaTeX-formatted file. One the plus side, the
fonts will precisely match those in your document, and the resolution is
that of \TeX{} itself (100 times finer than the wavelength of
visible light). On the minus side, some features, such as color, are not
available.

Just as you can dump one C file into another via \ci{\#include}, you can
include the Gnuplot output via the \ci{$\backslash$input} command
\begin{lstlisting}
\documentclass{article}
\usepackage{latexsym}
\begin{document}
...
\begin{figure}
\input outfile.tex
\caption{This figure was autogenerated by a C program.}
\end{figure}
...
\end{document}
\end{lstlisting}

Another very common complaint: the Y-axis label isn't rotated right.
The solution provides a good example of how 
you can insert arbitrary \LaTeX{} code into your Gnuplot code.

First, in the Gnuplot file, you set the label to any set of instructions
that \LaTeX{} can understand. Let $\lambda$ be an arbitrary label:
\begin{lstlisting}
set ylabel "\\rotatebox{90}{Your $\lambda$ here.}"
\end{lstlisting}
Notice the double-backslash. Just as with \ci{printf} (see page
\pageref{printf}), expressions like \ci{$\backslash$n} have special
interpretations, so to print a plain backslash, you will need to double
it to \ci{$\backslash\backslash$}. 

If you are autogenerating this line from C, then you will again need to
double the backslash for each single backslash you will print to the
Gnuplot file. To print the line above to a file, use:
\begin{lstlisting}
fprintf(out, "set ylabel \"\\\\rotatebox{90}{Your $\\lambda$ here}\"\n ");
\end{lstlisting}

Two final notes to complete the example: \sinline{$\backslash$rotatebox}
is in the \bi{graphicx} package, so it needs to be called in the preamble: 
\begin{lstlisting}
\usepackage{latexsym, graphicx}
\end{lstlisting}
Second, \binline{xdvi} does not currently support rotation, so if you are
viewing via \TeX's native dvi format, the rotation won't happen. Use
either \binline{pdflatex} or \binline{dvips} to view the output as it
will print.

\paragraph{The Postscript route}\index{Postscript|(}
Which brings us to the second option for including a graphic:
Postscript.

Use the \airq{graphicx} package to incorporate the plot. E.g.:
\begin{lstlisting}[language={}]
\documentclass{article}
\usepackage{graphicx}
\begin{document}
...
\begin{figure}
\rotatebox{-90}{\scalebox{.35}{\includegraphics{outfile.eps}}}}
\caption{This figure was autogenerated by a C program.}
\end{figure}
...
\end{document}
\end{lstlisting}
Notice that you will frequently need to rotate the plot $90^\circ$
and scale the figure down to a reasonable size.

Depending on the system, the reader may be able to generate PDFs with
embedded Postscript images directly using \bi{pdflatex}, or may
need to do it indirectly via Postscript: 
\begin{lstlisting}[language=sql]
latex a_report
dvips < a_report.dvi > a_report.ps
ps2pdf a_report.ps
\end{lstlisting}

This is a lot of typing, but there is a way to automate the process:
\ind{make}. Below is a sample Makefile for producing a \LaTeX{} document
should \bi{pdflatex} be quarrelsome on your system. As with your C
programs, once the Makefile is in place, you can generate final PDF
documents by just typing \bi{make} at the command line. The
creative reader could readily combine this Makefile with the sample C
Makefile from page \pageref{make} to regenerate the final report every
time the analysis is updated.

\begin{lstlisting}[language=make]
DOCNAME = a_report

pdf:	$(DOCNAME).pdf

$(DOCNAME).dvi: $(DOCNAME).tex
	latex $(DOCNAME); latex $(DOCNAME)

$(DOCNAME).ps: $(DOCNAME).dvi
	dvips  -f < $(DOCNAME).dvi > $(DOCNAME).ps

$(DOCNAME).pdf: $(DOCNAME).ps
	ps2pdf $(DOCNAME).ps  $(DOCNAME).pdf

clean:
	rm -f $(DOCNAME).blg $(DOCNAME).log $(DOCNAME).ps
\end{lstlisting}
\index{Postscript|)}

\section{Animation}\index{animation} Perhaps three dimensions is not
quite enough, and you need one more. Gnuplot easily supports animation:
just stack plots one after the next and call \ci{replot} in between. However,
many media (such as paper) do not yet support animation, meaning that your
output will generally be dependent on your display method. The \ind{GIF} format
provides animation and is supported by all major web browsers, so you
can also put your movies online.\footnote{Also, the U.S. patents on the
compression algorithm upon which the GIF format is based \citep{welch:lzw}
have expired, so the mathematical transformations required to write a
GIF may be executed without seeking a license.}

More detail forthcoming.


\section{\treesymbol Instant gratification}
All of the above methods involved writing your commands data to a file and then 
running Gnuplot, but you may want to produce plots as your program runs.
This is often useful for simulations, to give you a hint that all is OK
while the program runs, and to impress your friends and funders. This is
easy to do using a \vocab{pipe}.\footnote{There is a readily available
package named \cind{gnuplot\_i} that provides some functions to simplify
piping commands to Gnuplot. It basically works via the same method as
the one discussed in this section, but has much more code to handle
settings and problem cases.}

The command \cind{popen} does two things: it runs the specified program,
and it produces a data pipe connecting your program to the now-running
child program. Any commands you write to the pipe is read by the child
as if someone had typed those commands into the program directly.

You can write to a pipe just like you would write to a file, using
\cind{fprintf}, meaning that once you have opened the pipe to
Gnuplot, the methods above really do apply directly.

You will want to use \cind{apop\_vector\_print} or
\cind{apop\_matrix\_print} to dump out the actual data. To do so, you
will need to set the output type to \ci{'p'} and specify the output
pipe. Lines 11 through 13 in the sample code below do this.
The command on line 14, \cind{fflush}, ensures that all of the data has
been flushed through the pipe and delivered to Gnuplot.

\label{pipeexample}
\begin{lstlisting}[numbers=left, numberstyle=\scshape]
void plot_vector_now(gsl_vector *data){
static FILE *gp = NULL;
int  i;
    if (!gp)
        gp = popen("/usr/local/bin/gnuplot -persist", "w");
    if (!gp){
        printf("Couldn't open Gnuplot.\n");
        return 0;
    }
    fprintf(gp,"reset; plot '-' \n");
    apop_opts.output_type = 'p';
    apop_opts.output_pipe = gp;
    apop_vector_print(data, NULL);
    fflush(gp);
}
\end{lstlisting} 

The \ci{popen} function takes in the full path to Gnuplot, and a \ci{w}
to indicate that you will be writing to Gnuplot rather than reading from
it. You can find where Gnuplot lives on your machine using the command
\bi{which gnuplot}. The \ci{popen} function then returns a file, here
assigned to \ci{gp}. Since \ci{gp} was declared to be a static function,
and \ci{popen} is only called when \ci{gp==NULL},
it will persist through multiple calls of this function, and you can
repeatedly call the function to produce new plots in the same window.

If \ci{gp} is \ci{NULL} after the call to \ci{popen}, then something
went wrong.  This is worth checking for every time a pipe is created.

But if the pipe was created
properly, then the function continues with the now-familiar process of
writing the command \bi{plot '-'} and a vector to a file. The \bi{reset}
command to Gnuplot ensures that next time you call the function, the new
plot will not have any strange interactions with the last plot.

One final detail: data is often kept in a \vocab{buffer}, a space in
memory that the system promises to eventually write to the file. This
improves efficiency, but you want your plot now, not when the system
deems the buffer worth writing.  The final
function, \cind{fflush}, tells the system to send all elements of the
\ci{gp} buffer down the pipeline. The function also works when you are
expecting standard
output to the screen, by the way, via \ci{fflush(NULL)}.

The main drawback to producing realtime graphs is that they can take over
your computer, as another graph pops up and grabs focus every half-second, and can significantly slow down the program.
Thus, you may want to settle for occasional redisplays, such as every
fifty periods of your simulation. You could call the above
function using something like:

\begin{lstlisting}
for (period =0; period< 1000; period++){
    run_simulation();
    if (!(period % 50))
        plot_vector_now(output);
\end{lstlisting}

\index{Gnuplot|)}
