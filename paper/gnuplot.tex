\chapter{Gnuplot} \label{gnuplot}
%@-     so lgrind will play nice with makeindex
\index{Gnuplot|(}
\index{plotting|see{Gnuplot}}
\index{graphing|see{Gnuplot}}

This chapter will give you some tips on plotting using Gnuplot, a graphing package that is as
open and freely available as gcc. [It is unrelated to the GNU, by the way. The name is a compromise
between the names the two main authors preferred: nplot and llamaplot.]

Gnuplot does nothing but plot points. It has some interface with the GSL to plot functions for you, but
you mostly won't be concerned with those: you'll just want to plot your data.


\section{Dumping output to an agreeable format} 
The line \cinline{plot '-';} tells Gnuplot to (2-D) plot the data to come. The
command for a 3-D plot is \cinline{splot '-'}. That means that the process
of turning a matrix into a basic plot is trivial. Let \cinline{data} be an
\cinline{apop\_data} set whose first and fifth columns we'd like to plot
against each other:
\begin{lstlisting}
FILE    *f = fopen("plot_me", 'w');
fprintf("plot '-' using 1:5;\n");
fclose(f);
apop_data_print(data, "plot_me");
\end{lstlisting}
The second option to \ttind{fopen} should be either \cinline{'a'} for append or
\cinline{'w'} for write; in this case, we want to start with a clean file.
Notice that \ttind{apop\_data\_print} defaults to appending; you
would need to set \ttind{apop\_opts.output\_append = 0} to overwrite.

The clause \cinline{using 1:5} in the plot command tells Gnuplot to use
only the first and fifth columns of the data set---so there is no need to pare
down the data set in memory. Notice that the first column in Gnuplot is
1, not 0. At the end of this, \cinline{print\_me} will be executable by
Gnuplot. There are a few ways to get Gnuplot to read the file:
\begin{lstlisting}
gnuplot -persist < plot_me
(or)
gnuplot plot_me -
\end{lstlisting}
The first option will open a window and leave the command line inactive
until you close the window;
the second will give you a Gnuplot command line that you'll have to
manually exit
from (by typing \cinline{exit} or $<$ctrl$>$-D, or you can send in more
Gnuplot commands). On many systems, you can
interact with the plot, spinning 3-D plots with the mouse or selecting
subregions of 2-D plots to zoom into.

\subsection{Histograms} Gnuplot, refusing to do calculations for you,
makes making histograms a pain.  Fortunately, the GSL has you covered,
with the \ttind{gsl\_histogram} object. It creates a set of bins, and
then you can call \cinline{gsl\_histogram\_increment} to put
data into the right bin. The example below, allocates a histogram with
\cinline{bin\_ct} bins, then sets its range to just past the min and max
of the data. Then the for loop pulls data points from the vector and
dumps them to the histogram, without any further calculation on our part.

\begin{lstlisting}
void create_a_histogram(gsl_vector *data, size_t bin_ct, char *outfile){
int             i;
FILE *          f;
double      min, max, pt;
gsl_histogram   *h      = gsl_histogram_alloc(bin_ct);
    gsl_vector_minmax(data, &min, &max);
    gsl_histogram_set_ranges_uniform(h, min-GSL_DBL_EPSILON, 
                                            max+GSL_DBL_EPSILON);
    for (i=0; i < data->size; i++){
        pt  = gsl_vector_get(data, i);
        gsl_histogram_increment(h, pt);
        }
    for (i=0; i < bin_ct; i++)
        printf("%4f\t %g\n", h->range[i], gsl_histogram_get(h, i));
}
\end{lstlisting}

This is the same histogram structure that was turned into a PDF for
random number generation in Section \ref{randomnumbers}.
But this is the plotting chapter, so the above should output to
a gnuplot-readable file. The \ttind{apop\_plot\_histogram}
function does exactly this.

\index{Gnuplot|)}
