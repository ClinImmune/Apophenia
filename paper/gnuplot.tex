\chapter{Gnuplot} \label{gnuplot} 
\index{Gnuplot|(}
\index{plotting|see{Gnuplot}}
\index{graphing|see{Gnuplot}}

This chapter will give you some tips on plotting using Gnuplot, a graphing
package that is as open and freely available as gcc.\footnote{There is
some politics about how this is not strictly true: the maintainers of
Gnuplot will not allow you to modify their code and then distribute the
modified package independently (i.e., to \airq{fork} the code base). The project is entirely unrelated to the
GNU, and the name is simply a compromise between the names that the two
main authors preferred: nplot and llamaplot.}

Gnuplot does nothing but plot points and lines. As such, the language
basically has only two verbs---\ci{set} and \ci{plot}---plus a few
variants (\ci{splot}, \ci{replot}). A Gnuplot command file generally
consists of a long string of \ci{set} commands to indicate what the axes
should look like, the point and line formats, et cetera, and a final
\ci{plot} command to do the actual work.

As with SQLite, there is a command-line interpreter for Gnuplot's
commands (\bi{gnuplot}), so after your data is basically in place, you can
interactively try different \ci{set} commands to see what options look
best. After you have finished shopping for the best settings, you can
put them into a script that will always produce the perfect graph, or
better still, write a C program to autogenerate a script that will
always produce the perfect graph.

\section{From arrays to plots} \label{gnuprint}
The line \ci{plot '-'} tells Gnuplot to plot the (2-D) data to come. The
command for a 3-D surface plot of data to follow is \ci{splot '-'}. With
these commands, the process of turning a matrix into a basic plot is
trivial. Let \ci{data} be an \ci{apop\_data} set whose first and fifth
columns we would like to plot against each other. Then we need to create
a file, put a \ci{plot '-';} command in the first line, and then fill the
remainder with the data to be plotted. Below is the basic code to create
a Gnuplot file. Since virtually anything you do with Gnuplot will be a
variant of this code, it will be dissected in detail.  
  \label{fprintf}
\begin{lstlisting}[numbers=left, numberstyle=\scshape]
FILE    *f = fopen("plot_me", "w");
fprintf(f, "set plot '-' using 1:5 title 'columns (1,5)'\n");
fclose(f);
apop_matrix_print(data, "plot_me");
\end{lstlisting}

The first option to \cind{fopen} is the file to be written to, and
the second option should be either \ci{"a"} for append or \ci{"w"} for
write anew; in this case, we want to start with a clean file so we use
\ci{"w"}.\footnote{If the argument is \ci{"r"}, you could read from the
file. However, none of the methods in this book involve reading raw text
from a file. See any standard reference on C on the details of opening a
file for reading.} 


As you can see from line two, the syntax for \ci{fprintf} is just like
the syntax for \ci{sprintf}: the first argument indicates to what you
are writing, and the rest is a standard \ci{printf} line, which may
include the usual insertions via \ci{\%f}, \ci{\%i}, and so on.

The clause \ci{using 1:5} in the plot command written in line two tells
Gnuplot to use only the first and fifth columns of the data set---so
there is no need to pare down the data set in memory.  Notice that the
first column in Gnuplot is 1, not 0.

You can give the \ci{using} clause a single number, like \ci{plot '-'
using 1}, in which case Gnuplot will assume that the $X$-axis is the
element number $1, 2, \dots$, and your data is the $Y$-value. With two
columns as above, the columns are taken to be $(X, Y)$ pairs. To plot
two columns of data together, see \ci{replot}, below.

The \ci{title} clause is self-explanatory: Gnuplot adds a legend to your
graph by default, and this will be the text associated with this data.
Notice that Gnuplot accepts both ``double quotes'' and `single quotes'
around text such as file names or labels; since single quotes are
nothing special to C, this makes it much easier to enter such text.

Line three closes the file, so there is no confusion when, in line four,
we use the standard \ci{apop\_matrix\_print} command to write the data
to the file. We print the matrix instead of the
full \ci{apop\_data} structure so that no names or labels are written.
Since \cind{apop\_data\_print} defaults to appending, the matrix appears
after the \ci{plot} header that we just wrote to the file.
You would need to set \ci{apop\_opts.output\_append = 0} to overwrite.
\cindex{apop\_opts.output\_append}

At the end of this, \ci{print\_me} will be executable by
Gnuplot. There are a few ways to get Gnuplot to read the file from the
typical UNIX-style command prompt:
\begin{lstlisting}
gnuplot -persist < plot_me
#(or)
gnuplot plot_me -
\end{lstlisting}
The first option will open a window and leave the command line inactive
until you close the window; the second will give you a Gnuplot command
line that you will have to manually exit from (by typing \ci{exit}
or $<$ctrl$>$-D, or you can send in more Gnuplot commands). On many
systems, you can interact with the plot, spinning 3-D plots with the
mouse or selecting subregions of 2-D plots to zoom into.

\treesymbol{} Those experienced with POSIX systems know that a script
can be made executable by itself. The first line of the script must begin
with the special marker \#!, and then give the interpreter that will read
the file, and the script must be given execute permissions. The following
program will produce a self-executing Gnuplot script to plot $\sin(x)$:
\begin{lstlisting}
#include <apophenia/headers.h>
#include <sys/stat.h>
int main(){
    char    filename[]  = "plot_me";
    FILE    *f = fopen(filename, "w");
    fprintf(f, "#!/usr/bin/gnuplot -persist\n\
                plot sin(x)");
    fclose(f);
    chmod(filename, 0755);
    return 0;
}
\end{lstlisting}

\subsection{\cind{replot}} You will often want multiple data sets on the
same plot, and Gnuplot does this easily using the \ci{replot} command.
Just change every use of \ci{plot} after the first to \ci{replot}. This
seems simple enough, but the system is a bit fragile. The remainder of
this section presents some details regarding the use of \ci{replot} (\treesymbol).

First, it can be very frustrating using the above \ci{plot '-'} format
to put data inline when replotting elements. It is easier to write the
data to a separate file and then refer to that in the file to be read
by Gnuplot. Here is a C snippet to produce a data file and a Gnuplot
command file:
\begin{lstlisting}
FILE    *f = fopen("plot_me", "w");
fprintf(f, "plot 'datafile' using 1 title 'data column 1';\n \
            replot 'datafile' using 5 title 'data column 5';\n");
fclose(f);
apop_data_print(data, "datafile");
\end{lstlisting}
Running \bi{plotme} through Gnuplot will produce a plot with two lines,
representing column one and column five of the datafile.

Also, when outputting to a paper device, replotting tends to make a
mess. Set the output terminal (see below) just before the final replot:
\begin{lstlisting}
plot 'datafile' using 1
set term postscript color
set out 'two_lines.eps'
replot 'datafile' using 5
\end{lstlisting}


\subsection{Plotting functions} To this point, the discussion has been
entirely about plotting data points, but Gnuplot also knows all of the
functions in the standard C math library. For example, the following
sequence will produce a set of pleasing curves. Notice that \ci{x**2}
is common stats-package notation for $x^2$.  
\begin{lstlisting}
set xrange [-4:6]
plot sin(x)
replot cos(x)
replot log(x) + 2*x - 0.5*x**2
\end{lstlisting}

\section{Some common settings}
At this point, you can produce a basic graph of data or a function (or
both at once). But
barring supreme luck, Gnuplot's default plot is not exactly what you
have in mind, and you will need to modify it in some way. 

As above, a typical Gnuplot file consists of a long series of \ci{set}
commands followed by a single \ci{plot} command. This section catalogs
the most common features to set. The next section will list some special
types of graph.

For more information on the settings here and many more, see the
very comprehensive Gnuplot documentation, which can be accessed from
inside the gnuplot command-line program via
\ci{help}, optionally followed by any of the headers below (e.g.,
\ci{help set style}, \ci{help set pointtype}).

\subsection{\ci{set style}} The basic style of the plot may be a simple
line or points, a bar graph, boxes with error bars, or many other
possibilities. Gnuplot keeps track of two types of style: that for
function plotting (\ci{set style function}) and for data plotting (\ci{set style data}). 
Thus, a typical style setting would consist of something like \ci{set
style data impulses}.

As with many of Gnuplot's settings, you can either set the style via a
command on its own line, or after the plot command using the \cind{with}
command. There are a few examples below.

\subsection{\ci{set pointtype}, \ci{set linetype}} You can go with the default
point and line type, or explicitly set it using these commands.

Like many Gnuplot commands, they may be given on the same line as the
plot command or on their own line, and may be abbreviated to an
easy-to-type but impossible-to-read two-letter sequence.
\begin{lstlisting}
plot 'data' with points pointtype 3
# is equivalent to
plot 'data' with points pt 3
# is equivalent to
set style data points
set pointtype 3
plot 'data'
\end{lstlisting}

The \ci{pointtype} and \ci{linetype} commands, among a handful of other
commands, may differ from on-screen to postscript
to PNG formats, depending upon what is easy in the different formats.  You can see what each terminal can do via the \ci{test} command. E.g.:
\begin{lstlisting}
set terminal postscript
set out 'testpage.ps'
test
\end{lstlisting}
Among other things, the test page displays the types of points and lines
available for the given terminal, and their number.

\subsection{\ci{set xrange}, \ci{set yrange}} Gnuplot generally does a good job of
selecting a default range for the plot, but you can manually override
this using these commands. A range is of the form \ci{[min:max]}.
Sometimes, you will want to leave one end of the range to be set by
Gnuplot, but fix the other end, in which case you can use a \ci{*} to
indicate an automatically set bound. For example, \ci{set yrange [*:10]}
fixes the top of the graph at ten, but lets the lower end of the graph
fall where it may. 

You will sometimes want the axes to go backward.  Say that your data
represents rankings, so 1 is best; then \ci{set yrange [*:10] reverse}
will put tenth place at the top of the graph, and autoset the bottom of
the graph to just past the largest ranking in the data set.

\subsection{\ci{set title}, \ci{set xlabel}, \ci{set ylabel}} These are
very simple commands, that label the $X$
and $Y$ axes and the graph itself. If the graph is going to be a figure
in a paper with an adequate caption, then the title may be optional, but
there is rarely an excuse for omitting axis labels. Sample usage:
\begin{lstlisting}
set xlabel 'Time, days'
set ylabel 'Observed density, picograms/liter'
set title 'Density over time'
\end{lstlisting}

\subsection{\ci{set key}} \index{legend, graph} As noted above, Gnuplot
puts a legend on your graph by default. Most of the time, it is
reasonably intelligent about it, but sometimes the legend gets in the
way. Your first option in this case is to just turn off the key
entirely, via \ci{set key off}.

The more moderate option is to move the key, using some combination of 
\ci{left, right, outside, top, bottom, below}. The first three are
horizontal positions, where \ci{outside} indicates the far right,
outside the graph, while \ci{left} and \ci{right} put the
legend inside the bounds of the graph. The last three indicate vertical
position, where \ci{top} and \ci{bottom} again put the legend inside the
graph, and \ci{below} puts the legend just under the graph.

The key also sometimes benefits from a border, via \ci{set key graph}.

More settings (five or six) forthcoming.

\section{Some special plots} For a system that basically only has a 
\ci{set} and a \ci{plot} command, Gnuplot is surprisingly versatile. Here
are some specialized visualizations that go well beyond the basic 2-D
plot.

\subsection{Surfaces} \index{surface plots}
Let us say tht your data matrix is not a collection of variables in
columns, but a matrix giving the level of a variable over a grid of
coordinates. The \ci{splot '-' matrix} command takes such data and
produces a surface.

Surface plotting goes hand-in-hand with the \cind{pm3d} option, that 
produces a pleasing color-gradient surface. For example,
\begin{lstlisting}
set term postscript 
set out 'surfaceplot1.eps'
set pm3d
set palette gray negative
splot 'datafile' matrix with pm3d
\end{lstlisting}
will produce the first plot in figure \ref{splotone}.  There are many
palettes to be had; the default, omitting the \ci{set palette} line
entirely, works for most purposes.

Another alternative is to \ci{set pm3d map}. This produces an overhead
view of the same surface, sometimes known as a \vocab{contour plot}, as
in the second plot of Figure \ref{splotone}.

\begin{figure}
\begin{tabular}{cc}
\rotatebox{-90}{\scalebox{.25}{\includegraphics{surfaceplot1.eps}}}
&
\rotatebox{-90}{\scalebox{.25}{\includegraphics{surfaceplot2.eps}}}
\end{tabular}
\caption{Two views of the same surface}\label{splotone}
\end{figure}




\subsection{Lattices}  \index{lattices}
Perhaps plotting two pairs of columns at a time is not sufficient---you
want bulk, displaying every variable graphed against every other. For
this, use the \ci{apop\_plot\_lattice} function.

\begin{lstlisting}
apop_data *d = apop_text_to_data("indata", 0, 1);
apop_plot_lattice("outfile", d);
\end{lstlisting}
This produces a file that (after \bi{gnuplot -persist outfile}) produces
a plot like the one in Figure \ref{trellis}. Each variable is plotted
against each other, so the upper-left graph shows the SES variable
versus the Hirfindahl index for a set of data points. The lower-right
graph shows a mirror image of the same two variables. Along the diagonal
are plots of a variable against itself, and therefore these plots will
always be along the $45^\circ$ line. They give a quick picture of the
how a variable's density is distributed.

\begin{figure}
\rotatebox{-90}{\scalebox{.45}{\includegraphics{trellis.eps}}}
\caption{Three variables from my hard drive. Each is plotted against the
other.}\label{trellis}
\end{figure}

What is a lattice plot good for? Some call it \airq{getting a lay of the
land}, while others call it \vocab{data snooping}. Given ten perfectly
random variables, there is a good chance that at least one pair of
lattice plots will look to you like it demonstrates a nice correlation.
A formal regression on the chosen pair of variables will likely
verify your initial visual impression. 

One interviewer directly asked the people who first developed
this type of display, Rick Becker and Bill Cleveland,
whether this display method treads too close to data
snooping:\footnote{\url{http://stat.bell-labs.com/project/trellis/interview.html}}

\begin{quote}
{\em Inteviewer:} OK, but there is another way to approach the study of a large database:
develop a statistical model and see if it fits the data. If it does fit,
use the model to learn about the structure of the data.

{\em Becker \& Cleveland:} Yes, and Trellis
display\footnote{\vocab{Trellis display} is a trademarked term; therefore
this book and many common stats packages use the term \airq{lattice}
to refer to similar displays.} is a big help in doing this because it
allows you to make a good guess about an initial model to fit and then
to diagnose how well it fits the data. [\dots]

{\em Inteviewer:} But instead of agonizing over all those panels I could do a bunch of
chi-squared tests for goodness of fit.

{\em Becker \& Cleveland:} You're joking, right? If not, we're leaving.

{\em Inteviewer:} OK, I guess I'm joking.
\end{quote}

Since Becker and Cleveland do not elucidate the difference between their
visualization method and numerical data snooping, it is up to you to
decide whether such wide-reaching plots are a good first hack at the
data or merely facilitators of apophenia.

\subsection{Histograms} \index{histograms!plotting|(}
Gnuplot, refusing to do calculations for you,
makes making histograms a pain.  Fortunately, the GSL has you covered,
with the \cind{gsl\_histogram} object, which will also appear
in Section \ref{randomnumbers}, when we needed to generate PDFs from data.

It creates a set of bins, and
then you can call \ci{gsl\_histogram\_increment} to put
data into the right bin. Below is the code for \cind{apop\_plot\_hist\-o\-gram}. 
It allocates a histogram with
\ci{bin\_ct} bins, then sets its range to just past the min and max
of the data. Then the \ci{for} loop pulls data points from the vector and
dumps them to the histogram, without any further calculation on our part.
Once everything is neatly aggregated, the function opens a file and dumps the data to a Gnuplottable file. There is an example of this function in use in Figure \ref{draw_beta_curve}, page \pageref{draw_beta_curve}.
\begin{lstlisting}
void apop_plot_histogram(gsl_vector *data, size_t bin_ct, char *outfile){
int             i;
FILE *          f;
double          min, max, pt;
gsl_histogram   *h      = gsl_histogram_alloc(bin_ct);
    gsl_vector_minmax(data, &min, &max);
        gsl_histogram_set_ranges_uniform(h, min-GSL_DBL_EPSILON, max+GSL_DBL_EPSILON);
    for (i=0; i < data->size; i++){
        pt  = gsl_vector_get(data, i);
        gsl_histogram_increment(h, pt);
        }

    //Now that you have a histogram, print it.
        if (outfile == NULL)    f       = stdout;
        else            f       = fopen(outfile, "a");
    fprintf(f, "set key off                                     ;\n\
                        set style data histograms               ;\n\
                        set style histogram cluster gap 0       ;\n\
                        set xrange [0:%i]                       ;\n\
                        set style fill solid border -1          ;\n\
                        set boxwidth 0.9                        ;\n\
                        plot '-' using 2:xticlabels(1);\n", bin_ct);
    for (i=0; i < bin_ct; i++)
    fprintf(f, "%4f\t %g\n", h->range[i], gsl_histogram_get(h, i));
    if (outfile !=NULL)    fclose(f);
}
\end{lstlisting}
\index{histograms!plotting|)}

\subsection {Pruning data for display}
Plotting the entire data set may be detrimental for two reasons. The
first is the range problem: that one data point at $Y=$a million throws off the
whole darn plot. If you are using an interactive on-screen graph, you
can select a smaller region, but it would be better to just not plot
that point to begin with. 

The second reason for pruning is when the data set is too large. The black
blob you get from plotting ten million data points on a single piece of
paper is not very informative. In this case, you want to use only a
random subset of the data.

This section forthcoming. Summary: you can do this in SQL using the
typical \sinline{select * from plotme where value < 1e7} form to eliminate
those values greater than a million. 

One could do the same for random
numbers, although SQLite does not provide the friendliest of random
number generators. The \sind{random} function provides a single random
number between -2,147,483,647 and 2,147,483,647, which the reader will
recognize as $\pm 2^{31}-1$. So we need to pull a random number,
divide by $2^{31}-1$, thus producing a number in $[-1,1]$, then shift it
to the familiar $[0,1]$ range, and then compare it to a limit. The
query below does this to remove approximately half of the data set.
It uses the bit-shifting operator which I had promised you would never
need; read \ci{1<<x} as $2^x$.

\sinline{select * from plotme where (random()/(-(1<<31)-1.0)+1)/2  < 0.5}

\summary{
\item A Gnuplot command file basically consists of a group of \ci{set}
commands to specify how the graph will look, and then a single \ci{plot}
(2-D version) or \ci{splot} (3-D version) command. 
\item Using the \ci{plot '-'} form, you can put the data to be plotted
in the command file immediately after the command. You can use this and
\ci{apop\_data\_print} to produce plot files of your data.
}

\section{Printing} \index{Postscript} 
Once your plot looks nice on the screen, you can put it on paper or a
report by simply setting the right variables. Notably, the commands
\begin{lstlisting}
set terminal postscript;
set out 'outfile.eps';
\end{lstlisting}

at the head of a file will put the plot in \bi{outfile.eps} rather
than posting it to the screen. Since all of the plotting commands append
by default, one could start the file off with this command, and then
call a plotting command to produce a paper-printing Gnuplot command file.

The following snippet will erase a file, and
if \ci{print\_to\_paper} is true, place a header setting Gnuplot to
print to \bi{outfile.eps}; if it is false, Gnuplot will default
to printing to screen.

\begin{lstlisting}
char *gnuplot_file = "plot_me";
char *graph_file = "outplot.eps";
FILE    f = fopen(gnuplot_file, "w");//overwrite the file
    if (print_to_paper)
        fprintf(f, "set terminal postscript;\nset out '%s';\n", graph_file);
    fclose(f);
    apop_plot_histogram(data, 1000, gnuplot_file);
\end{lstlisting}

What to do with an \bi{eps} file? For those who just want a quick
printout, your best best is probably to run the command \bi{ps2pdf}
to produce a PDF file, which can be viewed with familiar PDF viewers
such as Acrobat Reader. On a system with GhostScript, the \bi{eps} file
can be viewed and printed directly. Since all of this research will
probably eventually turn into a report or paper, you can also smoothly
include it in \LaTeX{} documents.

\subsection{\treesymbol \LaTeX}\index{Latex@\LaTeX} \index{Tex@\TeX}
You have two options when putting a plot in a \TeX{}ed paper: native
\LaTeX{} and Postscript. 

\paragraph{Native format}
Just as you can set the output device to a screen or a Postscript printer,
you can also send it to a \LaTeX-formatted file. One the plus side, the
fonts will precisely match those in your document, and the resolution is
that of \TeX{} itself (100 times finer than the wavelength of
visible light). On the minus side, some features, such as color, are not
available.

Just as you can dump one C file into another via \ci{\#include}, you can
include the Gnuplot output via the \ci{$\backslash$input} command
\begin{lstlisting}
\documentclass{article}
\usepackage{latexsym}
\begin{document}
...
\begin{figure}
\input outfile.tex
\caption{This figure was autogenerated by a C program.}
\end{figure}
...
\end{document}
\end{lstlisting}

Another very common complaint: the Y-axis label isn't rotated right.
The solution provides a good example of how 
you can insert arbitrary \LaTeX{} code into your Gnuplot code.

First, in the Gnuplot file, you set the label to any set of instructions
that \LaTeX{} can understand. Let $\lambda$ be an arbitrary label:
\begin{lstlisting}
set ylabel '\\rotatebox{90}{Your $\lambda$ here.}'
\end{lstlisting}
Notice the double-backslash. Just as with \ci{printf} (see page
\pageref{printf}), expressions like \ci{$\backslash$n} have special
interpretations, so to print a plain backslash, you will need to double
it to \ci{$\backslash\backslash$}. 

If you are autogenerating this line from C, then you will again need to
double the backslash for each single backslash you will print to the
Gnuplot file. To print the line above to a file, use:
\begin{lstlisting}
fprintf(out, "set ylabel '\\\\rotatebox{90}{Your $\\lambda$ here}'\n ");
\end{lstlisting}

Two final notes to complete the example: \sinline{$\backslash$rotatebox}
is in the \bi{graphicx} package, so it needs to be called in the preamble: 
\begin{lstlisting}
\usepackage{latexsym, graphicx}
\end{lstlisting}
Second, \binline{xdvi} does not currently support rotation, so if you are
viewing via \TeX's native dvi format, the rotation won't happen. Use
either \binline{pdflatex} or \binline{dvips} to view the output as it
will print.

\paragraph{The Postscript route}\index{Postscript|(}
Which brings us to the second option for including a graphic:
Postscript.

Use the \airq{graphicx} package to incorporate the plot. E.g.:
\begin{lstlisting}[language={}]
\documentclass{article}
\usepackage{graphicx}
\begin{document}
...
\begin{figure}
\rotatebox{-90}{\scalebox{.35}{\includegraphics{outfile.eps}}}}
\caption{This figure was autogenerated by a C program.}
\end{figure}
...
\end{document}
\end{lstlisting}
Notice that you will frequently need to rotate the plot $90^\circ$
and scale the figure down to a reasonable size.

The first option for generating PDFs is to use \bi{epstopdf}. First,
convert all of your \bi{eps} files to \bi{pdf} files on the command
line:
\begin{lstlisting}[language=bash]
for i in *.eps; do 
    epstopdf $i;
done
\end{lstlisting}

Then, in your \LaTeX{} header, add 
\begin{lstlisting}[language=sql]
\usepackage[pdftex]{epsfig}
\end{lstlisting}

The benefit to this method is that you can now run \bi{pdflatex
my\_document} without incident; the drawback is that you now have two
versions of every figure cluttering up your directory, and must
regenerate the PDF version of the graphic every time you regenerate the Postscript
version.

The alternative is to go through Postscript in generating the entire
document:
\begin{lstlisting}[language=sql]
latex a_report
dvips < a_report.dvi > a_report.ps
ps2pdf a_report.ps
\end{lstlisting}

This is a lot of typing, but there is a way to automate the process:
\ind{make}. Below is a sample Makefile for producing a \LaTeX{} document
should \bi{pdflatex} be quarrelsome on your system. As with your C
programs, once the Makefile is in place, you can generate final PDF
documents by just typing \bi{make} at the command line. The
creative reader could readily combine this Makefile with the sample C
Makefile from page \pageref{make} to regenerate the final report every
time the analysis is updated.

\begin{lstlisting}[language=make]
DOCNAME = a_report

pdf:	$(DOCNAME).pdf

$(DOCNAME).dvi: $(DOCNAME).tex
	latex $(DOCNAME); latex $(DOCNAME)

$(DOCNAME).ps: $(DOCNAME).dvi
	dvips  -f < $(DOCNAME).dvi > $(DOCNAME).ps

$(DOCNAME).pdf: $(DOCNAME).ps
	ps2pdf $(DOCNAME).ps  $(DOCNAME).pdf

clean:
	rm -f $(DOCNAME).blg $(DOCNAME).log $(DOCNAME).ps
\end{lstlisting}
\index{Postscript|)}

\section{Animation}\index{animation} Perhaps three dimensions is not
quite enough, and you need one more. Gnuplot easily supports animation:
just stack plots one after the next and call \ci{replot} in between. However,
many media (such as paper) do not yet support animation, meaning that your
output will generally be dependent on your display method. The \ind{GIF} format
provides animation and is supported by all major web browsers, so you
can also put your movies online.\footnote{Also, the U.S. patents on the
compression algorithm upon which the GIF format is based \citep{welch:lzw}
have expired, so the mathematical transformations required to write a
GIF may be executed without seeking a license.}

More detail forthcoming.


\section{\treesymbol Instant gratification}
All of the above methods involved writing your commands data to a file and then 
running Gnuplot, but you may want to produce plots as your program runs.
This is often useful for simulations, to give you a hint that all is OK
while the program runs, and to impress your friends and funders. This is
easy to do using a \vocab{pipe}.\footnote{There is a readily available
package named \cind{gnuplot\_i} that provides some functions to simplify
piping commands to Gnuplot. It basically works via the same method as
the one discussed in this section, but has much more code to handle
settings and problem cases.}

The command \cind{popen} does two things: it runs the specified program,
and it produces a data pipe connecting your program to the now-running
child program. Any commands you write to the pipe is read by the child
as if someone had typed those commands into the program directly.

You can write to a pipe just like you would write to a file, using
\cind{fprintf}, meaning that once you have opened the pipe to
Gnuplot, the methods above really do apply directly.

You will want to use \cind{apop\_vector\_print} or
\cind{apop\_matrix\_print} to dump out the actual data. To do so, you
will need to set the output type to \ci{'p'} and specify the output
pipe. Lines 11 through 13 in the sample code below do this.
The command on line 14, \cind{fflush}, ensures that all of the data has
been flushed through the pipe and delivered to Gnuplot.

\label{pipeexample}
\begin{lstlisting}[numbers=left, numberstyle=\scshape]
void plot_vector_now(gsl_vector *data){
static FILE *gp = NULL;
int  i;
    if (!gp)
        gp = popen("/usr/local/bin/gnuplot -persist", "w");
    if (!gp){
        printf("Couldn't open Gnuplot.\n");
        return 0;
    }
    fprintf(gp,"reset; plot '-' \n");
    apop_opts.output_type = 'p';
    apop_opts.output_pipe = gp;
    apop_vector_print(data, NULL);
    fflush(gp);
}
\end{lstlisting} 

The \ci{popen} function takes in the full path to Gnuplot, and a \ci{w}
to indicate that you will be writing to Gnuplot rather than reading from
it. You can find where Gnuplot lives on your machine using the command
\bi{which gnuplot}. The \ci{popen} function then returns a file, here
assigned to \ci{gp}. Since \ci{gp} was declared to be a static function,
and \ci{popen} is only called when \ci{gp==NULL},
it will persist through multiple calls of this function, and you can
repeatedly call the function to produce new plots in the same window.

If \ci{gp} is \ci{NULL} after the call to \ci{popen}, then something
went wrong.  This is worth checking for every time a pipe is created.

But if the pipe was created
properly, then the function continues with the now-familiar process of
writing the command \bi{plot '-'} and a vector to a file. The \bi{reset}
command to Gnuplot ensures that next time you call the function, the new
plot will not have any strange interactions with the last plot.

One final detail: data is often kept in a \vocab{buffer}, a space in
memory that the system promises to eventually write to the file. This
improves efficiency, but you want your plot now, not when the system
deems the buffer worth writing.  The final
function, \cind{fflush}, tells the system to send all elements of the
\ci{gp} buffer down the pipeline. The function also works when you are
expecting standard
output to the screen, by the way, via \ci{fflush(NULL)}.

The main drawback to producing realtime graphs is that they can take over
your computer, as another graph pops up and grabs focus every half-second, and can significantly slow down the program.
Thus, you may want to settle for occasional redisplays, such as every
fifty periods of your simulation. You could call the above
function using something like:

\begin{lstlisting}
for (period =0; period< 1000; period++){
    run_simulation();
    if (!(period % 50))
        plot_vector_now(output);
\end{lstlisting}

\index{Gnuplot|)}
