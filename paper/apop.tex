\chapter{Apophenia} \label{apop}
%@-     so lgrind will play nice with makeindex

One could divide Apophenia's functions into two categories: haphazard
convenience functions, and a unified worldview of about how data is
analyzed. Some of the convenience functions have already appeared; this
chapter describes the unified world view. 

This may also be a good place to remind the reader that, as with most of
the stats packages of the world, Apophenia has two types of
documentation: the chatty, not-comprehensive overview you are reading now and the
comprehensive function-by-function reference. The reference is autogenerated from the
source code, and can be found online at \url{http://apophenia.info/doc}
or generated from your own copy of the source using \binline{doxygen}.\footnote{doxygen is free software and is universally packaged,
so it is easy to get. If you have it installed, run \cinline{make doc} in
your source directory.}

\section{The structures}
Here is a one-sentence summary of statistical analysis: estimate the
parameters of a model
using data. Apophenia thus has three key objects defined that embody
this description, named \cinline{apop\_data}, \cinline{apop\_model}, and 
\cinline{apop\_estimate}.\footnote{Notice that the `estimate the parameters of a
model' line readily includes ``non-parametric'' models. This becomes
especially evident when coding such models, which still wind up being
black boxes that take in a data set and return a set of parameter
estimates.}

The basic story for a statistical analysis is that the researcher
assembles a data set into an \cinline{apop\_data} structure, then sends it to
an \cinline{apop\_model} so that the model's parameters can be estimated,
and that is returned in an \cinline{apop\_estimate} structure.

Supporting these main structures are a few more structures you would only
have to worry about for fine tuning.  The \cinline{apop\_name} structure is
an organized list of row and column names; functions that take an 
\cinline{apop\_data} set automatically handle the names for you. 
Some models, such as MLEs, require some parameters to run, in
which case you will need to fill out an \cinline{apop\_est\-i\-ma\-tion\_params}
form and hand it in to the model. Included in the
\cinline{apop\_est\-i\-ma\-tion\_params} is an
\cinline{apop\_inventory} structure that lists the elements
that an \cinline{apop\_estimate} will generate (no model produces
everything, and if you don't need covariances, why produce them). If you
don't care about the estimation parameters, sending \cinline{NULL} will
work fine for most models. 

\paragraph{Data} \cindx{apop\_data}{(textbf}
The \cinline{apop\_data} structure adds a touch of metadata on top of the
basic \cinline{gsl\_matrix}. It includes an \cinline{apop\_name} structure (see
below), and a table for non-numeric variables. In case you need to access
its individual elements, here is the declaration:

\begin{lstlisting}
typedef struct apop_data{
    gsl_matrix  *matrix;
    apop_name   *names;
    char        ***categories;
    int         catsize[2];
} apop_data;
\end{lstlisting}
You can easily operate on the individual elements of the structure:
if the \cinline{matrix\_man\-ip\-u\-late} function requires a
\cinline{gsl\_ma\-trix}, but you are using an \cinline{apop\_da\-ta}
structure, then you can call
\cinline{matrix\_man\-ip\-u\-late(my\_data-$>$matrix)}. Similarly to
manipulate the names and the table of text data. The size of the text
data is stored in the \cinline{catsize} element. Usage:

\begin{lstlisting}
int r,c;
apop_data   *set = get_category_data(...);
for (r=0; r< set->catsize[0]; r++){
    for (c=0; c< set->catsize[1]; c++){
        printf("%s\t", set->categories[r][c]);
    }
    printf("\n");
}
\end{lstlisting}
\comment{
Categories are not particularly well-supported, because there is not
much analysis that one could do with them---they are primarily useful
for dissecting data on the SQL side. But one common use is to 
take a column with, say, five categories,
and produce four columns of dummy variables.}

\paragraph{Useful functions} As well as using them for models, there are
various functions for manipulating \cinline{apop\_data} sets. You will
first
create the data set, probably with \cind{apop\_query\_to\_data}, but perhaps
with \cind{apop\_matrix\_to\_data}, \cind{apop\_vector\_to\_data}, or
creating a blank slate with \cind{apop\_data\_alloc}.

\cindex{apop\_data\_copy}
You can copy the entire data set, 
stack two data sets one on top of the other (stack rows), or 
stack two data sets one to the right of the other (stack columns):
\begin{lstlisting}
apop_data *newcopy = apop_data_copy(oldset);
apop_data *newset_tall = apop_data_stack(oldset_one, oldset_two, 'r');}
apop_data *newset_wide = apop_data_stack(oldset_one, oldset_two, 'c');}
\end{lstlisting}

All of these operations make a full copy of the data, without
erasing the original data sets, so in each case
you will be taking up twice as much memory
at the end of the function until you call
\cinline{apop\_data\_free(oldset)}.\cindex{apop\_data\_free} As
noted earlier, you are generally better off doing data manipulation
in the database. If the tables are in the database instead of
\cinline{apop\_data} sets the two stacking commands above are equivalent
to \sinline{select * from oldset\_one UNION select * from oldset\_two}
and \sinline{select t1.*, t2.* from oldset\_one t1,oldset\_two t2},
respectively.

Since the \cinline{data} element of the \cinline{apop\_data} structure
is a \cinline{gsl\_matrix}, you can use any of the tools from Chapter
\ref{linear_algebra} to dissect it.
There are four additional functions for pulling an element from an
\cinline{apop\_data} set using the names. Let \airq{t} be a title and
\airq{n} be a number; then you may refer to the row-column coordinate
using the $(n,n)$, $(t,n)$, $(n,t)$, or $(t,t)$ form:
\begin{lstlisting}
apop_data_get(your_data, i, j);
apop_data_get_tn(your_data, "rowname", j);
apop_data_get_nt(your_data, i, "colname");
apop_data_get_tt(your_data, "rowname", "colname");
\end{lstlisting}
Notice that the first form, \cinline{apop\_data\_get}, has an abbreviated
name, and is identical to \cinline{gsl\_matrix\_get(your\_data->matrix, i, j)}.
\cindex{apop\_data\_get...}

 \cindx{apop\_data}{)textbf}

\paragraph{Models}
The \cinline{apop\_model} structure encapsulates a description of the world
in which the data and the parameters produce observed outcomes. The
\cinline{apop\_mo\-del.\-est\-i\-mate()} method takes in data and produces an \cinline{apop\_est\-i\-mate}. 

\marginalia{Patterns in static}{{\sl Apophenia} is a term from the
psychology literature referring to the human tendency to see patterns in
static. Good data description seeks out patterns in existing data; good
hypothesis testing does not seek out patterns but aims to reject or fail
to reject observed patterns. Hypothesis testing is thus an attempt to
fight against apophenia.

The Apophenia library is so named because the word has a pleasant ring, is a
statistics-related term, and is not an acronym.}

[Many statistics packages include a model structure that describes only
linear models.  "Linear" models can include a wide range of nonlinear
features, but they are still a subset of measure zero within the class of
models as described above. Currently, Apophenia has no plans to include
a summary syntax for describing linear models; the reader who has a linear
model to be estimated via OLS or GLS is advised to instead manipulate
the data set to the appropriate form and then call \cinline{apop\_OLS} or
\cinline{apop\_GLS}.]

Frequently, a model is a probability distribution. The data is assumed
to have been drawn from a given distribution and the question is
only what distributional parameters best fit; e.g., assume the data
is Normally distributed and find the mean and variance.

In fact, one could even use the \cinline{apop\_model} to describe 
non-statistical models involving optimization subject to constraints;
see the example of Section \ref{econ101}.

Because models are often distributions, and because it is not our place
to dictate what you will do with a model, the \cinline{apop\_model} also includes a
number of additional functions that may be useful for additional analyis,
such as a likelihood function that could be used for ML estimation or
for estimating the Hessian, and a random number generator. Some effort
has been made to ensure that the prepackaged models include as many of
these auxiliary functions as possible; if you are writing your own,
there is no requirement that you provide all functions, and the \cinline{apop\_maximum\_likelihood} and \cinline{apop\_numerical\_hessian}
functions do a good job of filling in blanks.

\paragraph{Estimates} 
%\index{apop\_estimate@\cinlinetwo{apop\_estimate}|(textbf}
\cindx{apop\_estimate}{(textbf}
The \cinline{apop\_estimate} structure returns all the data one would want
from a regression or ML estimation, including the parameters estimated,
the variance/covariance matrix, the predicted values, et cetera. The structure
includes instances of almost all of the other structures listed here, so
that you will have a link to the data, model, a copy of the
estimation parameters that produced the estimate. Within the
estimation parameters one will find an inventory of
what the \cinline{apop\_est\-i\-mate} contains.

Here is the current definition of the \cinline{apop\_estimate} structure. You can se that it errs on the inclusive side.
\begin{lstlisting}
typedef struct apop_estimate{
    gsl_vector  *parameters, *confidence;
    apop_data   *dependent;
    apop_data   *covariance;
    double      log_likelihood;
    apop_name   *names;
    int         status;
    struct apop_data   *data;
    struct apop_model  *model;
    struct apop_estimation_params  estimation_params;
} apop_estimate;
\end{lstlisting}

The \cinline{dependent} matrix is worth notice. It is three columns, named 
\cinline{actual}, \cinline{predicted}, and \cinline{residual}. 
 If this is a model with a single dependent and lots of
independent vars, then the first column is the actual data. Let our
model be $\Yv = \betav \Xv + \epsilon$. Then the second column is the
predicted values: $\betav \Xv$, and the third column is the residuals:
$\epsilon$. The third column is therefore always the first minus
the second, and this is probably how that column was calculated
internally. There is thus currently no way to get just the predicted
but not the residuals or vice versa.

The \cinline{status} element is primarily for maximum likelihood
estimations, which can fail to converge. If \cinline{status != 0},
then the MLE failed and the estimate should not be relied on.

The \cinline{apop\_est\-i\-mate} tries to be self-contained, including
everything one would need to re-run an estimation. In fact, on page
\pageref{restart}, the \cind{apop\_estimate\_restart} function will be
able to derive a new \cinline{apop\_est\-i\-mate} using only an old
\cinline{apop\_est\-i\-mate} as an input. 

However, since we assume that the data set is a million entries, it
would be impractical to save a copy in the \cinline{apop\_est\-i\-mate}
just in case. Therefore, the other elements should be copied in, but
the pointer to the data, \cinline{your\_estimate.data} is merely a spare
pointer, pointing to the block of memory where your data is located. If
you destroy your data using this pointer, then you have just destroyed
your original data set, and vice versa.
%\index{apop\_estimate@\cinlinetwo{apop\_estimate}|)textbf}
\cindx{apop\_estimate}{)textbf}


\paragraph{An example}
Here is a program that puts the above structures to work.  It assumes a
data set in a file, such as the \cinline{test\_data} file included with
Apophenia's source code, and that file has no row names but does have
column names.
\begin{lstlisting}
#include <apophenia/headers.h>

int main(void){
apop_data       *data;
apop_estimate   *est;
    apop_convert_text_to_db("data","d",0,1,NULL);
    data       = apop_query_to_data("select * from d");
    invent.parameters   = 1;
    est  = apop_OLS.estimate(data, NULL);
    apop_estimate_print(est);
    return 0;
}
\end{lstlisting}

We first read the data into the database, and then pull it into an \cinline{apop\_data} set. Since we didn't pare down the data, we didn't really
need the database, and could have read the text file directly into a
\cinline{apop\_data} structure:
\begin{lstlisting}
    data       = apop_text_to_data("data",0,1);
\end{lstlisting}
Then we write an \cinline{apop\_inventory} that we only want the
parameters, and to not bother finding the variance-covariance matrix or
the residuals or other such things used for hypothesis testing. Then we
send the data and the estimate to the \cinline{apop\_OLS.estimate}
function, which returns, naturally, an \cinline{apop\_estimate}
structure. Then we print it.

Feeling lazy? The program above was good form and demonstrated useful
features, but the code below will do the same thing in even fewer lines:

\label{oneliner}
\begin{lstlisting}
#include <apophenia/headers.h>
int main(void){
    apop_estimate_print(apop_OLS.estimate(apop_text_to_data("data",0,1), NULL));
    return 0; }
\end{lstlisting}

The drawback is that the intermediate forms aren't saved, but we're busy
people who don't have time to interrogate intermediate forms anyway.

\subsection{\treesymbol{} The supporting cast}
Generally, the structures in this section are used as elements of the main
structures above, and are handled automatically as necessary. However,
they are readily accessible, and if you would like finer control of how
estimates are made or results printed, you will need to manipulate these
directly.

\paragraph{Names}
The \cinline{apop\_name} structure has three components: a list of column
names, a list of row names, and a list of categeory (text) variable
names. It is intended to accompany the \cinline{gsl\_matrix} structure,
which holds all the other information about a data aaray such as the
number of rows and columns.

You won't see an \cinline{apop\_name} structure by itself very often;
usually it is embedded in an \cinline{apop\_data} structure. But its
dimension is entirely independent of the \cinline{apop\_data} structure's
data matrices, and you can operate on the \cinline{apop\_name} structure
directly to add or retrieve names.

For example, to get the
column number of a variable in which you are insterested, usd \cind{apop\_name\_find}, e.g.:
\begin{lstlisting}
int column_number   = apop_name_find(my_data->names, "ages", 'c');
gsl_vector age_vector = gsl_marix_column(my_data->matrix, column_number).vector;
printf("mean age: %g\n", apop_vector_mean(&age_vector));
\end{lstlisting}
As above, you can also use \cind{apop\_data\_get\_nt} to pull a single
element given a row number and a column name.

The easy way to add names to a data set is to use the 
\cind{apop\_query\_to\_data} function. It takes an SQL query and returns
the data set with column names neatly stored in
\cinline{returned\_data->names}.

If you have a data set with a blank set of names, such as one
produced via \cind{apop\_matrix\_to\_data},
you may use \cind{apop\_name\_add} to add one name at a
time, e.g.:
\begin{lstlisting}
apop_data newset    = apop_matrix_to_data(a_gsl_matrix);
apop_name_add(newset->names, "col0",'c');
apop_name_add(newset->names, "col1",'c');
apop_name_add(newset->names, "row0",'r');
\end{lstlisting}

\paragraph{Inventory}
The \cinline{apop\_inventory} structure serves two purposes. It is an input
to an \cinline{apop\_model}, that tells the function what output you
would like the \cinline{apop\_estimate} output to include.  Alternatively, you
can just send in a \cinline{NULL} pointer, and the functions will return
everything apropos.

It is also an output from these functions, since the returned \cinline{apop\_estimate} will include its own \cinline{apop\_inventory},
giving a list of the elements of the structure which are
actually in use. For example, the regressions won't return a log
likelihood.

The inventory has one binary element for each element of the \cinline{apop\_estimate} structure.

If the \cinline{apop\_inventory} will be sent in to a regression/MLE
function, set the appropriate element to either zero or one if you would
like the function to return the designated \cinline{apop\_estimate} element.

The \cinline{apop\_estimate} structure itself has an \cinline{apop\_inventory}
element named \cinline{uses} embedded within it. Those elements for
which \cinline{uses.elmt} are zero are unallocated pointers (so be careful:
precede any pointer use with an \cinline{if(est->uses.element)} clause).

It may sometimes be useful to manipulate the \cinline{apop\_estimate} structure's
internal \cinline{apop\_inventory} element to your own benefit. For
example, if you set \cinline{est-$>$uses.co\-var\-iance = 0} before calling
\cinline{apop\_print\_estimate(est, NULL)}, then the covariance matrix won't get
printed. But be careful: if you then call \cinline{apop\_estimate\_free(est)},
then the covariance matrix won't get freed, either.

\paragraph{Estimate parameters}
The \ttind{apop\_estimation\_params} are the details for how an \cinline{apop\_est\-i\-mate} should do its work; currently it is just the specifications
for tolerances, step sizes, starting points, et cetera, for \cinline{apop\_max\-i\-mum\_like\-li\-hood}.

\section{Estimating a model}
Here are the models that currently ship with Apophenia:\\
\cinline{apop\_exponential} and \cinline{apop\_exp\-o\-nen\-tial\_rank}, \\
\cinline{apop\_gamma} and \cinline{apop\_gamma\_rank}, \\
\cinline{apop\_GLS}, \\
\cinline{apop\_normal} (or \cinline{apop\_gaussian}, as you prefer), \\
\cinline{apop\_OLS}, \\
\cinline{apop\_poisson}, \\
\cinline{apop\_probit}, \\
\cinline{apop\_waring} and \cinline{apop\_waring\_rank}, \\
\cinline{apop\_yule}, \\
\cinline{apop\_zipf} and \cinline{apop\_zipf\_rank}.

Some of these are full models, some are distributions, some are
estimated via closed-form calculations and some via MLEs. However, all
of them can be estimated via a form such as
\begin{lstlisting}
apop_normal.estimate(data,  NULL);
\end{lstlisting}

The optional parameter, that was \cinline{NULL} above,
is an \cinline{apop\_\-est\-i\-ma\-tion\_\-par\-a\-met\-ers} object; see
the online reference for the individual models for details of the
parameters one could set.

\paragraph{Data formats} \label{dataformats} \index{data!format}
For the models that are merely a distribution, the data matrix can have
any form: 1 $\times$ 10,000, or 10,000 $\times$ 1, or 100 $\times$ 100.
This provides maximum flexibility in how you produce the data.

For the more elaborate models such as \cinline{apop\_OLS} or
\cinline{apop\_probit}, each row of the data is assumed to be one
observation, the first column of the data is the independent
variable, and the remaining columns are the independent variable.

\paragraph{\treesymbol{} Data formats: networks} \index{network analysis}
Those models with variants ending in \cinline{\_rank} are typically used
in network analysis. For example, let us say that we have a classroom
where every student wrote down the ID number his or her best friend,
and we tallied this list of student numbers:\\
1 1 2 2 2 2 3 4 4 4 6 7 7 7.\\ 
First, we would need to count how often each student appeared:\\
2 : 4\\
4 : 3\\
7 : 3\\
1 : 2\\
3 : 1\\
6 : 1.\\
In SQL: \sinline{select id\_no, count(*) as ct from surveys group by id\_no
order by ct}.

The first option would be to pass this data to
the \cinline{\_rank} version of the model, so the row above would be:\\
4 3 3 2 1 1.\\
Each row of the data set would be one classroom like the above, and the
column number represents the ranking being tallied.

Alternatively, one could 
write down one entry listing the rank for each observation. There would
be four 1s, three 2s, three 3s, et cetera:\\
1 1 1 1 2 2 2 3 3 3 4 4 5 5.\\
Here, order does not matter.  This data set can be passed to the
non-\cinline{\_rank} versions, such as \cinline{apop\_zipf} to fit a
Zipf distribution.

Both data formats will produce the same output; the one you use will
depend on the format in which the data was given to you.




\section{Output and interrogating an estimate}
Now that you have run an estimation function to produe an 
\cinline{apop\_\-est\-i\-mate}, you want to ask it some questions. Only the most
basic hypothesis tests are included in the estimate (and future versions
of Apophenia have a good chance of extricating them). Instead, you can
pass the estimate object to a function that will test a hypothesis. For
example, the \ttind{apop\_estimate\_F\_test} takes in an 
\cinline{apop\_estimate} and puts out the result of an F test, and the
\ttind{apop\_estimate\_correlation\_co\-ef\-ficient} will produce a
table including $R^2$, adjusted $R^2$, \ind{SSE}, SST, and SSR. [See the
reference for the definitions.] \index{R squared@$R^2$}

The output is an \cinline{apop\_data} structure. Typically, the rows are
names of the variables in your original data set, and the columns are
statistics. Note that this means what had been a column name in the 
original data set is now a row name.

\paragraph{Output} 
But you don't just want to know that an \cinline{apop\_data} set has been
produced, you want to {\sl see} it.  Most of the useful data types have
a print function, and given the package-type-operation naming scheme,
you can basically guess their names: \cind{apop\_data\_print},
\cind{apop\_matrix\_print}, \cind{apop\_vector\_print}. If your
data is primarily integers, you may want to save screen real estate
with the integer-printing versions: \cind{apop\_data\_print\_int},
\cind{apop\_matrix\_print\_int}, \cind{apop\_vector\_print\_int}.

These printing functions are actually three-in-one functions: you can
dump your data to either the screen, a file, or the database. You select
the output via the \cind{apop\_opts} structure, which is where all of
Apophenia's global options are stored. 

The three choices for the \index{apop\_opts!output\_type@\cinline{output\_type}}\cinline{apop\_opts.output\_type} 
variable are:
\begin{lstlisting}
apop_opts.output_type   = 's';  //default: print to screen.
apop_opts.output_type   = 'f';  //print to file.
apop_opts.output_type   = 'd';  //store in database.
\end{lstlisting}

The screen output will generally be human-readable, meaning different
column sizes and other notes and conveniences for you at the terminal to
understand what is going on.
The file output will generally be oriented toward allowing a machine to
read the output, meaning stricter formatting. 

The second argument to the output functions is a string.  Output to
screen ignores this; if outputting to file, this is the file name;
if writing to the database, then this will be the table name.
If outputting to file, the name can be \cinline{NULL}, in which case, the
output will be printed to STDOUT (if you aren't familiar with STDOUT,
then it is the screen), but in the machine-friendly format instead of
the human-friendly form. This is what you will use if you are piping
output from an Apophenia-based program to another program.

Since the name argument is irrelevant to printing to screen, and
Apophenia endeavors to facilitate laziness, there are functions
corresponding to the above \cinline{apop\_type\_print} functions that will
dump to the screen, by basically just setting the output type to \cinline{'s'}, e.g.:
\ttindex{apop\_vector\_print} \ttindex{apop\_vector\_print\_int}
\ttindex{apop\_matrix\_print} \ttindex{apop\_matrix\_print\_int}
\ttindex{apop\_data\_print} \ttindex{apop\_data\_print\_int}
\ttindex{apop\_vector\_show} \ttindex{apop\_matrix\_show}
\ttindex{apop\_data\_show}
\begin{lstlisting}
apop_vector_show(a_vector);
apop_matrix_show_int(a_matrix);
apop_data_show_int(data);
\end{lstlisting}

\section{Command-line utilities}
Incidentally, Apophinia includes a handful of \ind{com\-mand-line utilities} for
situations where there is no need to write a full-blown C program. For
all of the utilities below, you can use the \binline{-h} parameter to
get detailed instructions (e.g., \binline {apop\_db\_to\_cross\-tab
-h}).

Three are simply for handling SQLite databases.  
\cind{apop\_text\_to\_db} reads a text file into a database table,
\cind{apop\_merge\_dbs} will send tables from one database to
another, and
\cind{apop\_db\_to\_cross\-tab} will take a table from the SQLite
database and produce a crosstab. All of these are simply wrappers for
the corresponding Apophenia functions, as seen in Chapter \ref{sql}.

Finally, for numerical analysis, there is a client/server program,
\binline{apop}.  With the command \binline{apop
start dataset.db}, the program installs itself in memory.
Subsequent commands are clients to this server. For
example, the user may call \binline{apop query\_to\_data agedata
"select * from ages"}, and the server would run the query and create an
\cinline{apop\_data} set named \cinline{agedata}. The data set resides in
memory, waiting for further commands to operate on it.

For example, the following could be run from the command line:
\begin{lstlisting}
apop start dataset.db
apop query_to_data agedata "select * from ages"
apop estimate_OLS est agedata 
apop estimate_print est
apop stop
\end{lstlisting}

Since all of the handling of \cinline{gsl\_matrix}es,
\cinline{apop\_data} sets, and \cinline{apop\_estimate}s is handled by
the server, and all output is plain text, one only needs
basic text-parsing to fold the input and output of these functions into
scripts in languages such as Perl or Python. \index{Perl} \index{Python}

\comment{
\section{Notes on design} Here are a few notes on the ideas behind
Apophenia's design, which may be of interest to end-users. The executive
summary: the library takes a relatively modern approach to C coding, 
oriented toward facilitating quick statistical queries without hampering
those who need to be more careful in management of data and memory.

\paragraph{Facilitate laziness} First,
default values are oriented toward the lazy. Notably, any
\cinline{model.estimate} function should be able to accept
\cinline{NULL} for the \cinline{estimation\_params} argument. This makes
it easy for those who want quick results to get their results, and those
who want control to specify what they need.

\paragraph{Memory usage} Pointers are good for you, but their management
can be an annoyance. Simply by being in C, Apophenia requires that the
user understand pointers. Many coders who know pointers insist that
most people are too dumb to understand them. But if a person can
understand the concept of projecting a data matrix onto an arbitrary
basis space, he or she probably has enough grey matter to work out that
data and the address of data can be manipulated separately.

However, there are ways to facilitate the process of dealing with memory
allocation and deallocation for the lazy.

The GSL is careful to never allocate large
spans of memory internally, and does not return large blocks of memory
outside of routines with \cinline{alloc} in the name. This imposes work
on the user, however, because so many functions must be preceeded with
several lines of memory allocation. Under the \airq{facilitate laziness}
rule, Apophenia takes the opposite approach: it freely allocates memory behind
your back, although this is documented for every function that does so,
and many functions, such as the estimation routines, return potentially
very large blocks of memory. That means that the declaration and the
estimation can be on one line, or the returned value can be nested in
other functions:
\lstset{numbers=left, numberstyle=\scshape}
\begin{lstlisting}
apop_estimate_print(apop_OLS.estimate(data, NULL));
(or)
apop_estimate *e = apop_OLS.estimate(data, NULL);
\end{lstlisting}
\lstset{numbers=none}
Copy commands and tests also return a pointer to newly-allocated data,
again allowing the user to declare and assign on the same line.

\paragraph{Stats scripts are often short}
The reader will note that line 1 produces a memory leak, since the
\cinline{apop\_estimate} can't be deallocated. But if the whole program
is one line, as in the example on page \pageref{oneliner}, then it
doesn't matter. The typical computer today has around a gigabyte of
memory, while many data sets are only a few hundred observations. That
means that if every single allocation in the analysis results in a memory
leak, the memory lost will still be marginal.


\paragraph{New languages} Computer scientists love writing new
languages.  One author has compiled a list of about
2,500.\footnote{\url{http://people.ku.edu/~nkinners/LangList/Extras/langlist.htm}}
The wisdom of the ages has shown that every language with pretentions
to being the One True Language is eventually superceded by another
language with the same pretentions. There are certainly aspects of
statistics that would benefit from a specialized syntax, but 




The
generally discredited \vocab{Sapir-Whorf hypothesis} claims that how we
think is influenced by the language we speak. 

}


