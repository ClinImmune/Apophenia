\chapter{Apophenia}
%@-     so lgrind will play nice with makeindex

One could divide Apophenia's functions into two categories: haphazard
convenience functions, and a unified worldview of about how data is
analyzed. Some of the convenience functions have already appeared; this
chapter describes the unified world view. If you don't agree with the
worldview, or find it constraining, then don't worry about it; just use
the underlying functions as they come in handy.

This may also be a good place to remind the reader that, as with most of
the stats packages of the world, Apophenia has two types of
documentation: the chatty, not-comprehensive overview you are reading now and the
comprehensive function-by-function reference. The reference is autogenerated from the
source code, and can be found online at \url{http://apophenia.info/doc}
or generated from your own copy of the source using {\tt doxygen} if you
have a copy.\footnote{doxygen is free software and is universally packaged,
so it's easy to get. If you have it installed, run {\tt make doc} in
your source directory.}

Here is a one-sentence summary of statistical analysis: estimate the
parameters of a model
using data. Apophenia thus has three key objects defined that embody
this description, named {\tt apop\_data}, {\tt apop\_model}, and {\tt
apop\_estimate}.\footnote{Notice that the `estimate the parameters of a
model' line readily includes "non-parametric" models. This becomes
especially evident when coding such models, which still wind up being
black boxes that take in a data set and return a set of parameter
estimates.}

The basic story for a statistical analysis is that the researcher
assembles a data set into an {\tt apop\_data} structure, then sends it to
an {\tt apop\_model} so that the model's parameters can be estimated,
and that is returned in an {\tt apop\_estimate} structure.

Supporting these main structures are a few more structures you'd only
have to worry about for fine tuning.  The {\tt apop\_name} structure is
an organized list of row and column names; functions that take an {\tt
apop\_data} set try to automatically handle the names for you.  The {\tt
apop\_inventory} structure lists the elements that an {\tt apop\_estimate}
has generated (no model produces everything). Model estimates accept
an inventory, but all work fine if you send in NULL. Finally, the more
elaborate models, such as MLEs, require some parameters to run, in
which case you will need to fill out an {\tt apop\_estimation\_params}
form and hand it in to the mode.


\paragraph{Data}
The {\tt apop\_data} structure adds a touch of metadata on
top of the basic {\tt gsl\_matrix}. It includes an {\tt apop\_name} structure
(see below), and a table for non-numeric variables. 

\paragraph{Models}
The {\tt apop\_model} structure encapsulates a description of the world
in which the data and the parameters produce observed outcomes. The
apop\_model.estimate() method takes in data and produces an {\tt
apop\_estimate}. 

[Many statistics packages include a model structure that describes only
linear models.  "Linear" models can include a wide range of nonlinear
features, but they are still a subset of measure zero within the class of
models as described above. Currently, Apophenia has no plans to include
a summary syntax for describing linear models; the reader who has a linear
model to be estimated via OLS or GLS is advised to instead manipulate
the data set to the appropriate form and then call {\tt apop\_\-OLS} or
{\tt apop\_\-GLS}.]

Frequently, a model is a probability distribution. The data is assumed
to have been drawn from a given distribution and the question is
only what distributional parameters best fit; e.g., assume the data
is Normally distributed and find the mean and variance.

In fact, one could even use the {\tt apop\_\-model} to describe 
non-statistical models involving optimization subject to constraints;
see the example of section \ref{econ101}.

Because models are often distributions, and because it is not our place
to dictate what you will do with a model, the {\tt apop\_\-model} also includes a
number of additional functions that may be useful for additional analyis,
such as a likelihood function that could be used for ML estimation or
for estimating the Hessian, and a random number generator. Some effort
has been made to ensure that the prepackaged models include as many of
these auxiliary functions as possible; if you are writing your own,
there is no requirement that you provide all functions, and the {\tt apop\_\-maximum\_\-likelihood} 
and {\tt apop\_\-numerical\_\-hessian} functions do a
good job of filling in blanks.

\paragraph{Estimates}
The {\tt apop\_estimate} structure returns all the data one would want
from a regression or ML estimation, including the parameters estimated,
the variance/covariance matrix, the residuals, et cetera. The structure
includes instances of almost all of the other structures listed here, so
that you will have a link to the data, model, and estimation parameters
that produced the estimate, and an inventory of what it contains.

\paragraph{An example}
Here is a program that puts the above structures to work.  It assumes a
data set in a file, such as the {\tt test\_data} file included with
Apophenia's source code.
%[
#include <apophenia/headers.h>

int main(void){
apop_data       *data;
apop_estimate   *est;
apop_inventory  invent;
    apop_convert_text_to_db("data","d",NULL);
    data       = apop_query_to_data("select * from d");
    apop_inventory_set(&invent, 0);
    invent.parameters   = 1;
    est  = apop_OLS.estimate(data, &invent, NULL);
    apop_estimate_print(est);
    return 0;
}
%]

We first read the data into the database, and then pull it into an {\tt
apop\_\-data} set. Then we write an {\tt apop\_\-inventory} that we only want the
parameters, and to not bother finding the variance-covariance matrix or
the residuals or other such things used for hypothesis testing. Then we
send the data and the estimate to the {\tt apop\_\-OLS.est\-i\-mate}
function, which returns, naturally, an {\tt apop\_\-est\-i\-mate}
structure. Then we print it.

Feeling lazy? The program above was good form and demonstrated useful
features, but the code below will do the same thing in even fewer lines:

%[
#include <apophenia/headers.h>
int main(void){
    apop_convert_text_to_db("data","d",NULL);
    apop_estimate_print(apop_OLS.estimate(
         apop_query_to_data("select * from d"), NULL, NULL));
    return 0; }
%]

The drawback is that the intermediate forms aren't saved, but we're busy
executives who don't have time to interrogate intermediate forms anyway.

\subsection{The supporting cast}
\paragraph{Names}
The {\tt apop\_name} structure has three components: a list of column
names, a list of row names, and a list of dependent variable names. It
is intended to accompany the {\tt gsl\_matrix} structure, which holds
all the other information about a data aaray such as the number of rows
and columns.  See {\tt names}.

\paragraph{Inventory}
The {\tt apop\_inventory} structure serves two purposes. It is an input
to an {\tt apop\_\-model}, that tells the function what output you
would like the {\tt apop\_\-estimate} output to include.  Alternatively, you
can just send in a {\tt NULL} pointer, and the functions will return
everything apropos.

It is also an output from these functions, since the returned {\tt
apop\_\-estimate} will include its own {\tt apop\_\-in\-ventory},
giving a list of the elements of the structure which are
actually in use. For example, the regressions won't return a log
likelihood.

There is one element for each element of the {\tt apop\_estimate} structure.

If the {\tt apop\_inventory} will be sent in to a regression/MLE
function, set the appropriate element to either zero or one if you would
like the function to return the designated {\tt apop\_estimate} element.

The {\tt apop\_estimate} structure itself has an {\tt apop\_inventory}
element named {\tt uses} embedded within it. Those elements for
which {\tt uses.elmt} are zero are unallocated pointers (so be careful:
precede any pointer use with an {\tt if(est->uses.element)} clause).

It may sometimes be useful to manipulate the {\tt apop\_estimate} structure's
internal {\tt apop\_\-inventory} element to your own benefit. For
example, if you set {\tt est->uses.residuals = 0} before calling
{\tt apop\_\-print\_\-estimate(est, NULL)}, then the residuals won't get
printed. But be careful: if you then call {\tt apop\_\-estimate\_\-free(est)},
then the residuals won't get freed, either.

\paragraph{Estimate parameters}
The {\tt apop\_estimation\_params} are the details for how an {\tt
apop\_estimate} should do its work; currently it is just the specifications
for tolerances, step sizes, starting points, et cetera, for {\tt apop\_max\-i\-mum\_like\-li\-hood}.
 See {\tt inv\_and\_est}.
