\chapter{Apophenia}
%@-     so lgrind will play nice with makeindex

One could divide Apophenia's functions into two categories: haphazard
convenience functions, and a unified worldview of about how data is
analyzed. Some of the convenience functions have already appeared; this
chapter describes the unified world view. If you don't agree with the
worldview, or find it constraining, then don't worry about it; just use
the underlying functions as they come in handy.

This may also be a good place to remind the reader that, as with most of
the stats packages of the world, Apophenia has two types of
documentation: the chatty, not-comprehensive overview you are reading now and the
comprehensive function-by-function reference. The reference is autogenerated from the
source code, and can be found online at \url{http://apophenia.info/doc}
or generated from your own copy of the source using {\tt doxygen} if you
have a copy.\footnote{doxygen is free software and is universally packaged,
so it's easy to get. If you have it installed, run {\tt make doc} in
your source directory.}

Here is a one-sentence summary of statistical analysis: estimate a model
using data. Apophenia thus has three key objects defined that embody
this description, named {\tt apop\_data}, {\tt apop\_model}, and {\tt
apop\_estimate}.

The basic story for a statistical analysis is that the researcher
assembles a data set into an {\tt apop\_data} structure, then sends it to
an {\tt apop\_model} so that the model's parameters can be estimated,
and that is returned in an {\tt apop\_estimate} structure.

Supporting these main structures are a few more structures you'd only have to worry about 
for fine tuning.
The {\tt apop\_name}
structure is an organized list of row and column names; functions that
take an {\tt apop\_data} set try to automatically handle the names for you.
The {\tt apop\_inventory} structure lists the elements that an {\tt
apop\_estimate} has generated (no model produces everything). Model
estimates accept an inventory, but all work fine if you send in
NULL. Finally, the more elaborate models, such as MLEs, require some parameters to run,
in which case you will need to fill out an {\tt
apop\_estimation\_params}
form and hand it in to the mode.


\paragraph{Data}
The {\tt apop\_data} structure adds a touch of metadata on
top of the basic {\tt gsl\_matrix}. It includes an {\tt apop\_name} structure
(see below), and a table for non-numeric variables. See {\tt data\_struct}.

\paragraph{Models}
The {\tt apop\_model} structure encapsulates a description of the world
in which the data and the parameters produce observed outcomes. The
apop\_model.estimate() method takes in data and produces an {\tt
apop\_estimate}. See {\tt models}.

\paragraph{Estimates}
The {\tt apop\_estimate} structure returns all the data one would want
from a regression or ML estimation, including the parameters estimated,
the variance/covariance matrix, the residuals, et cetera. The structure
includes instances of both of the strucutres below. See {\tt inv\_and\_est}.


\paragraph{An example}
Here is a program that puts the above structures to work.  It assumes a
data set in a file, such as the {\tt test\_data} file included with
Apophenia's source code.
%[
#include <apophenia/headers.h>

int main(void){
apop_data       *data;
apop_estimate   *est;
apop_inventory  invent;
    apop_convert_text_to_db("data","d",NULL);
    data       = apop_query_to_data("select * from d");
    apop_inventory_set(&invent, 0);
    invent.parameters   = 1;
    est  = apop_OLS.estimate(data, &invent, NULL);
    apop_estimate_print(est);
    return 0;
}
%]

We first read the data into the database, and then pull it into an {\tt
apop\_\-data} set. Then we write an {\tt apop\_\-inventory} that we only want the
parameters, and to not bother finding the variance-covariance matrix or
the residuals or other such things used for hypothesis testing. Then we
send the data and the estimate to the {\tt apop\_\-OLS.est\-i\-mate}
function, which returns, naturally, an {\tt apop\_\-est\-i\-mate}
structure. Then we print it.

Feeling lazy? The program above was good form and demonstrated useful
features, but the code below will do the same thing in even fewer lines:

%[
#include <apophenia/headers.h>
int main(void){
    apop_convert_text_to_db("data","d",NULL);
    apop_estimate_print(apop_OLS.estimate(apop_query_to_data("select * from d"), NULL, NULL));
    return 0; }
%]

The drawback is that the intermediate forms aren't saved, but we're busy
executives who don't have time to interrogate intermediate forms anyway.

\subsection{The supporting cast}
\paragraph{Names}
The {\tt apop\_name} structure has three components: a list of column
names, a list of row names, and a list of dependent variable names. It
is intended to accompany the {\tt gsl\_matrix} structure, which holds
all the other information about a data aaray such as the number of rows
and columns.  See {\tt names}.

\paragraph{Inventory}
The {\tt apop\_inventory} structure serves two purposes. It is an input
to a regression or ML estimation, tells the function what output you
would like the {\tt apop\_\-estimate}  output to include. It is also an
output from these functions, since the returned {\tt apop\_\-estimate}
will include its own {\tt apop\_\-in\-ventory},  which can be used later on
to test whether any given element is in use. See {\tt inv\_and\_est}.

\paragraph{Estimate parameters}
The {\tt apop\_estimation\_params} are the details for how an {\tt
apop\_estimate} should do its work; currently it is just the specifications
for tolerances, step sizes, starting points, et cetera, for {\tt apop\_max\-i\-mum\_like\-li\-hood}.
 See {\tt inv\_and\_est}.
