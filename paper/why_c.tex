\section{Why C?}

\index{statistics packages!rants regarding|(}
There are so many other languages out there in which you could do
statistics. Why use C instead of SAS, Stata, SPSS, S-PLUS, SSt, GAUSS, GAMS, GRETL,
MatLab, Minitab, Mupad, Mathematica, Limdep, Octave, R, or RATS? Since this is a
pervasive question, I'm going to spend a few pages answering it as clearly
as possible. Over the course of this, you should also get a better idea
of why C is the way it is, and why things that seem annoying on
the surface will pay off in the long run.

	\ifbook
\subsection{Reason \#1: C will help you do better science.}
As noted above, it's no longer OK to use OLS for everything.
OLS, with all its assumptions, used to be the only technique that we had the computing
power to actually implement. But my four-year old laptop regularly executes
feats of computation that were entirely impossible fifty years ago, and your
computer can do the same.  {\it So why are
we still using theorems written to facilitate computation?} More importantly, why
are we using them in cases where their assumptions aren't true?

Unfortunately, the statistics packages are written around the
specialized, assumption-heavy theorems, and because people do what the
technology facilitates, people who use stats packages are very, very
likely to assume OLS is valid.  If OLS doesn't quite fit, they hit a
brick wall, and don't have a simple way to go further. In the end, they'll
take the path of least resistance and just gloss over OLS's assumptions.

There is nothing more embarassing than a presenter who answers a question
about the assumptions or results of a model with `that's just Stata's
default'---or still worse, (and yes, I have heard this in a real live
presentation by a real live researcher) `I would have corrected this
anomaly in my data, but Stata didn't have a function to do that.' This
is beyond unpersuasive and into the realm of confidence-eroding.

Stats packages aren't designed around the general results, though
it's technically possible to retrofit these packages to use them. Since
they're Turing-complete,\footnote{Alan Turing wrote down an imaginary
machine which could execute a dozen types of instruction.  All
modern programming languages implement these instructions in one way or
another, and are therefore equivalent to Turing's theoretical computer;
by transitivity, they are all equivalent to each other. With enough
perseverence, you could
write a C compiler in MatLab.} you could
write anything in them: maybe a word processor or a painting program. But
why? It's just as easy to write the functions in C using the packages I discuss
here, and the resulting program will be more robust and orders of
magnitude faster, as per Reason \#2.
	\else
[Reason \#1 has been omitted from this excerpt.]
	\fi

\subsection{Reason \#2: Stats packages will break your heart.} Stats packages
are wonderful at first, making it easy to sit down and start working
quickly. As you get better with the language, you'll 
grow to depend on the stats package for more and more
things. And then, one day, you'll get to a problem that's too far
out from what the language designers had in mind, or a problem that is
too large-scale for the language to handle. Your favorite language just
won't be able to do it, even after you spend hours trying to get around
the language's assumptions about what you mean and endless attempts to
optimize the code so it'll run a little bit faster. And after all that,
you'll have nothing but a broken heart.

A full discussion of programming languages is beyond the scope of this book, but
here are a few hints as to how statistics packages can become cumbersome with
time. 

The first is that some languages do not allow you to declare types. This
looks like a convenience at first---you will see that there are a
lot of declarations involved in a typical program, and it can be a
distraction. But the declarations allow the program to run significantly
faster. Some languages get around the type declaration question by simply
declaring everything to be the largest possible type (basically making
everyting a {\tt long double} array).  For very complex data types,
such as lists of lists, it is often difficult (and for exceptionally
perverse cases, impossible) to get the computer to correctly guess what the
type of a variable should be.

The second is that most languages do not have a call-by-reference
mechanism, which will be defined and discussed extensively in Section
\ref{pointers}. As you read \ifbook Chapter \ref{c_crash}\else this overview\fi, imagine that it ends
at Section \ref{prepointers} and you will have an idea of what most
stats packages are like.

Third, some stats packages have only two types of scope: local to
a function, and global. You will see that having many options for
intermediate levels of scope is a central theme to \ifbook Chapter \ref{c_crash}\else this overview\fi,
and this is because good control over a variable's scope is essential
to your sanity when writing programs with more than a few pages of
code. Again, this is something that you won't notice is missing until
you invest heavily in a language and begin writing lengthier analyses.

Finally, all stats packages are slower than C---often hundreds of times
slower. This won't be noticeable for a linear regression on a few thousand
observations, but for very large data sets, or for the maximum likelihood
methods discussed later in this book, this can mean literally days of
waiting instead of several minutes.  Why are stats packages all slower
than C? Because they are all written in C to begin with, so after they
do their preprocessing to determine variable types and translate their
structures into other structures, they just call a C function.

As you read \ifbook Chapter \ref{c_crash}\else this overview\fi, these
problems are worth bearing in mind. C may seem to have some ugly
features, but they will eventually save you heartbreak.
\index{statistics packages!rants regarding|)}

\subsection{Reason \#3: C is universal} 
The software I discuss in this book is available from {\tt www.gnu.org}, for the
system you're using, and for the system you will be using five years from now, for
free. There is no other language I could say that about with such confidence.

This is not only important because you may find yourself in front of
a different type of computer next year, but because we increasingly
expect that the data and analysis behind a work be publically available.
For example, it's a requirement for National Science Foundation funding. But if your analysis uses
a stats package which isn't universally available, then you will break
the hearts of all of your fellow researchers who want to work with your analysis
but for whom it's logistically impossible to do so. Are you sure your
colleague in Madras can afford a Stata license?

