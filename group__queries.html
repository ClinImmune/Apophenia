<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="../index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.3 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Queries</h1>  </div>
</div>
<div class="contents">
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li><a class="anchor" id="gaf28e7d098a9bae73f246186632a82faf"></a><!-- doxytag: member="queries::Store_settings" ref="gaf28e7d098a9bae73f246186632a82faf" args="" -->
#define <b>Store_settings</b>&#160;&#160;&#160;int v = apop_opts.verbose; apop_opts.verbose=0;
<li><a class="anchor" id="ga2e2152950499d383546b6adfd753431f"></a><!-- doxytag: member="queries::Restore_settings" ref="ga2e2152950499d383546b6adfd753431f" args="" -->
#define <b>Restore_settings</b>&#160;&#160;&#160;apop_opts.verbose=v;
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>int <a class="el" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a> (const char *fmt,...)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__queries.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a> (const char *fmt,...)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> (const char *fmt,...)
<li>gsl_matrix * <a class="el" href="group__queries.html#ga8a1da4d925dbafdd2b3318672eac751f">apop_query_to_matrix</a> (const char *fmt,...)
<li>gsl_vector * <a class="el" href="group__queries.html#ga830703db838855b8abd636069c7145de">apop_query_to_vector</a> (const char *fmt,...)
<li>double <a class="el" href="group__queries.html#ga1ad75f9dfba696a3741e28896ed5b75d">apop_query_to_float</a> (const char *fmt,...)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a> (const char *typelist, const char *fmt,...)
</ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>These functions query the database, and most return a value for use on the C-side.</p>
<p>In all cases, your query may be in <code>printf</code> form. For example: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> tabname[] = <span class="stringliteral">&quot;demographics&quot;</span>;
<span class="keywordtype">char</span> colname[] = <span class="stringliteral">&quot;heights&quot;</span>;
<span class="keywordtype">int</span> min_height = 175;
<a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;select %s from %s where %s &gt; %i&quot;</span>, colname, tabname, colname, min_height);
</pre></div><ul>
<li>Blanks in the database (i.e., <code> NULL</code>s) and elements that match <a class="el" href="structapop__opts__type.html">apop_opts.db_nan</a> are filled with <code>NAN</code>s in the matrix. </li>
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga236452b3305ea7b791c781d91a819e3b"></a><!-- doxytag: member="apop_db.c::apop_query" ref="ga236452b3305ea7b791c781d91a819e3b" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a query to the database, return nothing </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>A <code>printf</code>-style SQL query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade862993166c6482f53562fb77721db9"></a><!-- doxytag: member="apop_db.c::apop_query_to_data" ref="gade862993166c6482f53562fb77721db9" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_query_to_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the database, and dumps the result into an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If <a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> is set (it defaults to being "row_names"), and the name of a column matches the name, then the row names are read from that column. </p>

</div>
</div>
<a class="anchor" id="ga1ad75f9dfba696a3741e28896ed5b75d"></a><!-- doxytag: member="apop_db.c::apop_query_to_float" ref="ga1ad75f9dfba696a3741e28896ed5b75d" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_query_to_float </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the database, and dumps the result into a single double-precision floating point number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A double, actually.</dd></dl>
<ul>
<li>This calls <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> and returns the (0,0)th element of the returned matrix. Thus, if your query returns multiple lines, you will get no warning, and the function will return the first in the list (which is not always well-defined; maybe use an {<em>order</em> by} clause in your query if you expect multiple lines).</li>
</ul>
<ul>
<li>If <code>apop_opts.db_name_column</code> is set, then I'll ignore that column. It gets put into the names of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then thrown away when I look at only the <code>gsl_matrix</code> element of that set.</li>
</ul>
<p>If the query returns no rows at all, the function returns <code>NAN</code>. </p>

</div>
</div>
<a class="anchor" id="ga8a1da4d925dbafdd2b3318672eac751f"></a><!-- doxytag: member="apop_db.c::apop_query_to_matrix" ref="ga8a1da4d925dbafdd2b3318672eac751f" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_query_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the database, and dumps the result into a matrix.</p>
<p>Uses <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> and returns just the matrix part; see that function for notes.</p>
<ul>
<li>If <code>apop_opts.db_name_column</code> is set, then I'll ignore that column. It gets put into the names of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then thrown away when I return only the <code>gsl_matrix</code> part of that set.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>gsl_matrix</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f06db34e05b5afb63112f83ad2317b8"></a><!-- doxytag: member="apop_db.c::apop_query_to_mixed_data" ref="ga1f06db34e05b5afb63112f83ad2317b8" args="(const char *typelist, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_query_to_mixed_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query data to an <code>apop_data</code> set, but a mix of names, vectors, matrix elements, and text.</p>
<p>If you are querying to a matrix and maybe a name, use <code>apop_query_to_data</code> (and set <a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> if desired). But if your data is a mix of text and numbers, use this.</p>
<p>The first argument is a character string consisting of the letters <code>nvmtw</code>, one for each column of the SQL output, indicating whether the column is a name, vector, matrix column, text column, or weight vector. You can have only one n, v, and w.</p>
<p>If the query produces more columns than there are elements in the column specification, then the remainder are dumped into the text section. If there are fewer columns produced than given in the spec, the additional elements will be allocated but not filled (i.e., they are uninitialized and will have garbage).</p>
<p>The 'n' character indicates row, meaning that <a class="el" href="structapop__opts__type.html">apop_opts.db_name_column</a> is ignored).</p>
<p>As with the other <code>apop_query_to_</code>... functions, the query can include printf-style format specifiers. </p>

</div>
</div>
<a class="anchor" id="ga2fbd580cd71f481ae04ee03b5cf64ff5"></a><!-- doxytag: member="apop_db.c::apop_query_to_text" ref="ga2fbd580cd71f481ae04ee03b5cf64ff5" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_query_to_text </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump the results of a query into an array of strings.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> structure with the <code>text</code> element filled. Notice that this is always a 2-D array, even if the query returns a single column. In that case, use <code>returned_tab-&gt;text[i][0]</code> to refer to row <code>i</code>.</dd></dl>
<p>For example, the following function will list the tables in a database (much like you could do from the command line using <code>sqlite3 dbname.db ".table"</code>).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">void</span> print_table_list(<span class="keywordtype">char</span> *db_file){
    <a class="code" href="apop__db_8c.html#a4d81aff912df2982697038c51795e358">apop_db_open</a>(db_file);
    <a class="code" href="struct__apop__data.html">apop_data</a> *tab_list= <a class="code" href="group__queries.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;select name from sqlite_master where type==\&quot;table\&quot;;&quot;</span>);
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; tab_list-&gt;textsize[0]; i++)
        printf(<span class="stringliteral">&quot;%s\n&quot;</span>, tab_list-&gt;text[i][0]);
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){
    <span class="keywordflow">if</span> (argc == 1){
        printf(<span class="stringliteral">&quot;Give me a database name, and I will print out the list of tables contained therein.\n&quot;</span>);
        <span class="keywordflow">return</span> 0; 
    }
    print_table_list(argv[1]);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ga830703db838855b8abd636069c7145de"></a><!-- doxytag: member="apop_db.c::apop_query_to_vector" ref="ga830703db838855b8abd636069c7145de" args="(const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_query_to_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the database, and dumps the first column of the result into a gsl_vector.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>gsl_vector</code> holding the first column of the returned matrix. Thus, if your query returns multiple lines, you will get no warning, and the function will return the first in the list.</dd></dl>
<ul>
<li>Uses <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> internally, then throws away all but the first column of the matrix. </li>
<li>If <code>apop_opts.db_name_column</code> is set, then I'll ignore that column. It gets put into the names of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then thrown away when I look at only the <code>gsl_matrix</code> part of that set.</li>
</ul>
<p>If the query returns no columns at all, the function returns <code>NULL</code>. </p>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Wed Oct 19 2011.</div></body></html>
