<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>
<!-- Generated by Doxygen 1.8.1.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Singular value decompositions, determinants, et cetera.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6984006ab44fa7c9c2e99463f7d4081b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> (const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)</td></tr>
<tr class="memitem:ga185243be2d8a93686c68263cc3318f47"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> (const gsl_matrix *in)</td></tr>
<tr class="memitem:ga03038130e4ba55228f9e164dba513961"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> (const gsl_matrix *in)</td></tr>
<tr class="memitem:gaa1715c468336800a21ca86971323ae3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> (gsl_matrix *data, int const dimensions_we_want)</td></tr>
<tr class="memitem:gaf2d13e1b1f20f97e0772a0be41dc430e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d1, const <a class="el" href="structapop__data.html">apop_data</a> *d2, char form1, char form2)</td></tr>
<tr class="memitem:ga1b6ecb8702153658c29369dc2e7cfba9"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This page describes some standard bits of linear algebra that Apophenia facilitates.</p>
<p>See also the printing functions, <a class="el" href="group__apop__print.html">Assorted printing functions</a>, and the <a class="el" href="group__convenience__fns.html">Convenience functions</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6984006ab44fa7c9c2e99463f7d4081b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_det_and_inv </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the determinant of a matrix, its inverse, or both, via LU decomposition. The <code>in</code> matrix is not destroyed in the process.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a>, <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a></dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted/determined.</td></tr>
    <tr><td class="paramname">out</td><td>If you want an inverse, this is where to place the matrix to be filled with the inverse. Will be allocated by the function.</td></tr>
    <tr><td class="paramname">calc_det</td><td>0: Do not calculate the determinant.\ 1: Do.</td></tr>
    <tr><td class="paramname">calc_inv</td><td>0: Do not calculate the inverse.\ 1: Do.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>If <code>calc_det == 1</code>, then return the determinant. Otherwise, just returns zero. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2d13e1b1f20f97e0772a0be41dc430e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for dot products.</p>
<p>First, this requires less typing than the <code>gsl_cblas_dgexx</code> functions.</p>
<p>Second, it makes some use of the semi-overloading of the <a class="el" href="gentle.html#apop_data">apop_data</a> structure. <code>d1</code> may be a vector or a matrix, and the same for <code>d2</code>, so this function can do vector dot matrix, matrix dot matrix, and so on. If <code>d1</code> includes both a vector and a matrix, then later parameters will indicate which to use.</p>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>the left part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_23.png"/> </td></tr>
    <tr><td class="paramname">d2</td><td>the right part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_23.png"/> </td></tr>
    <tr><td class="paramname">form1</td><td>'t' or 'p' or 1: transpose or prime <code>d1-&gt;matrix</code>.<br/>
 'n' or 0: no transpose. (the default)<br/>
 'v': ignore the matrix and use the vector. </td></tr>
    <tr><td class="paramname">form2</td><td>As above, with <code>d2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If two matrices come in, the vector element is <code>NULL</code> and the matrix has the dot product; if either or both are vectors, the vector has the output and the matrix is <code>NULL</code> </dd></dl>
<p>A note for readers of <em>Modeling with Data</em>: the awkward instructions on using this function on p 130 are now obsolete, thanks to the designated initializer syntax for function calls. Notably, in the case where <code>d1</code> is a vector and <code>d2</code> a matrix, then <code>apop_dot(d1,d2,'t')</code> won't work, because <code>'t'</code> now refers to <code>d1</code>. Instead use <code>apop_dot(d1,d2,.form2='t')</code> or <code>apop_dot(d1,d2,0, 't')</code></p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NULL</td><td>If something goes wrong, I return NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03038130e4ba55228f9e164dba513961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_determinant </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the determinant of a matrix. The <code>in</code> matrix is not destroyed in the process.</p>
<p>See also <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> , or <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The determinant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga185243be2d8a93686c68263cc3318f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_inverse </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverts a matrix. The <code>in</code> matrix is not destroyed in the process. You may want to call <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> first to check that your input is invertible, or use <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Its inverse. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1715c468336800a21ca86971323ae3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_matrix_pca </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimensions_we_want</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Principal component analysis: hand in a matrix and (optionally) a number of desired dimensions, and I'll return a data set where each column of the matrix is an eigenvector. The columns are sorted, so column zero has the greatest weight. The vector element of the data set gives the weights.</p>
<p>You also specify the number of elements your principal component space should have. If this is equal to the rank of the space in which the input data lives, then the sum of weights will be one. If the dimensions desired is less than that (probably so you can prepare a plot), then the weights will be accordingly smaller, giving you an indication of how much variation these dimensions explain.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input matrix. (No default. If <code>NULL</code>, I'll return <code>NULL</code>.) I modify int in place so that each column has mean zero.</td></tr>
    <tr><td class="paramname">dimensions_we_want</td><td>(default: the size of the covariance matrix, i.e. <code>data-&gt;size2</code>) The singular value decomposition will return this many of the eigenvectors with the largest eigenvalues.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set whose matrix is the principal component space. Each column of the returned matrix will be another eigenvector; the columns will be ordered by the eigenvalues. The data set's vector will be the largest eigenvalues, scaled by the total of all eigenvalues (including those that were thrown out). The sum of these returned values will give you the percentage of variance explained by the factor analysis. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b6ecb8702153658c29369dc2e7cfba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_numerical_gradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GSL provides one-dimensional numerical differentiation; here's the multidimensional extension.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to use for all evaluations. It remains constant throughout. </td></tr>
    <tr><td class="paramname">model</td><td>The model, expressing the function whose derivative is sought. The gradient is taken via small changes along the model parameters. </td></tr>
    <tr><td class="paramname">delta</td><td>The size of the differential. If you explicitly give me a <code>delta</code>, I'll use it. If <code>delta</code> is not specified, but <code>model</code> has <code>method_settings</code> of type <code>apop_ml_params</code>, then the <code>delta</code> element is used for the differential. Else, I use 1e-3.</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment"> gsl_vector *gradient = apop_numerical_gradient(data, your_parametrized_model);</pre><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Oct 8 2012.</div></body></html>
