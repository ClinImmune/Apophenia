<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.4 -->
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">apop_conversions.c File Reference</div>  </div>
</div>
<div class="contents">
<h2><a name="nested-classes"></a>
Data Structures</h2>
<ul>
<li>struct <a class="el" href="structline__parse__t.html">line_parse_t</a>
<li>struct <a class="el" href="structapop__char__info.html">apop_char_info</a>
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="anchor" id="ab319c5937e4c2623e2c6d7e0064173db"></a><!-- doxytag: member="apop_conversions.c::xprintf" ref="ab319c5937e4c2623e2c6d7e0064173db" args="(char **q, char *format,...)" -->
void <b>xprintf</b> (char **q, char *format,...)
<li>double * <a class="el" href="group__conversions.html#gab48a3b2c6619dba38053eccf86734adc">apop_vector_to_array</a> (const gsl_vector *in)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a> (double *in, int size)
<li>gsl_matrix * <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> (const gsl_vector *in, char row_col)
<li>gsl_matrix * <a class="el" href="group__conversions.html#ga5c7ed1341ef1be13e2e277f9f31e42df">apop_array_to_matrix</a> (const double **in, const int rows, const int cols)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__conversions.html#gaffca0627028a244e262098cf3cf19b28">apop_array_to_data</a> (const double **in, const int rows, const int cols)
<li>gsl_matrix * <a class="el" href="group__conversions.html#gae8ac57006d4673be7352bcd16debad7f">apop_line_to_matrix</a> (double *line, int rows, int cols)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__conversions.html#gac92b5b4d0e985bcca2e6df1835195743">apop_line_to_data</a> (double *in, int vsize, int rows, int cols)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> (char *tabname, char *r1, char *r2, char *datacol)
<li>void <a class="el" href="apop__conversions_8c.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *in)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *in)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a> (char const *text_file, int has_row_names, int has_col_names, int const *field_ends, char const *delimiters)
<li>void <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> (const gsl_vector *in, <a class="el" href="struct__apop__data.html">apop_data</a> *d, char use_info_pages)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> (const <a class="el" href="struct__apop__data.html">apop_data</a> *in, gsl_vector *out, char all_pages, char use_info_pages)
<li><a class="anchor" id="a65a20082f0b120016f673e7d2ad899a8"></a><!-- doxytag: member="apop_conversions.c::apop_data_fill_base" ref="a65a20082f0b120016f673e7d2ad899a8" args="(apop_data *in, double ap[])" -->
<a class="el" href="struct__apop__data.html">apop_data</a> * <b>apop_data_fill_base</b> (<a class="el" href="struct__apop__data.html">apop_data</a> *in, double ap[])
<li><a class="anchor" id="a68210ee2c87e9cbb7733a14eb907b6cd"></a><!-- doxytag: member="apop_conversions.c::apop_vector_fill_base" ref="a68210ee2c87e9cbb7733a14eb907b6cd" args="(gsl_vector *in, double ap[])" -->
gsl_vector * <b>apop_vector_fill_base</b> (gsl_vector *in, double ap[])
<li><a class="anchor" id="a30fca967b854f3c5a47e3f8aff2726fb"></a><!-- doxytag: member="apop_conversions.c::apop_matrix_fill_base" ref="a30fca967b854f3c5a47e3f8aff2726fb" args="(gsl_matrix *in, double ap[])" -->
gsl_matrix * <b>apop_matrix_fill_base</b> (gsl_matrix *in, double ap[])
<li>void <a class="el" href="apop__conversions_8c.html#ae8eca5bb4fb4ebf7e384d47b585b9484">apop_data_set_row</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *d, <a class="el" href="struct__apop__data.html">apop_data</a> *row, int row_number)
<li>char * <a class="el" href="apop__conversions_8c.html#ac6114b6a2be902c83a75d4367db4371f">prep_string_for_sqlite</a> (int prepped_statements, char const *astring)
<li>int <a class="el" href="group__conversions.html#gaa57d56a9a364a4f2955d27741bbbf137">apop_text_to_db</a> (char const *text_file, char *tabname, int has_row_names, int has_col_names, char **field_names, int const *field_ends, <a class="el" href="struct__apop__data.html">apop_data</a> *field_params, char *table_params, char const *delimiters)
</ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li><a class="anchor" id="ad6e663497d2c934364b3bcf07496b30b"></a><!-- doxytag: member="apop_conversions.c::db" ref="ad6e663497d2c934364b3bcf07496b30b" args="" -->
sqlite3 * <b>db</b>
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The various functions to convert from one format to another. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aee8c299b83b8500b8b6ecd30817353c8"></a><!-- doxytag: member="apop_conversions.c::apop_crosstab_to_db" ref="aee8c299b83b8500b8b6ecd30817353c8" args="(apop_data *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_crosstab_to_db </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>row_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>col_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See <a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> for the storyline; this is the complement, which takes a crosstab and writes its values to the database.</p>
<p>For example, I would take </p>
<table  frame="box">
<tr>
<td></td><td>c0</td><td>c1 </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>r0</td><td>2</td><td>3 </td></tr>
<tr>
<td>r1</td><td>0</td><td>4 </td></tr>
</table>
<p>and do the following writes to the database:</p>
<div class="fragment"><pre class="fragment">insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 2);
insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 4);
</pre></div><ul>
<li>If your data set does not have names (or not enough names), I will use the scheme above, filling in names of the form <code>r0</code>, <code>r1</code>, ... <code>c0</code>, <code>c1</code>, .... Text columns get their own numbering system, <code>t0</code>, <code>t1</code>, ..., which is a little more robust than continuing the column count from the matrix.</li>
</ul>
<ul>
<li>I handle only the matrix and text. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8c4bb25171301f09a35c36306a7b9783"></a><!-- doxytag: member="apop_conversions.c::apop_data_rank_compress" ref="a8c4bb25171301f09a35c36306a7b9783" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_rank_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>One often finds data where the column indicates the value of the data point. There may be two columns, and a mark in the first indicates a miss while a mark in the second is a hit. Or say that we have the following list of observations:</p>
<div class="fragment"><pre class="fragment">2 3 3 2 1 1 2 1 1 2 1 1
</pre></div><p> Then we could write this as: </p>
<div class="fragment"><pre class="fragment">0  1  2  3
----------
0  6  4  2
</pre></div><p> because there are six 1s observed, four 2s observed, and two 3s observed. We call this rank format, because 1 (or zero) is typically the most common, 2 is second most common, et cetera.</p>
<p>This function takes in a list of observations, and aggregates them into a single row in rank format.</p>
<ul>
<li>For the complement, see <a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>.</li>
</ul>
<ul>
<li>You may be interested in <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> to convert real numbers or text into a matrix of categories.</li>
</ul>
<ul>
<li>The number of bins is simply the largest number found. So if there are bins {0, 1, 2} and your data set happens to consist of <code>0 0 1 1 0</code>, then I won't know to generate results with three bins where the last bin has probability zero.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">/* A round trip: generate Zipf-distributed draws, summarize them to a single list of</span>
<span class="comment">rankings, then expand the rankings to a list of single entries. The sorted list at the end</span>
<span class="comment">of this should be identical to the (sorted) original list. */</span>

<span class="keywordtype">void</span> rank_round_trip(gsl_rng *r){
    <span class="keywordtype">int</span> i, length = 1e4;
    <a class="code" href="struct__apop__model.html">apop_model</a> *a_zipf = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, 3.2);
    <a class="code" href="struct__apop__data.html">apop_data</a> *draws = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(length);
    <span class="keywordflow">for</span> (i=0; i&lt; length; i++)
        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a>(draws, i, -1), r, a_zipf);
    <a class="code" href="struct__apop__data.html">apop_data</a> *by_rankings = <a class="code" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>(draws);
    <span class="comment">//The first row of the matrix is suitable for plotting.</span>
    <span class="comment">//apop_data_show(by_rankings);</span>
    assert(<a class="code" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a>(by_rankings-&gt;matrix) == length);

    <a class="code" href="struct__apop__data.html">apop_data</a> *re_expanded = <a class="code" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>(by_rankings);
    gsl_sort_vector(draws-&gt;vector);
    gsl_sort_vector(re_expanded-&gt;vector);
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(draws-&gt;vector, re_expanded-&gt;vector) &lt; 1e-5);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a2feb17743f8b07b8ddcf457362cabefc"></a><!-- doxytag: member="apop_conversions.c::apop_data_rank_expand" ref="a2feb17743f8b07b8ddcf457362cabefc" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_rank_expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The complement to this is <a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>; see that function's documentation for the story and an example.</p>
<p>This function takes in a data set where the zeroth column includes the count(s) of times that zero was observed, the first gives the count(s) of times that one was observed, et cetera. It outputs a data set whose vector element includes a list that has exactly the given frequency of zeros, ones, et cetera. </p>

</div>
</div>
<a class="anchor" id="ae8eca5bb4fb4ebf7e384d47b585b9484"></a><!-- doxytag: member="apop_conversions.c::apop_data_set_row" ref="ae8eca5bb4fb4ebf7e384d47b585b9484" args="(apop_data *d, apop_data *row, int row_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_set_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Now that you've used <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a> to pull a row from an <a class="el" href="gentle.html#apop_data">apop_data</a> set, this function lets you write that row to another position in the same data set or a different data set entirely.</p>
<p>The set written to must have the same form as the original: </p>
<ul>
<li>a vector element has to be present if one existed in the original, </li>
<li>same for the weights vector, </li>
<li>the matrix in the destination has to have as many columns as in the original, and </li>
<li>the text has to have a row long enough to hold the original</li>
</ul>
<p>If any of the source elements are <code>NULL</code>, I won't bother to check that element in the destination. </p>

</div>
</div>
<a class="anchor" id="aebe17fe6f2b0c49c0c90824b7a68ff90"></a><!-- doxytag: member="apop_conversions.c::apop_db_to_crosstab" ref="aebe17fe6f2b0c49c0c90824b7a68ff90" args="(char *tabname, char *r1, char *r2, char *datacol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_db_to_crosstab </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datacol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give the name of a table in the database, and names of three of its columns: the x-dimension, the y-dimension, and the data. the output is a 2D matrix with rows indexed by r1 and cols by r2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tabname</td><td>The database table I'm querying. Anything that will work inside a <code>from</code> clause is OK, such as a subquery in parens. </td></tr>
    <tr><td class="paramname">r1</td><td>The column of the data set that will indicate the rows of the output crosstab </td></tr>
    <tr><td class="paramname">r2</td><td>The column of the data set that will indicate the columns of the output crosstab </td></tr>
    <tr><td class="paramname">datacol</td><td>The column of the data set holding the data for the cells of the crosstab</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the query to get data to fill the table (select r1, r2, datacol from tabname) returns an empty data set, then I will return a <code>NULL</code> data set and if <code>apop_opts.verbosity &gt;= 1</code> print a warning.</li>
</ul>
<ul>
<li>This setup presumes that there is one value for each (row, col) coordinate in the data. You may want an aggregate instead. There are two ways to do this, both of which hack the fact that this function runs a simple <code>select</code> query to generate the data. One is to specify an ad hoc table to pull from:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> * out = <a class="code" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;(select row, col, count(*) ct from base_data group by row, col)&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>,  <span class="stringliteral">&quot;ct&quot;</span>);
</pre></div><p>The other is to use the fact that the table name will be at the end of the query, so you can add conditions to the table:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> * out = <a class="code" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;base_data group by row, col&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>, <span class="stringliteral">&quot;count(*)&quot;</span>);
<span class="comment">//which will expand to &quot;select row, col, count(*) from base_data group by row, col&quot;</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6114b6a2be902c83a75d4367db4371f"></a><!-- doxytag: member="apop_conversions.c::prep_string_for_sqlite" ref="ac6114b6a2be902c83a75d4367db4371f" args="(int prepped_statements, char const *astring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* prep_string_for_sqlite </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prepped_statements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>astring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>--If the string has zero length, then it's probably a missing value. --If the string isn't a number, it needs quotes </p>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Tue Mar 13 2012.</div></body></html>
