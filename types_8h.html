<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">types.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="types_8h_source.html">Go to the source code of this file.</a></p>
<h2><a name="nested-classes"></a>
Data Structures</h2>
<ul>
<li>struct <a class="el" href="structapop__name.html">apop_name</a>
<li>struct <a class="el" href="structapop__data.html">apop_data</a>
<li>struct <a class="el" href="structapop__settings__type.html">apop_settings_type</a>
<li>struct <a class="el" href="structapop__model.html">apop_model</a>
<li>struct <a class="el" href="structapop__opts__type.html">apop_opts_type</a>
</ul>
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li>#define <a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(dataset, type,...)&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})
<li>#define <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(freeme)&#160;&#160;&#160;(<a class="el" href="types_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a>(freeme) ? 0 : ((freeme)= NULL))
<li>#define <a class="el" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(in,...)
<li><a class="anchor" id="a79b5994e799d38ad44d646d7a457f42d"></a><!-- doxytag: member="types.h::apop_line_to_vector" ref="a79b5994e799d38ad44d646d7a457f42d" args="" -->
#define <b>apop_line_to_vector</b>&#160;&#160;&#160;<a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a>
<li>#define <a class="el" href="types_8h.html#af9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a>(avfin,...)&#160;&#160;&#160;apop_vector_fill_base((avfin), (double []) {__VA_ARGS__})
<li>#define <a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(adfin,...)&#160;&#160;&#160;apop_data_fill_base((adfin), (double []) {__VA_ARGS__})
<li>#define <a class="el" href="types_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(dataset,...)&#160;&#160;&#160;apop_text_fill_base((dataset), (char* []) {__VA_ARGS__, NULL})
<li>#define <a class="el" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>(sizes,...)&#160;&#160;&#160;<a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> sizes, __VA_ARGS__)
<li>#define <a class="el" href="types_8h.html#abbdfc523f5b269827db8cebf28216e28">apop_gaussian</a>
<li><a class="anchor" id="aaae03e0c8a6bb5f02bb422f4fca465ba"></a><!-- doxytag: member="types.h::apop_OLS" ref="aaae03e0c8a6bb5f02bb422f4fca465ba" args="" -->
#define <b>apop_OLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>
<li><a class="anchor" id="af417b9601adfa9cefad8c9a377a9674f"></a><!-- doxytag: member="types.h::apop_PMF" ref="af417b9601adfa9cefad8c9a377a9674f" args="" -->
#define <b>apop_PMF</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>
<li><a class="anchor" id="adb7cd4412e9fca67bb14aa22662aaa65"></a><!-- doxytag: member="types.h::apop_F_distribution" ref="adb7cd4412e9fca67bb14aa22662aaa65" args="" -->
#define <b>apop_F_distribution</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga88a178ec7fceed826f72caa52eccca93">apop_f_distribution</a>
<li><a class="anchor" id="ad1974e60ac54b2f06a9731ecc42c74e0"></a><!-- doxytag: member="types.h::apop_WLS" ref="ad1974e60ac54b2f06a9731ecc42c74e0" args="" -->
#define <b>apop_WLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaa030af2c41ac564c3a9ccce14b06f13c">apop_wls</a>
<li><a class="anchor" id="aaf1281c546207c8e27e4c8a9239ec3f9"></a><!-- doxytag: member="types.h::apop_IV" ref="aaf1281c546207c8e27e4c8a9239ec3f9" args="" -->
#define <b>apop_IV</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga1efcbbe0410c89401354c762363a909f">apop_iv</a>
<li>#define <a class="el" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(in,...)
<li>#define <a class="el" href="types_8h.html#a40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a>(...)&#160;&#160;&#160;apop_model_mixture_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})
<li>#define <a class="el" href="types_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(...)&#160;&#160;&#160;apop_model_stack_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})
<li>#define <a class="el" href="types_8h.html#a15d9e73643bf66f7d69c7ebf959757aa">apop_model_coordinate_transform</a>(...)&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a>, apop_ct, __VA_ARGS__)
<li>#define <a class="el" href="types_8h.html#ab664f68b5e481bec56c8ddc7f16928c0">apop_model_dcompose</a>(...)&#160;&#160;&#160;Apop_model_copy_set(apop_composition, apop_composition, __VA_ARGS__)
<li>#define <a class="el" href="types_8h.html#a34644b9d55c7528b47f0b887c9241928">apop_model_dconstrain</a>(...)&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, __VA_ARGS__)
</ul>
<h2><a name="typedef-members"></a>
Typedefs</h2>
<ul>
<li>typedef struct <a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="types_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>
<li>typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="types_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a>
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="el" href="structapop__name.html">apop_name</a> * <a class="el" href="types_8h.html#a29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> (void)
<li>int <a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a> (<a class="el" href="structapop__name.html">apop_name</a> *n, char const *add_me, char type)
<li>void <a class="el" href="types_8h.html#a62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> (<a class="el" href="structapop__name.html">apop_name</a> *free_me)
<li>void <a class="el" href="types_8h.html#af7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> (<a class="el" href="structapop__name.html">apop_name</a> *n)
<li>void <a class="el" href="types_8h.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> (<a class="el" href="structapop__name.html">apop_name</a> *n1, <a class="el" href="structapop__name.html">apop_name</a> *nadd, char type1, char typeadd)
<li><a class="el" href="structapop__name.html">apop_name</a> * <a class="el" href="types_8h.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> (<a class="el" href="structapop__name.html">apop_name</a> *in)
<li>int <a class="el" href="types_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> (const <a class="el" href="structapop__name.html">apop_name</a> *n, const char *findme, const char type)
<li><a class="anchor" id="a1b050ee3cfbb8858576bca6ae07571df"></a><!-- doxytag: member="types.h::apop_data_add_names_base" ref="a1b050ee3cfbb8858576bca6ae07571df" args="(apop_data *d, const char type, char const **names)" -->
void <b>apop_data_add_names_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, const char type, char const **names)
<li>char <a class="el" href="types_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *freeme)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> (gsl_matrix *m)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> (gsl_vector *v)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> (<a class="el" href="structapop__data.html">apop_data</a> *m1, <a class="el" href="structapop__data.html">apop_data</a> *m2, char posn, char inplace)
<li><a class="el" href="structapop__data.html">apop_data</a> ** <a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int splitpoint, char r_or_c)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="anchor" id="a1312f6568cfe832f1e35f7f44482ffb4"></a><!-- doxytag: member="types.h::apop_data_rm_columns" ref="a1312f6568cfe832f1e35f7f44482ffb4" args="(apop_data *d, int *drop)" -->
void <b>apop_data_rm_columns</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, int *drop)
<li>void <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> (<a class="el" href="structapop__data.html">apop_data</a> *out, const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li>double * <a class="el" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const int row, const int col, const char *rowname, const char *colname, const char *page)
<li>double <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const size_t row, const int col, const char *rowname, const char *colname, const char *page)
<li>int <a class="el" href="group__data__set__get.html#ga1e7ba48032cb438271d57818b85613f2">apop_data_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const size_t row, const int col, const double val, const char *rowname, const char *colname, const char *page)
<li>void <a class="el" href="types_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char *name, double val)
<li>int <a class="el" href="types_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col, const char *fmt,...)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col)
<li>void <a class="el" href="types_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> (char ***freeme, int rows, int cols)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a06f38caecb66ec90b18b406b15068381">apop_data_transpose</a> (<a class="el" href="structapop__data.html">apop_data</a> const *in, char transpose_text)
<li>gsl_matrix * <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> (gsl_matrix *m, size_t newheight, size_t newwidth)
<li>gsl_vector * <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> (gsl_vector *v, size_t newheight)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char **colnames)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char match)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *dataset, <a class="el" href="structapop__data.html">apop_data</a> *newpage, const char *title)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char free_p)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int *drop, int(*do_drop)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), void *drop_parameter)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#ae1f659437ab89ac1e4df447023edf040">apop_model_draws</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, int count, gsl_rng *rng, <a class="el" href="structapop__data.html">apop_data</a> *draws)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)
<li>gsl_matrix * <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> (const gsl_vector *in, char row_col)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> (char *tabname, char *r1, char *r2, char *datacol)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a> (double *in, int size)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a> (char const *text_file, int has_row_names, int has_col_names, int const *field_ends, char const *delimiters)
<li>int <a class="el" href="group__conversions.html#gaa57d56a9a364a4f2955d27741bbbf137">apop_text_to_db</a> (char const *text_file, char *tabname, int has_row_names, int has_col_names, char **field_names, int const *field_ends, <a class="el" href="structapop__data.html">apop_data</a> *field_params, char *table_params, char const *delimiters)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li>void <a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in, gsl_vector *out, char all_pages, char use_info_pages)
<li>void <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> (const gsl_vector *in, <a class="el" href="structapop__data.html">apop_data</a> *d, char use_info_pages)
<li><a class="anchor" id="a9801d051a0ea37b5f7516a70b4054188"></a><!-- doxytag: member="types.h::apop_data_fill_base" ref="a9801d051a0ea37b5f7516a70b4054188" args="(apop_data *in, double[])" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_data_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double[])
<li><a class="anchor" id="a0b73de331ecf350babafa9418795860d"></a><!-- doxytag: member="types.h::apop_vector_fill_base" ref="a0b73de331ecf350babafa9418795860d" args="(gsl_vector *in, double[])" -->
gsl_vector * <b>apop_vector_fill_base</b> (gsl_vector *in, double[])
<li><a class="anchor" id="a1fd20a9fd056845b5469b6d3bb48c653"></a><!-- doxytag: member="types.h::apop_text_fill_base" ref="a1fd20a9fd056845b5469b6d3bb48c653" args="(apop_data *data, char *text[])" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_text_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, char *text[])
<li>int <a class="el" href="types_8h.html#a47313d1f22af539e43f5ff02dd0e8f90">apop_data_set_row</a> (<a class="el" href="structapop__data.html">apop_data</a> *row, <a class="el" href="structapop__data.html">apop_data</a> *d, int row_number)
<li>void <a class="el" href="group__models.html#gab29755a86b82dfe31cdd01d55431cc09">apop_model_free</a> (<a class="el" href="structapop__model.html">apop_model</a> *free_me)
<li>void <a class="el" href="group__output.html#gab7bf9adff9b97c60c5839ae72ba4fb7f">apop_model_print</a> (<a class="el" href="structapop__model.html">apop_model</a> *print_me, FILE *out)
<li><a class="anchor" id="a4fa08e29db38e8dcc111899c942022d9"></a><!-- doxytag: member="types.h::apop_model_show" ref="a4fa08e29db38e8dcc111899c942022d9" args="(apop_model *print_me)" -->
void <b>apop_model_show</b> (<a class="el" href="structapop__model.html">apop_model</a> *print_me)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a> (<a class="el" href="structapop__model.html">apop_model</a> *in)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>void <a class="el" href="group__models.html#ga228b013bc80f308900882312cab93eb3">apop_score</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_vector *out, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#ga5e160c8d0a0ee660c89fb3f6de2af89c">apop_log_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>void <a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>void <a class="el" href="group__models.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="types_8h.html#a69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> (double m, double v)
<li><a class="anchor" id="a0b818ff6672229f10c3e559ba9cffb65"></a><!-- doxytag: member="types.h::apop_model_set_parameters_base" ref="a0b818ff6672229f10c3e559ba9cffb65" args="(apop_model *in, double ap[])" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_set_parameters_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *in, double ap[])
<li><a class="anchor" id="a5f10c642ac9a8c9342da4530de1a4e95"></a><!-- doxytag: member="types.h::apop_model_mixture_base" ref="a5f10c642ac9a8c9342da4530de1a4e95" args="(apop_model **inlist)" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_mixture_base</b> (<a class="el" href="structapop__model.html">apop_model</a> **inlist)
<li><a class="anchor" id="a4c5afbd3068134ca9b20997e132d132f"></a><!-- doxytag: member="types.h::apop_model_stack_base" ref="a4c5afbd3068134ca9b20997e132d132f" args="(apop_model *mlist[])" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_stack_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *mlist[])
<li><a class="anchor" id="aad65cf464db938a7fbd57de43dfe1c87"></a><!-- doxytag: member="types.h::apop_map" ref="aad65cf464db938a7fbd57de43dfe1c87" args="(apop_data *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(apop_data *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(apop_data *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(apop_data *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(apop_data *, int), void *param, int inplace, char part, int all_pages)" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_map</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, int inplace, char part, int all_pages)
<li><a class="anchor" id="a871b9e67a6ae243f7420e6943e28e8a0"></a><!-- doxytag: member="types.h::apop_map_sum" ref="a871b9e67a6ae243f7420e6943e28e8a0" args="(apop_data *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(apop_data *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(apop_data *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(apop_data *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(apop_data *, int), void *param, char part, int all_pages)" -->
double <b>apop_map_sum</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, char part, int all_pages)
<li>gsl_vector * <a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> (const gsl_matrix *m, double(*fn)(gsl_vector *))
<li>gsl_vector * <a class="el" href="group__mapply.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> (const gsl_vector *v, double(*fn)(double))
<li>void <a class="el" href="group__mapply.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> (gsl_matrix *m, void(*fn)(gsl_vector *))
<li>void <a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> (gsl_vector *v, void(*fn)(double *))
<li>gsl_matrix * <a class="el" href="group__mapply.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> (const gsl_matrix *in, double(*fn)(double))
<li>void <a class="el" href="group__mapply.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> (gsl_matrix *in, void(*fn)(double *))
<li>double <a class="el" href="group__mapply.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> (const gsl_vector *in, double(*fn)(double))
<li>double <a class="el" href="group__mapply.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> (const gsl_matrix *in, double(*fn)(gsl_vector *))
<li>double <a class="el" href="group__mapply.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> (const gsl_matrix *in, double(*fn)(double))
<li><a class="anchor" id="a2873c2a8dd007dad4084aa8d2d99386d"></a><!-- doxytag: member="types.h::apop_plot_line_and_scatter" ref="a2873c2a8dd007dad4084aa8d2d99386d" args="(apop_data *data, apop_model *est, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_line_and_scatter</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *est, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="ae2ce761ffa02ae5f9ccc7bb73271c164"></a><!-- doxytag: member="types.h::apop_plot_histogram" ref="ae2ce761ffa02ae5f9ccc7bb73271c164" args="(gsl_vector *data, size_t bin_count, char *with, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_histogram</b> (gsl_vector *data, size_t bin_count, char *with, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a01ca2ac09dce700d029ea135ed1f1f66"></a><!-- doxytag: member="types.h::apop_plot_lattice" ref="a01ca2ac09dce700d029ea135ed1f1f66" args="(const apop_data *d, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_lattice</b> (const <a class="el" href="structapop__data.html">apop_data</a> *d, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a5fba943001159cdb1737670f15aaec38"></a><!-- doxytag: member="types.h::apop_plot_qq" ref="a5fba943001159cdb1737670f15aaec38" args="(gsl_vector *v, apop_model *m, char const *output_file, FILE *output_pipe, char output_type, char output_append, size_t bins, gsl_rng *r)" -->
void <b>apop_plot_qq</b> (gsl_vector *v, <a class="el" href="structapop__model.html">apop_model</a> *m, char const *output_file, FILE *output_pipe, char output_type, char output_append, size_t bins, gsl_rng *r)
<li><a class="anchor" id="a574722083b2fb950010725438121c42c"></a><!-- doxytag: member="types.h::apop_plot_triangle" ref="a574722083b2fb950010725438121c42c" args="(apop_data *in, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_triangle</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a58b7fdc2b056a2a09abc17640d23cfa1"></a><!-- doxytag: member="types.h::apop_matrix_print" ref="a58b7fdc2b056a2a09abc17640d23cfa1" args="(const gsl_matrix *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_matrix_print</b> (const gsl_matrix *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a6b48138d9afee03e9040855c7d8ec768"></a><!-- doxytag: member="types.h::apop_vector_print" ref="a6b48138d9afee03e9040855c7d8ec768" args="(gsl_vector *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_vector_print</b> (gsl_vector *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a5bb65954561f942909d391259cc770d8"></a><!-- doxytag: member="types.h::apop_data_print" ref="a5bb65954561f942909d391259cc770d8" args="(const apop_data *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_data_print</b> (const <a class="el" href="structapop__data.html">apop_data</a> *data, char const *output_file, FILE *output_pipe, char output_type, char output_append)
<li>void <a class="el" href="group__apop__print.html#gae7f619a8c83d791ce3d07bf4f6eecb32">apop_matrix_show</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a> (const gsl_vector *data)
<li>void <a class="el" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data)
</ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li><a class="el" href="structapop__opts__type.html">apop_opts_type</a> <a class="el" href="types_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>
<li><a class="anchor" id="ae6cabd19bb6fe21b69caacb6e7c049cd"></a><!-- doxytag: member="types.h::apop_beta" ref="ae6cabd19bb6fe21b69caacb6e7c049cd" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_beta</b>
<li><a class="anchor" id="a0b078785923b7ebf991959e5fa48630e"></a><!-- doxytag: member="types.h::apop_bernoulli" ref="a0b078785923b7ebf991959e5fa48630e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_bernoulli</b>
<li><a class="anchor" id="a59528acef7371d496b3d53f8f1972222"></a><!-- doxytag: member="types.h::apop_binomial" ref="a59528acef7371d496b3d53f8f1972222" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_binomial</b>
<li><a class="anchor" id="a289aee941407e021f68214687d656056"></a><!-- doxytag: member="types.h::apop_chi_squared" ref="a289aee941407e021f68214687d656056" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_chi_squared</b>
<li><a class="anchor" id="a0ac4c68d07c52e2133bea97033efb9b2"></a><!-- doxytag: member="types.h::apop_dirichlet" ref="a0ac4c68d07c52e2133bea97033efb9b2" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_dirichlet</b>
<li><a class="anchor" id="a5da48b7a513b0edffc1039b793d2bf1e"></a><!-- doxytag: member="types.h::apop_exponential" ref="a5da48b7a513b0edffc1039b793d2bf1e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_exponential</b>
<li><a class="anchor" id="a5a879b97021e4187cf93d1319900e11c"></a><!-- doxytag: member="types.h::apop_f_distribution" ref="a5a879b97021e4187cf93d1319900e11c" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_f_distribution</b>
<li><a class="anchor" id="a343bdd2f8ac26b9dfc3aab70371dc1a5"></a><!-- doxytag: member="types.h::apop_gamma" ref="a343bdd2f8ac26b9dfc3aab70371dc1a5" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_gamma</b>
<li><a class="anchor" id="ad427ffccf160021bc1ce64ddcd792d9e"></a><!-- doxytag: member="types.h::apop_improper_uniform" ref="ad427ffccf160021bc1ce64ddcd792d9e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_improper_uniform</b>
<li><a class="anchor" id="a126c685e799d0eec806c5819f91845cc"></a><!-- doxytag: member="types.h::apop_iv" ref="a126c685e799d0eec806c5819f91845cc" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_iv</b>
<li><a class="anchor" id="a4b6cd49361e8635fd5e3e3312e8040ed"></a><!-- doxytag: member="types.h::apop_kernel_density" ref="a4b6cd49361e8635fd5e3e3312e8040ed" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_kernel_density</b>
<li><a class="anchor" id="a9457bd24a17a8705f4ee1c8fe7807dd9"></a><!-- doxytag: member="types.h::apop_loess" ref="a9457bd24a17a8705f4ee1c8fe7807dd9" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_loess</b>
<li><a class="anchor" id="ab3e8bb3aac8ce211c9ebcb7e2ef06241"></a><!-- doxytag: member="types.h::apop_logit" ref="ab3e8bb3aac8ce211c9ebcb7e2ef06241" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_logit</b>
<li><a class="anchor" id="acc72d4e9d073dd029032675fd7c7feb1"></a><!-- doxytag: member="types.h::apop_lognormal" ref="acc72d4e9d073dd029032675fd7c7feb1" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_lognormal</b>
<li><a class="anchor" id="a2bc96895b91ff00eda42b36b31fe0df1"></a><!-- doxytag: member="types.h::apop_multinomial" ref="a2bc96895b91ff00eda42b36b31fe0df1" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_multinomial</b>
<li><a class="anchor" id="a6133f5f2ed5172c4a98e51bd17a18b23"></a><!-- doxytag: member="types.h::apop_multivariate_normal" ref="a6133f5f2ed5172c4a98e51bd17a18b23" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_multivariate_normal</b>
<li><a class="anchor" id="a74c3f0a4c9263e1f5e17c9ef873c8f02"></a><!-- doxytag: member="types.h::apop_normal" ref="a74c3f0a4c9263e1f5e17c9ef873c8f02" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_normal</b>
<li><a class="anchor" id="a7a3d6eb287feb7e22399fcfcf5d30d0d"></a><!-- doxytag: member="types.h::apop_ols" ref="a7a3d6eb287feb7e22399fcfcf5d30d0d" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_ols</b>
<li><a class="anchor" id="a3f90682cc2ba9b6f0f36b3ad4066b7c4"></a><!-- doxytag: member="types.h::apop_pmf" ref="a3f90682cc2ba9b6f0f36b3ad4066b7c4" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_pmf</b>
<li><a class="anchor" id="a695d628d5c038a6ba9f9b983c483c535"></a><!-- doxytag: member="types.h::apop_poisson" ref="a695d628d5c038a6ba9f9b983c483c535" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_poisson</b>
<li><a class="anchor" id="a0a2fe38172bbc4a70cbfd2077eb22dc4"></a><!-- doxytag: member="types.h::apop_probit" ref="a0a2fe38172bbc4a70cbfd2077eb22dc4" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_probit</b>
<li><a class="anchor" id="a04c08bcad3e882d38e92ad77f9296f43"></a><!-- doxytag: member="types.h::apop_t_distribution" ref="a04c08bcad3e882d38e92ad77f9296f43" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_t_distribution</b>
<li><a class="anchor" id="a6043cdfc7c38877cd1c1c9a46ae1b231"></a><!-- doxytag: member="types.h::apop_uniform" ref="a6043cdfc7c38877cd1c1c9a46ae1b231" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_uniform</b>
<li><a class="anchor" id="ae557aac3841d227b15beceb36e88b1aa"></a><!-- doxytag: member="types.h::apop_wishart" ref="ae557aac3841d227b15beceb36e88b1aa" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_wishart</b>
<li><a class="anchor" id="a17169ed9be0b026a496b8d16a11c87ea"></a><!-- doxytag: member="types.h::apop_wls" ref="a17169ed9be0b026a496b8d16a11c87ea" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_wls</b>
<li><a class="anchor" id="af67e6b37ea29a900a26a2c382d1f965b"></a><!-- doxytag: member="types.h::apop_yule" ref="af67e6b37ea29a900a26a2c382d1f965b" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_yule</b>
<li><a class="anchor" id="af238f568423aedb7e775a6ac259e820f"></a><!-- doxytag: member="types.h::apop_zipf" ref="af238f568423aedb7e775a6ac259e820f" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_zipf</b>
<li><a class="anchor" id="aeab707dc9e20143e26f6a89d0677af8f"></a><!-- doxytag: member="types.h::apop_coordinate_transform" ref="aeab707dc9e20143e26f6a89d0677af8f" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_coordinate_transform</b>
<li><a class="anchor" id="a618d4cbbb5b910f361766ecc99a0ffa0"></a><!-- doxytag: member="types.h::apop_composition" ref="a618d4cbbb5b910f361766ecc99a0ffa0" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_composition</b>
<li><a class="anchor" id="ae8babcd9877d0f4991ee2aca9316ca6e"></a><!-- doxytag: member="types.h::apop_dconstrain" ref="ae8babcd9877d0f4991ee2aca9316ca6e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_dconstrain</b>
<li><a class="anchor" id="ad86a3bbaf8312a5c8aa3e1c4dcc53d0d"></a><!-- doxytag: member="types.h::apop_mixture" ref="ad86a3bbaf8312a5c8aa3e1c4dcc53d0d" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_mixture</b>
<li><a class="anchor" id="aedb1edfba761f1c84ef9d449d5a10fbf"></a><!-- doxytag: member="types.h::apop_stack" ref="aedb1edfba761f1c84ef9d449d5a10fbf" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_stack</b>
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="aeca6159c82c21da0db82ae9ed0582dc6"></a><!-- doxytag: member="types.h::apop_data_add_names" ref="aeca6159c82c21da0db82ae9ed0582dc6" args="(dataset, type,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a list of names to a data set.</p>
<ul>
<li>Use this with a list of names that you type in yourself, like <div class="fragment"><pre class="fragment"><a class="code" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(mydata, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;age&quot;</span>, <span class="stringliteral">&quot;sex&quot;</span>, <span class="stringliteral">&quot;height&quot;</span>);
</pre></div> Notice the lack of curly braces around the list.</li>
</ul>
<ul>
<li>You may have an array of names, probably autogenerated, that you would like to add. In this case, make certain that the last element of the array is <code>NULL</code>, and call the base function: <div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> **[] colnames = {<span class="stringliteral">&quot;age&quot;</span>, <span class="stringliteral">&quot;sex&quot;</span>, <span class="stringliteral">&quot;height&quot;</span>, NULL};
apop_data_add_names_base(mydata, <span class="charliteral">&#39;c&#39;</span>, colnames);
</pre></div> If you forget the <code>NULL</code> marker, this has good odds of segfaulting. You may prefer to use a <code>for</code> loop that inserts each name in turn using <a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>.</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>, although <a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a> will be more useful in most cases. </dd></dl>

</div>
</div>
<a class="anchor" id="acb6b2c53478f9db902ba0340ba499819"></a><!-- doxytag: member="types.h::apop_data_falloc" ref="acb6b2c53478f9db902ba0340ba499819" args="(sizes,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sizes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> sizes, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a data set and fill it with values. Put the data set dimensions (one, two, or three dimensions as per <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>) in parens, then the data (as per <a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>). E.g.: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *identity2 = <a class="code" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2,2),
                         1, 0,
                         0, 1);

<a class="code" href="structapop__data.html">apop_data</a> *count_vector = <a class="code" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((5), 0, 1, 2, 3, 4);
</pre></div><p>If you forget the parens, you will get an obscure error during compilation.</p>
<ul>
<li>This is a pretty simple macro wrapping <a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a> and <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>, because they appear together so often. The second example expands to: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *count_vector = <a class="code" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(5), 0, 1, 2, 3, 4);
</pre></div> </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6be56d710a63aa1ceadf2242c553905"></a><!-- doxytag: member="types.h::apop_data_fill" ref="ad6be56d710a63aa1ceadf2242c553905" args="(adfin,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_fill_base((adfin), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a pre-allocated data set with values.</p>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="structapop__data.html">apop_data</a> *a =<a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
    <span class="keywordtype">double</span>    eight   = 8.0;
    <a class="code" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(a, 8, 2.2, eight/2,
                      0, 6.0, eight);
    <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(a);
}
</pre></div><p>Warning: I need as many arguments as the size of the data set, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your matrix with garbage or a simple segfault.</p>
<p>Underlying this function is a base function that takes a single list, as opposed to a set of unassociated numbers as above:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
  <a class="code" href="structapop__data.html">apop_data</a> *a =<a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
  <span class="keywordtype">double</span>    eight   = 8.0;
  <span class="keywordtype">double</span> list[] = {8, 2.2, eight/2, 
                   0, 6.0, eight};
    apop_data_fill_base(a, list);
    <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(a);
}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">adfin</td><td>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of at least as many floating-point values as there are blanks in the data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the same data set that was input.</dd></dl>
<ul>
<li>I assume that <code>vector-&gt;size==matrix-&gt;size1</code>; otherwise I just use <code>matrix-&gt;size1</code>.</li>
</ul>
<ul>
<li>See also <a class="el" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> to allocate and fill on one line. E.g., to generate a unit vector for three dimensions: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *unit_vector = <a class="code" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((3), 1, 1, 1);
</pre></div></li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>, <a class="el" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a459acfde11f2c39f5c32cff377f85b9e"></a><!-- doxytag: member="types.h::apop_data_free" ref="a459acfde11f2c39f5c32cff377f85b9e" args="(freeme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">freeme</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="types_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a>(freeme) ? 0 : ((freeme)= NULL))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free an <a class="el" href="gentle.html#apop_data">apop_data</a> structure.</p>
<p>As with <code>free()</code>, it is safe to send in a <code>NULL</code> pointer (in which case the function does nothing).</p>
<p>If the <code>more</code> pointer is not <code>NULL</code>, I will free the pointed-to data set first. If you don't want to free data sets down the chain, set <code>more=NULL</code> before calling this.</p>
<ul>
<li>This is actually a macro (that calls <a class="el" href="types_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> to do the real work). It sets <code>freeme</code> to <code>NULL</code> when it's done, because there's nothing safe you can do with the freed location, and you can later safely test conditions like <code>if (data) ...</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5ea849ee3c044e95eafb7b79124ce844"></a><!-- doxytag: member="types.h::apop_data_prune_columns" ref="a5ea849ee3c044e95eafb7b79124ce844" args="(in,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep only the columns of a data set that you name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">...</td><td>A list of names to retain (i.e. the columns that shouldn't be pruned out). For example, if you have run <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>, you have columns for several statistics, but may care about only one or two; see the example.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="comment">/* This sample produces a dummy times table, gets a summary, and prunes the summary table.</span>
<span class="comment">If you are not a test script, uncomment the last line to display the pruned table.  */</span>
<span class="keywordtype">int</span> main(){
    <span class="keywordtype">int</span> i, j;
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(0, 10, 4);
    <span class="keywordflow">for</span> (i=0; i&lt; 10; i++)
        <span class="keywordflow">for</span> (j=0; j&lt; 4; j++)
            <a class="code" href="group__data__set__get.html#ga1e7ba48032cb438271d57818b85613f2">apop_data_set</a>(d, i, j, i*j);
    <a class="code" href="structapop__data.html">apop_data</a> *summary = <a class="code" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>(d);
    <a class="code" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(summary, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);
    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;mean&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);
    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;median&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);
    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;max&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span>
    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;variance&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span>
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=0, .colname=<span class="stringliteral">&quot;mean&quot;</span>)==0);
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=1, .colname=<span class="stringliteral">&quot;median&quot;</span>)==4);
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=2, .colname=<span class="stringliteral">&quot;median&quot;</span>)==8);
    <span class="comment">//apop_data_show(summary);</span>
}
</pre></div><ul>
<li>I use a case-insensitive search to find your column. </li>
<li>If your name multiple columns, I'll only give you the first. </li>
<li>If I can't find a column matching one of your strings, I throw an error to the screen and continue. </li>
<li>This is a macro calling <a class="el" href="types_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>. It packages your list of columns into a list of strings, adds a <code>NULL</code> string at the end, and calls that function. </li>
</ul>

</div>
</div>
<a class="anchor" id="abbdfc523f5b269827db8cebf28216e28"></a><!-- doxytag: member="types.h::apop_gaussian" ref="abbdfc523f5b269827db8cebf28216e28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#abbdfc523f5b269827db8cebf28216e28">apop_gaussian</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alias for the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> distribution, qv. </p>

</div>
</div>
<a class="anchor" id="a15d9e73643bf66f7d69c7ebf959757aa"></a><!-- doxytag: member="types.h::apop_model_coordinate_transform" ref="a15d9e73643bf66f7d69c7ebf959757aa" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a15d9e73643bf66f7d69c7ebf959757aa">apop_model_coordinate_transform</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a>, apop_ct, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build an <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> model, qv.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__ct__settings.html">apop_ct_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab664f68b5e481bec56c8ddc7f16928c0"></a><!-- doxytag: member="types.h::apop_model_dcompose" ref="ab664f68b5e481bec56c8ddc7f16928c0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#ab664f68b5e481bec56c8ddc7f16928c0">apop_model_dcompose</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(apop_composition, apop_composition, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Data composition</em> is using either random draws or parameter estimates from the output of one model as the input data for another model.</p>
<ul>
<li>The <a class="el" href="group__models.html#gaedd07c678027bea683f48aa8617c4b89">apop_dcomposition</a> model relies on the <a class="el" href="structapop__composition__settings.html">apop_composition_settings</a> struct, qv. This macro takes the elements of that struct as input. You can use the designated initializer syntax to specify them.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of the <code>apop_composition</code> model. </dd></dl>

</div>
</div>
<a class="anchor" id="a34644b9d55c7528b47f0b887c9241928"></a><!-- doxytag: member="types.h::apop_model_dconstrain" ref="a34644b9d55c7528b47f0b887c9241928" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a34644b9d55c7528b47f0b887c9241928">apop_model_dconstrain</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build an <code>apop_dconstrain</code> model, q.v., which applies a data constraint to the data set. For example, this is how one would truncate a model to have data above zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__dconstrain__settings.html">apop_dconstrain_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a40bb98b02fde8f8e4ab59a4d127b692f"></a><!-- doxytag: member="types.h::apop_model_mixture" ref="a40bb98b02fde8f8e4ab59a4d127b692f" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;apop_model_mixture_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a model as a linear combination of other models. See the documentation for the <a class="el" href="group__models.html#gaf085564a8adc67ba156c4cd1db8145e3">apop_mixture</a> model. </p>

</div>
</div>
<a class="anchor" id="ad0e4b98a3edb53646ff9b036cfb558a0"></a><!-- doxytag: member="types.h::apop_model_stack" ref="ad0e4b98a3edb53646ff9b036cfb558a0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;apop_model_stack_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a model consisting of several models bound together. The output <a class="el" href="structapop__model.html">apop_model</a> is a copy of <a class="el" href="group__models.html#gaf4fa26b04f324b9895b7599e323203df">apop_stack</a>; see that model's documentation for details.</p>
<p>Sample use:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structapop__model.html">apop_model</a> *m1 = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1);
    <a class="code" href="structapop__model.html">apop_model</a> *m2 = <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(m1);
    <a class="code" href="structapop__model.html">apop_model</a> *m3 = <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(m1);
    <a class="code" href="structapop__model.html">apop_model</a> *two_independent_normals = <a class="code" href="types_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(n1, n2);
    <a class="code" href="structapop__model.html">apop_model</a> *three_independent_normals = <a class="code" href="types_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(n1, n2, n3);

    <span class="comment">//But you don&#39;t have to parameterize ahead of time. E.g.</span>
    <a class="code" href="structapop__model.html">apop_model</a> *two_n = <a class="code" href="types_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(
                    <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>),
                    <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>)
                    );
    <a class="code" href="structapop__model.html">apop_model</a> *estimated_norms = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(indata, two_n);
</pre></div><ul>
<li>If you input only one model, return a copy of that model; print a warning iff <code>apop_opts.verbose &gt;= 1</code>. <dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">error=='n'</td><td>First model input is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a74dca50ea16ed7bf25cb152315642769"></a><!-- doxytag: member="types.h::apop_text_fill" ref="a74dca50ea16ed7bf25cb152315642769" args="(dataset,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_text_fill_base((dataset), (char* []) {__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the text part of an already-allocated <a class="el" href="gentle.html#apop_data">apop_data</a> set with a list of strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>A data set that you already prepared with <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>. </td></tr>
    <tr><td class="paramname">...</td><td>A list of strings. The first row is filled first, then the second, and so on to the end of the text grid.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>No <code>NULL</code> strings. A blank string, <code>""</code> is OK. </li>
<li>If you provide more or fewer strings than are needed to fill the text grid and <code>apop_opts.verbose &gt;=1</code>, I print a warning and continue to the end of the text grid or data set, whichever is shorter. </li>
<li>If the data set is <code>NULL</code>, I return <code>NULL</code>. If you provide a <code>NULL</code> data set but a non-NULL list of text elements, and <code>apop_opts.verbose &gt;=1</code>, I print a warning and return <code>NULL</code>. </li>
<li>Remember that the C preprocessor concatenates two adjacent strings into one. Here is an attempt to fill a <img class="formulaInl" alt="$ 2\times 3$" src="form_5.png"/> grid: <div class="fragment"><pre class="fragment">  <a class="code" href="structapop__data.html">apop_data</a> *one23 = <a class="code" href="types_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(<a class="code" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 2, 3),
                                     <span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;three&quot;</span>   <span class="comment">//missing comma!</span>
                                     <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;four&quot;</span>, <span class="stringliteral">&quot;six&quot;</span>);
</pre></div> The preprocessor will join <code>"three" "two"</code> to form <code>"threetwo"</code>, leaving you with only five strings.</li>
</ul>
<ul>
<li>If you have a <code>NULL-delimited</code> array of strings (not just a loose list as above), then use <code>apop_text_fill_base</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="af9b051e2fbe0e473dddeabfe4932ce0c"></a><!-- doxytag: member="types.h::apop_vector_fill" ref="af9b051e2fbe0e473dddeabfe4932ce0c" args="(avfin,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="types_8h.html#af9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">avfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_vector_fill_base((avfin), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a pre-allocated <code>gsl_vector</code> with values.</p>
<p>See <code>apop_data_alloc</code> for a relevant example. See also <code>apop_matrix_alloc</code>.</p>
<p>Warning: I need as many arguments as the size of the vector, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your vector with garbage or a simple segfault.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">avfin</td><td>A <code>gsl_vector</code> (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of exactly as many values as there are spaces in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the same vector that was input. </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0c8c2a99fb8c6ec54822aca08591545e"></a><!-- doxytag: member="types.h::apop_data" ref="a0c8c2a99fb8c6ec54822aca08591545e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__data.html">apop_data</a>  <a class="el" href="structapop__data.html">apop_data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure represents a data set. It primarily joins together a gsl_vector, a gsl_matrix, and a table of strings, then gives them all row and column names. It tries to be minimally intrusive, so you can use it everywhere you would use a <code>gsl_matrix</code> or a <code>gsl_vector</code>.</p>
<p>If you are viewing the HTML documentation, here is a diagram showing a sample data set with all of the elements in place. Together, they represet a data set where each row is an observation, which includes both numeric and text values, and where each row/column is named.</p>
<table frame=box>
<tr>
<td>Rowname</td><td>Vector</td><td> Matrix</td><td> Text</td><td>Weights</td>
</tr><tr valign=bottom>
<td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>"Steven"</td>
</tr><tr>
<td>"Sandra"</td>
</tr><tr>
<td>"Joe"</td><td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th>Outcome</th>
</tr> <tr>
<td align=center>1</td>
</tr><tr>
<td align=center>0</td>
</tr><tr>
<td align=center>1</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Age</th><th> Weight (kg)</th><th> Height (cm)</th>
</tr> <tr>
<td> 32</td><td> 65</td><td> 175</td>
</tr><tr>
<td> 41</td><td> 61</td><td> 165</td>
</tr><tr>
<td> 40</td><td> 73</td><td> 181</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Sex</th><th> State</th>
</tr>
<tr>
<td> Male</td><td> Alaska</td><td>
</tr><tr>
<td> Female</td><td> Alabama</td>
</tr><tr>
<td> Male</td><td> Alabama</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>1</td>
</tr><tr>
<td>3.2</td>
</tr><tr>
<td>2.4</td>
</tr> 
</table>
</td></tr>
</table>
<p>Allocate using <code>apop_data_alloc</code>, free via <code>apop_data_free</code>, or more generally, see the <code>apop_data_</code>... section of the index (in the header links) for the many other functions that operate on this struct.</p>
<p>See also the Data Sets section of the outline page (also in the header links) for further notes on getting and manipulating the elements of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. </p>

</div>
</div>
<a class="anchor" id="afe86ae10fc82d219906211e4f88e4cf9"></a><!-- doxytag: member="types.h::apop_model" ref="afe86ae10fc82d219906211e4f88e4cf9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="structapop__model.html">apop_model</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A statistical model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a69adca14afc66100168f585e05b59dcb"></a><!-- doxytag: member="types.h::apop_beta_from_mean_var" ref="a69adca14afc66100168f585e05b59dcb" args="(double m, double v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="types_8h.html#a69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The Beta distribution is useful for modeling because it is bounded between zero and one, and can be either unimodal (if the variance is low) or bimodal (if the variance is high), and can have either a slant toward the bottom or top of the range (depending on the mean).</p>
<p>The distribution has two parameters, typically named <img class="formulaInl" alt="$\alpha$" src="form_1.png"/> and <img class="formulaInl" alt="$\beta$" src="form_2.png"/>, which can be difficult to interpret. However, there is a one-to-one mapping between (alpha, beta) pairs and (mean, variance) pairs. Since we have good intuition about the meaning of means and variances, this function takes in a mean and variance, calculates alpha and beta behind the scenes, and returns a random draw from the appropriate Beta distribution.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mean the Beta distribution should have. Notice that m is in [0,1].</td></tr>
    <tr><td class="paramname">v</td><td>The variance which the Beta distribution should have. It is in (0, 1/12), where (1/12) is the variance of a Uniform(0,1) distribution. Funny things happen with variance near 1/12 and mean far from 1/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns an <code>apop_beta</code> model with its parameters appropriately set. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='r'</td><td>Range error: mean is not within [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee8c299b83b8500b8b6ecd30817353c8"></a><!-- doxytag: member="types.h::apop_crosstab_to_db" ref="aee8c299b83b8500b8b6ecd30817353c8" args="(apop_data *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>row_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>col_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See <a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> for the storyline; this is the complement, which takes a crosstab and writes its values to the database.</p>
<p>For example, I would take </p>
<table  frame="box">
<tr>
<td></td><td>c0</td><td>c1 </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>r0</td><td>2</td><td>3 </td></tr>
<tr>
<td>r1</td><td>0</td><td>4 </td></tr>
</table>
<p>and do the following writes to the database:</p>
<div class="fragment"><pre class="fragment">insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 2);
insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 4);
</pre></div><ul>
<li>If your data set does not have names (or not enough names), I will use the scheme above, filling in names of the form <code>r0</code>, <code>r1</code>, ... <code>c0</code>, <code>c1</code>, .... Text columns get their own numbering system, <code>t0</code>, <code>t1</code>, ..., which is a little more robust than continuing the column count from the matrix.</li>
</ul>
<ul>
<li>I handle only the matrix and text. </li>
</ul>

</div>
</div>
<a class="anchor" id="a44b767b375fb18f61f939c6869955331"></a><!-- doxytag: member="types.h::apop_data_add_named_elmt" ref="a44b767b375fb18f61f939c6869955331" args="(apop_data *d, char *name, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to add a named element to a data set. Many of Apophenia's testing procedures use this to easily produce a column of named parameters. It is public as a convenience.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure. Must not be <code>NULL</code>, but may be blank (as per allocation via <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> <code>( )</code> ). </td></tr>
    <tr><td class="paramname">name</td><td>The name to add </td></tr>
    <tr><td class="paramname">val</td><td>the value to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>I use the position of the last non-empty row name to know where to put the value. If there are two names in the data set, then I will put the new name in the third name slot and the data in the third slot in the vector. If you use this function from start to finish in building your list, then you'll be fine. </li>
<li>If the vector is too short (or <code>NULL</code>), I will call <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> internally to make space. </li>
<li>This fits well with the defaults for <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>. An example:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>();
<a class="code" href="apop__data_8c.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;height&quot;</span>, 165);
<a class="code" href="apop__data_8c.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;weight&quot;</span>, 60);

<span class="keywordtype">double</span> height = <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(list, .rowname=<span class="stringliteral">&quot;height&quot;</span>);
</pre></div> 
</div>
</div>
<a class="anchor" id="a7e7e530a692571a403e5837fda5e0f12"></a><!-- doxytag: member="types.h::apop_data_add_page" ref="a7e7e530a692571a403e5837fda5e0f12" args="(apop_data *dataset, apop_data *newpage, const char *title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>newpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a page to a <a class="el" href="gentle.html#apop_data">apop_data</a> set. It gets a name so you can find it later.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>The input data set, to which a page will be added. </td></tr>
    <tr><td class="paramname">newpage</td><td>The page to append </td></tr>
    <tr><td class="paramname">title</td><td>The name of the new page. Remember, this is truncated at 100 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new page. I post a warning if I am appending or appending to a <code>NULL</code> data set and <code>apop_opts.verbose &gt;=1 </code>.</dd></dl>
<ul>
<li>Some data is fundamentally multi-page; an optimization search over multi-page parameters would search the space given by all pages, for example. Also, pages may be appended as output or auxiliary information, such as covariances---an MLE would not search over these elements. Generally, any page with a name in XML-ish brackets, such as <code>&lt;Covariance&gt;</code>, will be considered informational and ignored by search routines, missing data routines, et cetera. This is achieved by a rule in <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> and <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a>.</li>
</ul>
<p>Here is a toy example that establishes a baseline data set, adds a page, modifies it, and then later retrieves it. </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(10, 10, 10); <span class="comment">//the base data set.</span>
  <a class="code" href="structapop__data.html">apop_data</a> *a_new_page = <a class="code" href="apop__data_8c.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a>(d, <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2), <span class="stringliteral">&quot;new 2 x 2 page&quot;</span>);
  gsl_vector_set_all(a_new_page-&gt;matrix, 3);

  <span class="comment">//later:</span>
  <a class="code" href="structapop__data.html">apop_data</a> *retrieved = <a class="code" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(d, <span class="stringliteral">&quot;new&quot;</span>, <span class="charliteral">&#39;r&#39;</span>); <span class="comment">//use regexes, not literal match.</span>
  <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(retrieved); <span class="comment">//print a 2x2 grid of 3s.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ac39d6a56933b6f084328ec5ecd5090d8"></a><!-- doxytag: member="types.h::apop_data_alloc" ref="ac39d6a56933b6f084328ec5ecd5090d8" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data.</p>
<ul>
<li>The typical case is three arguments, like <code>apop_data_alloc(2,3,4)</code>: vector size, matrix rows, matrix cols. If the first argument is zero, you get a <code>NULL</code> vector. </li>
<li>Two arguments, <code>apop_data_alloc(2,3)</code>, would allocate just a matrix, leaving the vector <code>NULL</code>. </li>
<li>One argument, <code>apop_data_alloc(2)</code>, would allocate just a vector, leaving the matrix <code>NULL</code>. </li>
<li>Zero arguments, <code><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, will produce a basically blank set, with <code>out-&gt;matrix==out-&gt;vector==NULL</code>.</li>
</ul>
<p>For allocating the text part, see <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>.</p>
<p>The <code>weights</code> vector is set to <code>NULL</code>. If you need it, allocate it via </p>
<div class="fragment"><pre class="fragment"> d-&gt;weights   = gsl_vector_alloc(row_ct); 
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and ready. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. The matrix, vector, or names couldn't be <code>malloc</code>ed, which probably means that you requested a very large data set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An <a class="el" href="gentle.html#apop_data">apop_data</a> struct, by itself, is about 72 bytes. If I can't allocate that much memory, I return <code>NULL</code>. But if even this much fails, your computer may be on fire and you should go put it out.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0460790f2d21f03856ed4a212a4132ec"></a><!-- doxytag: member="types.h::apop_data_calloc" ref="a0460790f2d21f03856ed4a212a4132ec" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data; set everything in the allocated portion to zero. See <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> for details.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and zeroed out. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>malloc error; probably out of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a></dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="add67e6838ce2521a1d756894dc9b5ccf"></a><!-- doxytag: member="types.h::apop_data_copy" ref="add67e6838ce2521a1d756894dc9b5ccf" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data is duplicated.</p>
<p>Basically a front-end for <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> for those who prefer this sort of syntax.</p>
<p>Unlike <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>, I do follow the <code>more</code> pointer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill. If input is NULL, then this will be NULL.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out.error='c'</td><td>Cyclic link: <code>D-&gt;more == D</code> (may be later in the chain, e.g., <code>D-&gt;more-&gt;more = D-&gt;more</code>) You'll have only a partial copy. </td></tr>
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; should never happen. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Missing part error; should never happen. <ul>
<li>If the input data set has an error, then I will copy it anyway, including the error flag (which might be overwritten). I print a warning if the verbosity level is <code>&gt;=1</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8377359d46c9bd02ea57205e7968d3"></a><!-- doxytag: member="types.h::apop_data_free_base" ref="a3e8377359d46c9bd02ea57205e7968d3" args="(apop_data *freeme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="types_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>freeme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free the elements of the given <a class="el" href="gentle.html#apop_data">apop_data</a> set and then the <a class="el" href="gentle.html#apop_data">apop_data</a> set itself. Intended to be used by <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>, a macro that calls this to free elements, then sets the value to <code>NULL</code>.</p>
<ul>
<li><a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> is a macro that calls this function and, on success, sets the input pointer to <code>NULL</code>. For typical cases, that's slightly more useful than this function.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">freeme.error='c'</td><td>Circular linking is against the rules. If <code>freeme-&gt;more == freeme</code>, then I set <code>freeme.error='c'</code> and return. If you send in a structure like A -&gt; B -&gt; B, then both data sets A and B will be marked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0</code> on OK, <code>'c'</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a044771db76f0afb410a8d4f05ac51ca3"></a><!-- doxytag: member="types.h::apop_data_get_page" ref="a044771db76f0afb410a8d4f05ac51ca3" args="(const apop_data *data, const char *title, const char match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's good form to get a page from your data set by name, because you may not know the order for the pages, and the stepping through makes for dull code anyway (<code><a class="el" href="structapop__data.html">apop_data</a> *page = dataset; while (page-&gt;more) page= page-&gt;more;</code>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use. No default; if <code>NULL</code>, gives a warning if <code>apop_opts.verbose &gt;=1</code> and returns <code>NULL</code>.</td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to retrieve. Default=<code>"Info"</code>, which is the name of the page of additional estimation information returned by estimation routines (log likelihood, status, AIC, BIC, confidence intervals, ...).</td></tr>
    <tr><td class="paramname">match</td><td>If <code>'c'</code>, case-insensitive match (via <code>strcasecmp</code>); if <code>'e'</code>, exact match, if <code>'r'</code> regular expression substring search (via <a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>). Default=<code>'c'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The page whose title matches what you gave me. If I don't find a match, return <code>NULL</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa24d396c7fda38bc4ab03a3ba2db4943"></a><!-- doxytag: member="types.h::apop_data_memcpy" ref="aa24d396c7fda38bc4ab03a3ba2db4943" args="(apop_data *out, const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data on the first page is duplicated. [To do multiple pages, call this via a <code>for</code> loop over the data set's pages.]</p>
<p>This function does not allocate the output structure or the vector, matrix, text, or weights elements---I assume you have already done this and got the dimensions right. I will assert that there is at least enough room in the destination for your data, and fail if the copy would write more elements than there are bins.</p>
<ul>
<li>If you want space allocated, use <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>. </li>
<li>I don't follow the <code>more</code> pointer, though <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> does. </li>
<li>You can use the subsetting macros, <a class="el" href="stats_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> or <a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows</a>, to copy within a data set:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">//Copy the contents of row i of mydata to row j.</span>
<a class="code" href="stats_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, i, fromrow);
<a class="code" href="stats_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, j, torow);
<a class="code" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>(torow, fromrow);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>a structure that this function will fill. Must be preallocated with the appropriate sizes. </td></tr>
    <tr><td class="paramname">in</td><td>the input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; couldn't copy. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Part missing; e.g., in-&gt;matrix exists but out-&gt;matrix doesn't; couldn't copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1efbe058d6ca85ece023eb471c66e58"></a><!-- doxytag: member="types.h::apop_data_prune_columns_base" ref="ad1efbe058d6ca85ece023eb471c66e58" args="(apop_data *d, char **colnames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>colnames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep only the columns of a data set that you name. This is the function called internally by the <a class="el" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> macro. In most cases, you'll want to use that macro. An example of the two uses demonstrating the difference:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(d, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);

    <span class="keywordtype">char</span> *list[] = {<span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>, NULL};
    <a class="code" href="apop__data_8c.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>(d, list);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">colnames</td><td>A null-terminated list of names to retain (i.e. the columns that shouldn't be pruned out). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the input data set, now pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c4bb25171301f09a35c36306a7b9783"></a><!-- doxytag: member="types.h::apop_data_rank_compress" ref="a8c4bb25171301f09a35c36306a7b9783" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>One often finds data where the column indicates the value of the data point. There may be two columns, and a mark in the first indicates a miss while a mark in the second is a hit. Or say that we have the following list of observations:</p>
<div class="fragment"><pre class="fragment">2 3 3 2 1 1 2 1 1 2 1 1
</pre></div><p> Then we could write this as: </p>
<div class="fragment"><pre class="fragment">0  1  2  3
----------
0  6  4  2
</pre></div><p> because there are six 1s observed, four 2s observed, and two 3s observed. We call this rank format, because 1 (or zero) is typically the most common, 2 is second most common, et cetera.</p>
<p>This function takes in a list of observations, and aggregates them into a single row in rank format.</p>
<ul>
<li>For the complement, see <a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>.</li>
</ul>
<ul>
<li>You may be interested in <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> to convert real numbers or text into a matrix of categories.</li>
</ul>
<ul>
<li>The number of bins is simply the largest number found. So if there are bins {0, 1, 2} and your data set happens to consist of <code>0 0 1 1 0</code>, then I won't know to generate results with three bins where the last bin has probability zero.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">/* A round trip: generate Zipf-distributed draws, summarize them to a single list of</span>
<span class="comment">rankings, then expand the rankings to a list of single entries. The sorted list at the end</span>
<span class="comment">of this should be identical to the (sorted) original list. */</span>
<span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
    gsl_rng *r = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(2342);
    <span class="keywordtype">int</span> i, length = 1e4;
    <a class="code" href="structapop__model.html">apop_model</a> *a_zipf = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, 3.2);
    <a class="code" href="structapop__data.html">apop_data</a> *draws = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(length);
    <span class="keywordflow">for</span> (i=0; i&lt; length; i++)
        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a>(draws, i, -1), r, a_zipf);
    <a class="code" href="structapop__data.html">apop_data</a> *by_rankings = <a class="code" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>(draws);
    <span class="comment">//The first row of the matrix is suitable for plotting.</span>
    <span class="comment">//apop_data_show(by_rankings);</span>
    assert(<a class="code" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a>(by_rankings-&gt;matrix) == length);

    <a class="code" href="structapop__data.html">apop_data</a> *re_expanded = <a class="code" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>(by_rankings);
    gsl_sort_vector(draws-&gt;vector);
    gsl_sort_vector(re_expanded-&gt;vector);
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(draws-&gt;vector, re_expanded-&gt;vector) &lt; 1e-5);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a2feb17743f8b07b8ddcf457362cabefc"></a><!-- doxytag: member="types.h::apop_data_rank_expand" ref="a2feb17743f8b07b8ddcf457362cabefc" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The complement to this is <a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>; see that function's documentation for the story and an example.</p>
<p>This function takes in a data set where the zeroth column includes the count(s) of times that zero was observed, the first gives the count(s) of times that one was observed, et cetera. It outputs a data set whose vector element includes a list that has exactly the given frequency of zeros, ones, et cetera. </p>

</div>
</div>
<a class="anchor" id="ac434c9d08b6a8304107d9c93afb81914"></a><!-- doxytag: member="types.h::apop_data_rm_page" ref="ac434c9d08b6a8304107d9c93afb81914" args="(apop_data *data, const char *title, const char free_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>free_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first page from an <a class="el" href="gentle.html#apop_data">apop_data</a> set that matches a given name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data set, to which a page will be added. No default. If <code>NULL</code>, I return silently if <code> apop_opts.verbose &lt; 1 </code>; print an error otherwise. </td></tr>
    <tr><td class="paramname">title</td><td>The case-insensitive name of the page to remove. Default: <code>"Info"</code> </td></tr>
    <tr><td class="paramname">free_p</td><td>If <code>'y'</code>, then <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> the page. Default: <code>'y'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If not freed, a pointer to the <code><a class="el" href="structapop__data.html">apop_data</a></code> page that I just pulled out. Thus, you can use this to pull a single page from a data set. I set that page's <code>more</code> pointer to <code>NULL</code>, to minimize any confusion about more-than-linear linked list topologies. If <code>free_p=='y'</code> (the default) or the page is not found, return <code>NULL</code>.</dd></dl>
<ul>
<li>I don't check the first page, so there's no concern that the head of your list of pages will move. Again, the intent of the <code>-&gt;more</code> pointer in the <a class="el" href="gentle.html#apop_data">apop_data</a> set is not to fully implement a linked list, but primarily to allow you to staple auxiliary information to a main data set.</li>
</ul>
<ul>
<li>If I don't find the page you want, I return NULL, and print a message if <code>apop_opts.verbose &gt;= 1</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae2ab3a4f332adb368fe970619a8c0252"></a><!-- doxytag: member="types.h::apop_data_rm_rows" ref="ae2ab3a4f332adb368fe970619a8c0252" args="(apop_data *in, int *drop, int(*do_drop)(apop_data *, void *), void *drop_parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ir&#160;</td>
          <td class="paramname"><em>do_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drop_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the rows set to one in the <code>drop</code> vector or for which the <code>do_drop</code> function returns one. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down </td></tr>
    <tr><td class="paramname">drop</td><td>a vector with as many elements as the max of the vector, matrix, or text parts of <code>in</code>, with a one marking those columns to be removed. </td></tr>
    <tr><td class="paramname">do_drop</td><td>A function that returns one for rows to drop and zero for rows to not drop. A sample function: <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> your_drop_function(<a class="code" href="structapop__data.html">apop_data</a> *onerow, <span class="keywordtype">void</span> *extra_param){
    <span class="keywordflow">return</span> gsl_isnan(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(onerow)) || !strcmp(onerow-&gt;text[0][0], <span class="stringliteral">&quot;Uninteresting data point&quot;</span>);
  }
</pre></div> <a class="el" href="types_8h.html#ae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> uses <a class="el" href="stats_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to get a subview of the input data set of height one (and since all the default arguments default to zero, you don't have to write out things like <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a> <code>(onerow, .row=0, .col=0)</code>, which can help to keep things readable). </td></tr>
    <tr><td class="paramname">drop_parameter</td><td>If your <code>do_drop</code> function requires additional input, put it here and it will be passed through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the input data set, now pruned.</dd></dl>
<ul>
<li>If all the rows are to be removed, then you will wind up with the same <a class="el" href="gentle.html#apop_data">apop_data</a> set, with <code>NULL</code> <code>vector</code>, <code>matrix</code>, <code>weight</code>, and text. Therefore, you may wish to check for <code>NULL</code> elements after use. I remove rownames, but leave the other names, in case you want to add new data rows.</li>
</ul>
<ul>
<li>The typical use is to provide only a list or only a function. If both are <code>NULL</code>, I return without doing anything, and print a warning if <code>apop_opts.verbose &gt;=1</code>. If you provide both, I will drop the row if either the vector has a one in that row's position, or if the function returns a nonzero value. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a47313d1f22af539e43f5ff02dd0e8f90"></a><!-- doxytag: member="types.h::apop_data_set_row" ref="a47313d1f22af539e43f5ff02dd0e8f90" args="(apop_data *row, apop_data *d, int row_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="types_8h.html#a47313d1f22af539e43f5ff02dd0e8f90">apop_data_set_row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Now that you've used <a class="el" href="stats_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to pull a row from an <a class="el" href="gentle.html#apop_data">apop_data</a> set, this function lets you write that row to another position in the same data set or a different data set entirely.</p>
<p>The set written to must have the same form as the original: </p>
<ul>
<li>a vector element has to be present if one existed in the original, </li>
<li>same for the weights vector, </li>
<li>the matrix in the destination has to have as many columns as in the original, and </li>
<li>the text has to have a row long enough to hold the original </li>
<li>If the row to be written to already has a rowname, it is overwritten. If <code>d-&gt;names-&gt;rowct == row_number</code> (all rows up to <code>row_number</code> have row names), then extend the list of row names by one to add the new name. Else, don't add the row name. </li>
<li>Column names (of all types) aren't touched. Maybe use <code>apop_data_copy</code> or <code>apop_name_copy</code> if you need to copy these names.</li>
</ul>
<p>If any of the source elements are <code>NULL</code>, I won't bother to check that element in the destination.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably a source/destination size mismatch).</dd></dl>
<ul>
<li>The error codes for out-of-bounds errors are thread-safe iff you are have a C11-compliant compiler (thanks to the <code>_Thread_local</code> keyword) or a version of GCC with the <code>__thread</code> extension enabled. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef0284036801cb75d465a1738f65397e"></a><!-- doxytag: member="types.h::apop_data_split" ref="aef0284036801cb75d465a1738f65397e" args="(apop_data *in, int splitpoint, char r_or_c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>** <a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>r_or_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Split one input <a class="el" href="gentle.html#apop_data">apop_data</a> structure into two.</p>
<p>For the opposite operation, see <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to split </td></tr>
    <tr><td class="paramname">splitpoint</td><td>The index of what will be the first row/column of the second data set. E.g., if this is -1 and <code>r_or_c=='c'</code>, then the whole data set will be in the second data set; if this is the length of the matrix then the whole data set will be in the first data set. Another way to put it is that <code>splitpoint</code> will equal the number of rows/columns in the first matrix (unless it is -1, in which case the first matrix will have zero rows, or it is greater than the matrix's size, in which case it will have as many rows as the original). </td></tr>
    <tr><td class="paramname">r_or_c</td><td>If this is 'r' or 'R', then put some rows in the first data set and some in the second; of 'c' or 'C', split columns into first and second data sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of two <a class="el" href="gentle.html#apop_data">apop_data</a> sets. If one is empty then a <code>NULL</code> pointer will be returned in that position. For example, for a data set of 50 rows, <code><a class="el" href="structapop__data.html">apop_data</a> **out = apop_data_split(data, 100, 'r')</code> sets <code>out[0] = apop_data_copy(data)</code> and <code>out[1] = NULL</code>.</dd></dl>
<ul>
<li>When splitting at a row, the text is also split. </li>
<li><code>more</code> pointer is ignored. </li>
<li>The <code>apop_data-&gt;vector</code> is taken to be the -1st element of the matrix. </li>
<li>Weights will be preserved. If splitting by rows, then the top and bottom parts of the weights vector will be assigned to the top and bottom parts of the main data set. If splitting by columns, identical copies of the weights vector will be assigned to both parts. </li>
<li>Data is copied, so you may want to call <code><a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free(in)</a></code> after this. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2ffb5c5ba2bb240e930be08fc4fd56"></a><!-- doxytag: member="types.h::apop_data_stack" ref="a0f2ffb5c5ba2bb240e930be08fc4fd56" args="(apop_data *m1, apop_data *m2, char posn, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first data set either on top of or to the left of the second data set.</p>
<p>The fn returns a new data set, meaning that at the end of this function, until you <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free()</a> the original data sets, you will be taking up twice as much memory. Plan accordingly.</p>
<p>For the opposite operation, see <a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">posn</td><td>If 'r', stack rows of m1's matrix above rows of m2's<br/>
 if 'c', stack columns of m1's matrix to left of m2's<br/>
 (default = 'r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code> or 1, use <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> and <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>m1</code> in place; see the caveats on those function. Otherwise, allocate a new vector, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stacked data, either in a new <a class="el" href="gentle.html#apop_data">apop_data</a> set or <code>m1</code> </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Dimension error; couldn't make a complete copy.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If m1 or m2 are NULL, this returns a copy of the other element, and if both are NULL, you get NULL back (except if <code>m2</code> is <code>NULL</code> and <code>inplace</code> is <code>'y'</code>, where you'll get the original <code>m1</code> pointer back) </li>
<li>Text is handled as you'd expect: If 'r', one set of text is stacked on top of the other [number of columns must match]; if 'c', one set of text is set next to the other [number of rows must match]. </li>
<li><code>more</code> is ignored. </li>
<li>If stacking rows on rows, the output vector is the input vectors stacked accordingly. If stacking columns by columns, the output vector is just a copy of the vector of m1 and m2-&gt;vector doesn't appear in the output at all. </li>
<li>The same rules for dealing with the vector(s) hold for the vector(s) of weights. </li>
<li>Names are a copy of the names for <code>m1</code>, with the names for <code>m2</code> appended to the row or column list, as appropriate. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a06f38caecb66ec90b18b406b15068381"></a><!-- doxytag: member="types.h::apop_data_transpose" ref="a06f38caecb66ec90b18b406b15068381" args="(apop_data const *in, char transpose_text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a06f38caecb66ec90b18b406b15068381">apop_data_transpose</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transpose_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a copy of the input set where the matrix and text elements are transposed, including the row/column names. The vector and weights elements of the input data set are completely ignored (but see also <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>, which can convert a vector to a 1 X N matrix.)</p>
<p>This is mostly just a friendly wrapper for <code>gsl_matrix_transpose_memcpy</code>; if you have a <code>gsl_matrix</code> with no names or text, you may prefer to just use that function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. If <code>NULL</code>, I return <code>NULL</code>. Default is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">transpose_text</td><td>If <code>'y'</code>, then also transpose the text element. Default is <code>'y'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly alloced <a class="el" href="gentle.html#apop_data">apop_data</a> set, with the appropriately transposed matrix and/or text. The vector and weights elements will be <code>NULL</code>. If <code>transpose_text='n'</code>, then the text element of the output set will also be <code>NULL</code>.</dd></dl>
<ul>
<li>Row names are written to column names of the output matrix, text, or both (whichever is not empty in the input). </li>
<li>If only the matrix or only the text have names, then the one set of names is written to the row names of the output. </li>
<li>If both matrix column names and text column names are present, text column names are lost.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="aebe17fe6f2b0c49c0c90824b7a68ff90"></a><!-- doxytag: member="types.h::apop_db_to_crosstab" ref="aebe17fe6f2b0c49c0c90824b7a68ff90" args="(char *tabname, char *r1, char *r2, char *datacol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datacol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give the name of a table in the database, and names of three of its columns: the x-dimension, the y-dimension, and the data. the output is a 2D matrix with rows indexed by r1 and cols by r2.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tabname</td><td>The database table I'm querying. Anything that will work inside a <code>from</code> clause is OK, such as a subquery in parens. </td></tr>
    <tr><td class="paramname">r1</td><td>The column of the data set that will indicate the rows of the output crosstab </td></tr>
    <tr><td class="paramname">r2</td><td>The column of the data set that will indicate the columns of the output crosstab </td></tr>
    <tr><td class="paramname">datacol</td><td>The column of the data set holding the data for the cells of the crosstab</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the query to get data to fill the table (select r1, r2, datacol from tabname) returns an empty data set, then I will return a <code>NULL</code> data set and if <code>apop_opts.verbosity &gt;= 1</code> print a warning.</li>
</ul>
<ul>
<li>This setup presumes that there is one value for each (row, col) coordinate in the data. You may want an aggregate instead. There are two ways to do this, both of which hack the fact that this function runs a simple <code>select</code> query to generate the data. One is to specify an ad hoc table to pull from:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> * out = <a class="code" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;(select row, col, count(*) ct from base_data group by row, col)&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>,  <span class="stringliteral">&quot;ct&quot;</span>);
</pre></div><p>The other is to use the fact that the table name will be at the end of the query, so you can add conditions to the table:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> * out = <a class="code" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;base_data group by row, col&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>, <span class="stringliteral">&quot;count(*)&quot;</span>);
<span class="comment">//which will expand to &quot;select row, col, count(*) from base_data group by row, col&quot;</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a></dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='n'</td><td>Name not found error. </td></tr>
    <tr><td class="paramname">out-&gt;error='q'</td><td>Query returned an empty table (which might mean that it just failed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa06b6ab6ec9f78f305b1dacc8ec2efd3"></a><!-- doxytag: member="types.h::apop_matrix_realloc" ref="aa06b6ab6ec9f78f305b1dacc8ec2efd3" args="(gsl_matrix *m, size_t newheight, size_t newwidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_matrix</code> to a new height or width.</p>
<p>Data in the matrix will be retained. If the new height or width is smaller than the old, then data in the later rows/columns will be cropped away (in a non--memory-leaking manner). If the new height or width is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill new rows/columns before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds a column each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_matrix</code> is a versatile struct that can represent submatrices and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The already-allocated matrix to resize. If you give me <code>NULL</code>, this becomes equivalent to <code>gsl_matrix_alloc</code> </td></tr>
    <tr><td class="paramname">newheight,newwidth</td><td>The height and width you'd like the matrix to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>m, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="ac0674dcc81232e37c27f612499495bd4"></a><!-- doxytag: member="types.h::apop_matrix_to_data" ref="ac0674dcc81232e37c27f612499495bd4" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_matrix</code>. The matrix is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The existing matrix you'd like to turn into an <a class="el" href="gentle.html#apop_data">apop_data</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure whose <code>matrix</code> pointer points to the input matrix. The rest of the struct is basically blank. <ul>
<li>If you give me a <code>NULL</code> matrix, I return a blank <a class="el" href="gentle.html#apop_data">apop_data</a> set, equivalent to <code><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, and print a warning if <code>apop_opts.verbosity &gt;=1</code> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae1f659437ab89ac1e4df447023edf040"></a><!-- doxytag: member="types.h::apop_model_draws" ref="ae1f659437ab89ac1e4df447023edf040" args="(apop_model *model, int count, gsl_rng *rng, apop_data *draws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#ae1f659437ab89ac1e4df447023edf040">apop_model_draws</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>draws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a set of random draws from a model and write them to an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model from which draws will be made. Must already be prepared and/or estimated.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to make. If <code>draw_matrix</code> is not <code>NULL</code>, then this is ignored and <code>count=draw_matrix-&gt;matrix-&gt;size1</code>. default=1000.</td></tr>
    <tr><td class="paramname">rng</td><td>a <code>gsl_rng</code>, already allocated. default: see <a class="el" href="autorng.html">Auto-allocated RNGs</a>.</td></tr>
    <tr><td class="paramname">draws</td><td>If not <code>NULL</code>, a pre-allocated data set whose <code>matrix</code> element will be filled with draws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with the matrix filled with <code>size</code> draws. If <code>draw_matrix!=NULL</code>, then return a pointer to it.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>Input model isn't good for making draws: it is <code>NULL</code>, or <code>m-&gt;dsize=0</code>.</td></tr>
    <tr><td class="paramname">out-&gt;error=='s'</td><td>You gave me a <code>draws</code> matrix, but its size is less than the size of a single draw from the data, <code>model-&gt;dsize</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Prints a warning if you send in a non-<code>NULL <a class="el" href="structapop__data.html">apop_data</a></code> set, but its <code>matrix</code> element is <code>NULL</code>, when <code>apop_opts.verbose&gt;=1</code>.</li>
</ul>
<ul>
<li>See also <a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>, which makes a single draw. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae32d4f48cff7788b617d40155703ae64"></a><!-- doxytag: member="types.h::apop_name_add" ref="ae32d4f48cff7788b617d40155703ae64" args="(apop_name *n, char const *add_me, char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>add_me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a name to the <a class="el" href="structapop__name.html">apop_name</a> structure. Puts it at the end of the given list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An existing, allocated <a class="el" href="structapop__name.html">apop_name</a> structure. </td></tr>
    <tr><td class="paramname">add_me</td><td>A string. If <code>NULL</code>, do nothing; return -1. </td></tr>
    <tr><td class="paramname">type</td><td>'r': add a row name<br/>
 'c': add a column name<br/>
 't': add a text category name<br/>
 'h': add a title (or a header. 't' is taken).<br/>
 'v': add (or overwrite) the vector name<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of rows/cols/depvars after you have added the new one. But if <code>add_me</code> is <code>NULL</code>, return -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ff289eb3d86e1ba5b06e5064a3286f"></a><!-- doxytag: member="types.h::apop_name_alloc" ref="a29ff289eb3d86e1ba5b06e5064a3286f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* <a class="el" href="types_8h.html#a29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a name structure </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An allocated, empty name structure. In the very unlikely event that <code>malloc</code> fails, return <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad865208febeeb8cfce2f1d90e13db07a"></a><!-- doxytag: member="types.h::apop_name_copy" ref="ad865208febeeb8cfce2f1d90e13db07a" args="(apop_name *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* <a class="el" href="types_8h.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="structapop__name.html">apop_name</a> structure to another. That is, all data is duplicated. Usage:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__name.html">apop_name</a> *out  = <a class="code" href="apop__name_8c.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a>(in);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input names </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill </dd></dl>

</div>
</div>
<a class="anchor" id="adb1398925a93b7c2c502af8fb2abc49e"></a><!-- doxytag: member="types.h::apop_name_find" ref="adb1398925a93b7c2c502af8fb2abc49e" args="(const apop_name *n, const char *findme, const char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="types_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the position of an element in a list of names.</p>
<p>The function uses case-insensitive regular expressions to search.</p>
<p>For example, "p.val.*" will match "P value", "p.value", and "p values".</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="structapop__name.html">apop_name</a> object to search. </td></tr>
    <tr><td class="paramname">in</td><td>the name you seek; see above. </td></tr>
    <tr><td class="paramname">type</td><td>'c', 'r', or 't'. Default is 'c'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of <code>findme</code>. If 'c', then this may be -1, meaning the vector name. If not found, returns -2.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile). </li>
</ul>

</div>
</div>
<a class="anchor" id="a62a9c548fc646f28518bb1edb84dafc6"></a><!-- doxytag: member="types.h::apop_name_free" ref="a62a9c548fc646f28518bb1edb84dafc6" args="(apop_name *free_me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#a62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>free_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases an <a class="el" href="structapop__name.html">apop_name</a> structure. </p>

</div>
</div>
<a class="anchor" id="af7220e4b2fe43c56593af0ceb2c7001a"></a><!-- doxytag: member="types.h::apop_name_print" ref="af7220e4b2fe43c56593af0ceb2c7001a" args="(apop_name *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#af7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the given list of names to STDOUT. Useful for debugging, and not much else. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The <a class="el" href="structapop__name.html">apop_name</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fd369dba75ec4782400cf7378e56ec"></a><!-- doxytag: member="types.h::apop_name_stack" ref="ab4fd369dba75ec4782400cf7378e56ec" args="(apop_name *n1, apop_name *nadd, char type1, char typeadd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>nadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>typeadd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append one list of names to another.</p>
<p>Notice that if the first list is empty, then this is a copy function. If the second is <code>NULL</code>, it is a no-op.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>The first set of names (no default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">nadd</td><td>The second set of names, which will be appended after the first. (no default, if <code>NULL</code>, a no-op) </td></tr>
    <tr><td class="paramname">type1</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then ignore <code>typeadd</code> and just overwrite the target vector name with the source name. (default = 'r') </td></tr>
    <tr><td class="paramname">typeadd</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then overwrite the target with the source vector name. (default = type1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9c6f645acce82319fb85eb9d75112ba"></a><!-- doxytag: member="types.h::apop_text_add" ref="ac9c6f645acce82319fb85eb9d75112ba" args="(apop_data *in, const size_t row, const size_t col, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="types_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a string to the text element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you send me a <code>NULL</code> string, I will write the value of <code>apop_opts.nan_string</code> in the given slot. If there is already something in that slot, that string is freed, preventing memory leaks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set, that already has an allocated <code>text</code> element. </td></tr>
    <tr><td class="paramname">row</td><td>The row </td></tr>
    <tr><td class="paramname">col</td><td>The col </td></tr>
    <tr><td class="paramname">fmt</td><td>The text to write. </td></tr>
    <tr><td class="paramname">...</td><td>You can use a printf-style fmt and follow it with the usual variables to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably out-of-bounds)</dd></dl>
<ul>
<li>UTF-8 or ASCII text is correctly handled. </li>
<li>Apophenia follows a general rule of not reallocating behind your back: if your text matrix is currently of size (3,3) and you try to put an item in slot (4,4), then I display an error rather than reallocating the text matrix. </li>
<li>Resizing a text matrix is annoying in C, so note that <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> will reallocate to a new size if you need. For example, this code will fill the diagonals of the text array with a message, resizing as it goes: </li>
<li>The string added is a copy (via <code>asprintf</code>), not a pointer to the input(s). </li>
<li>If there had been a string at the grid point you are writing to, the old one is effectively lost when the new one is placed. So, I free the old string to prevent leaks. Remember this if you had other pointers aliasing that string, in which case you may as well avoid this function and just use <code> asprintf(&amp;(your_dataset-&gt;text[row][col]), "your string")</code>.</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = (something already allocated.);
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n &lt; 10; n++){
    <a class="code" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(list, n+1, n+1);
    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(list, n, n, <span class="stringliteral">&quot;This is cell (%i, %i)&quot;</span>, n, n);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a9fba0f07c262a433133f6f3362617da3"></a><!-- doxytag: member="types.h::apop_text_alloc" ref="a9fba0f07c262a433133f6f3362617da3" args="(apop_data *in, const size_t row, const size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This allocates an array of strings and puts it in the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If the <code>text</code> element already exists, then this is effectively a <code>realloc</code> function, reshaping to the size you specify.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. It's OK to send in <code>NULL</code>, in which case an <a class="el" href="structapop__data.html">apop_data</a> set with <code>NULL</code> <code>matrix</code> and <code>vector</code> elements is returned. </td></tr>
    <tr><td class="paramname">row</td><td>the number of rows of text. </td></tr>
    <tr><td class="paramname">col</td><td>the number of columns of text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the relevant <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the input was not <code>NULL</code>, then this is a repeat of the input pointer. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65386d7b37c2eaf37d1eb4e3ae7a7554"></a><!-- doxytag: member="types.h::apop_text_free" ref="a65386d7b37c2eaf37d1eb4e3ae7a7554" args="(char ***freeme, int rows, int cols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="types_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> </td>
          <td>(</td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>freeme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free a matrix of chars* (i.e., a char***). This is the form of the text element of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, so you can use this for: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="apop__data_8c.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a>(yourdata-&gt;text, yourdata-&gt;textsize[0], yourdata-&gt;textsize[1]);
</pre></div><p> This is what <code>apop_data_free</code> uses internally. </p>

</div>
</div>
<a class="anchor" id="af4658a3ecc0acfd17f610bc162fa5556"></a><!-- doxytag: member="types.h::apop_vector_realloc" ref="af4658a3ecc0acfd17f610bc162fa5556" args="(gsl_vector *v, size_t newheight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_vector</code> to a new length.</p>
<p>Data in the vector will be retained. If the new height is smaller than the old, then data at the end of the vector will be cropped away (in a non--memory-leaking manner). If the new height is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill them before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds an element each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_vector</code> is a versatile struct that can represent subvectors, matrix columns and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The already-allocated vector to resize. If you give me <code>NULL</code>, this is equivalent to <code>gsl_vector_alloc</code> </td></tr>
    <tr><td class="paramname">newheight</td><td>The height you'd like the vector to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>v, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="a4a69e915d2b6c40f9c69ec1842e2d689"></a><!-- doxytag: member="types.h::apop_vector_to_data" ref="a4a69e915d2b6c40f9c69ec1842e2d689" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="types_8h.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_vector</code>. The vector is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an allocated, ready-to-use <a class="el" href="gentle.html#apop_data">apop_data</a> structure. <ul>
<li>If you give me a <code>NULL</code> vector, I return a blank <a class="el" href="gentle.html#apop_data">apop_data</a> set, equivalent to <code><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, and print a warning if <code>apop_opts.verbosity &gt;=1</code> </li>
</ul>
</dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a7975faa07196cf463ec261ff0ddc3ccc"></a><!-- doxytag: member="types.h::apop_opts" ref="a7975faa07196cf463ec261ff0ddc3ccc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__opts__type.html">apop_opts_type</a> <a class="el" href="types_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Here are where the options are initially set. See the <a class="el" href="structapop__opts__type.html">apop_opts_type</a> documentation for details. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Sun Nov 10 2013.</div></body></html>
