<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>
<!-- Generated by Doxygen 1.8.1.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">types.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="types_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__name.html">apop_name</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__data.html">apop_data</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__settings__type.html">apop_settings_type</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__model.html">apop_model</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapop__opts__type.html">apop_opts_type</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aeca6159c82c21da0db82ae9ed0582dc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(dataset, type,...)&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})</td></tr>
<tr class="memitem:a459acfde11f2c39f5c32cff377f85b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(freeme)&#160;&#160;&#160;do {<a class="el" href="types_8h.html#a876361709aae2aa852c60d2c21eff881">apop_data_free_base</a>(freeme); (freeme)= NULL; } while (0)</td></tr>
<tr class="memitem:a5ea849ee3c044e95eafb7b79124ce844"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(in,...)</td></tr>
<tr class="memitem:a79b5994e799d38ad44d646d7a457f42d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79b5994e799d38ad44d646d7a457f42d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_line_to_vector</b>&#160;&#160;&#160;<a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a></td></tr>
<tr class="memitem:a66a9ddae5814beb8ff3be06bdd6d78ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a66a9ddae5814beb8ff3be06bdd6d78ac">apop_vector_fill</a>(in,...)&#160;&#160;&#160;apop_vector_fill_base((in), (double []) {__VA_ARGS__})</td></tr>
<tr class="memitem:a4ed914f400ade913970ebbe698176218"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a4ed914f400ade913970ebbe698176218">apop_data_fill</a>(in,...)&#160;&#160;&#160;apop_data_fill_base((in), (double []) {__VA_ARGS__})</td></tr>
<tr class="memitem:a85b202c330343fed6056578ab4ba20ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a85b202c330343fed6056578ab4ba20ff">apop_matrix_fill</a>(in,...)&#160;&#160;&#160;apop_matrix_fill_base((in), (double []) {__VA_ARGS__})</td></tr>
<tr class="memitem:abbdfc523f5b269827db8cebf28216e28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#abbdfc523f5b269827db8cebf28216e28">apop_gaussian</a></td></tr>
<tr class="memitem:aaae03e0c8a6bb5f02bb422f4fca465ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae03e0c8a6bb5f02bb422f4fca465ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_OLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a></td></tr>
<tr class="memitem:af417b9601adfa9cefad8c9a377a9674f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af417b9601adfa9cefad8c9a377a9674f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_PMF</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a></td></tr>
<tr class="memitem:adb7cd4412e9fca67bb14aa22662aaa65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb7cd4412e9fca67bb14aa22662aaa65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_F_distribution</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga88a178ec7fceed826f72caa52eccca93">apop_f_distribution</a></td></tr>
<tr class="memitem:ad1974e60ac54b2f06a9731ecc42c74e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1974e60ac54b2f06a9731ecc42c74e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_WLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaa030af2c41ac564c3a9ccce14b06f13c">apop_wls</a></td></tr>
<tr class="memitem:aaf1281c546207c8e27e4c8a9239ec3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1281c546207c8e27e4c8a9239ec3f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_IV</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga1efcbbe0410c89401354c762363a909f">apop_iv</a></td></tr>
<tr class="memitem:ga36cae46a2950eb6cfb65794cdd5dac7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(in,...)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c8c2a99fb8c6ec54822aca08591545e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__data.html">apop_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a></td></tr>
<tr class="memitem:afe86ae10fc82d219906211e4f88e4cf9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29ff289eb3d86e1ba5b06e5064a3286f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> (void)</td></tr>
<tr class="memitem:ae32d4f48cff7788b617d40155703ae64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a> (<a class="el" href="structapop__name.html">apop_name</a> *n, char const *add_me, char type)</td></tr>
<tr class="memitem:a62a9c548fc646f28518bb1edb84dafc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> (<a class="el" href="structapop__name.html">apop_name</a> *free_me)</td></tr>
<tr class="memitem:af7220e4b2fe43c56593af0ceb2c7001a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#af7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> (<a class="el" href="structapop__name.html">apop_name</a> *n)</td></tr>
<tr class="memitem:ab4fd369dba75ec4782400cf7378e56ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> (<a class="el" href="structapop__name.html">apop_name</a> *n1, <a class="el" href="structapop__name.html">apop_name</a> *nadd, char type1, char typeadd)</td></tr>
<tr class="memitem:ad865208febeeb8cfce2f1d90e13db07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> (<a class="el" href="structapop__name.html">apop_name</a> *in)</td></tr>
<tr class="memitem:adb1398925a93b7c2c502af8fb2abc49e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> (const <a class="el" href="structapop__name.html">apop_name</a> *n, const char *findme, const char type)</td></tr>
<tr class="memitem:a1b050ee3cfbb8858576bca6ae07571df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b050ee3cfbb8858576bca6ae07571df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_add_names_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, const char type, char const **names)</td></tr>
<tr class="memitem:a876361709aae2aa852c60d2c21eff881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a876361709aae2aa852c60d2c21eff881">apop_data_free_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *freeme)</td></tr>
<tr class="memitem:ac0674dcc81232e37c27f612499495bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> (gsl_matrix *m)</td></tr>
<tr class="memitem:a4a69e915d2b6c40f9c69ec1842e2d689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> (gsl_vector *v)</td></tr>
<tr class="memitem:ac39d6a56933b6f084328ec5ecd5090d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> (const size_t size1, const size_t size2, const int size3)</td></tr>
<tr class="memitem:a0460790f2d21f03856ed4a212a4132ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> (const size_t size1, const size_t size2, const int size3)</td></tr>
<tr class="memitem:a0f2ffb5c5ba2bb240e930be08fc4fd56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> (<a class="el" href="structapop__data.html">apop_data</a> *m1, <a class="el" href="structapop__data.html">apop_data</a> *m2, char posn, char inplace)</td></tr>
<tr class="memitem:aef0284036801cb75d465a1738f65397e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int splitpoint, char r_or_c)</td></tr>
<tr class="memitem:add67e6838ce2521a1d756894dc9b5ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:a1312f6568cfe832f1e35f7f44482ffb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int *drop)</td></tr>
<tr class="memitem:aa24d396c7fda38bc4ab03a3ba2db4943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> (<a class="el" href="structapop__data.html">apop_data</a> *out, const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:ga036a0ed6241af89643566086d5cb5373"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const int row, const int col, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="memitem:gae3c2f0d4bd96555e8eeb32a44511d0ac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const size_t row, const int col, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="memitem:ga1e7ba48032cb438271d57818b85613f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data__set__get.html#ga1e7ba48032cb438271d57818b85613f2">apop_data_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const size_t row, const int col, const double val, const char *rowname, const char *colname, const char *page)</td></tr>
<tr class="memitem:a44b767b375fb18f61f939c6869955331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char *name, double val)</td></tr>
<tr class="memitem:ac9c6f645acce82319fb85eb9d75112ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col, const char *fmt,...)</td></tr>
<tr class="memitem:a9fba0f07c262a433133f6f3362617da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col)</td></tr>
<tr class="memitem:a65386d7b37c2eaf37d1eb4e3ae7a7554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> (char ***freeme, int rows, int cols)</td></tr>
<tr class="memitem:a1115911d81fdc42999bfab81e986a8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a1115911d81fdc42999bfab81e986a8a8">apop_data_transpose</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:aa06b6ab6ec9f78f305b1dacc8ec2efd3"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> (gsl_matrix *m, size_t newheight, size_t newwidth)</td></tr>
<tr class="memitem:af4658a3ecc0acfd17f610bc162fa5556"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> (gsl_vector *v, size_t newheight)</td></tr>
<tr class="memitem:ab668b25789f7e1ef812ae9f16dc776aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ab668b25789f7e1ef812ae9f16dc776aa">apop_data_prune_columns_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char **colnames)</td></tr>
<tr class="memitem:a044771db76f0afb410a8d4f05ac51ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char match)</td></tr>
<tr class="memitem:a7e7e530a692571a403e5837fda5e0f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *dataset, <a class="el" href="structapop__data.html">apop_data</a> *newpage, const char *title)</td></tr>
<tr class="memitem:ac434c9d08b6a8304107d9c93afb81914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char free_p)</td></tr>
<tr class="memitem:aea2c3d11ba0d9b5e8224628875cb81b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aea2c3d11ba0d9b5e8224628875cb81b9">apop_data_rm_rows</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int *drop, int(*do_drop)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), void *drop_parameter)</td></tr>
<tr class="memitem:ga5baf0e8717a30fdcfba350da904c1825"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)</td></tr>
<tr class="memitem:gab48a3b2c6619dba38053eccf86734adc"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gab48a3b2c6619dba38053eccf86734adc">apop_vector_to_array</a> (const gsl_vector *in)</td></tr>
<tr class="memitem:ga604388dc6d7d08d95bbaa4422085db9c"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> (const gsl_vector *in, char row_col)</td></tr>
<tr class="memitem:ga45bb322b9f491c46feb1e24025b6301f"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)</td></tr>
<tr class="memitem:aebe17fe6f2b0c49c0c90824b7a68ff90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> (char *tabname, char *r1, char *r2, char *datacol)</td></tr>
<tr class="memitem:ga8abdcdbaceaaf0dd3882a164bc2565de"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a> (double *in, int size)</td></tr>
<tr class="memitem:ga5c7ed1341ef1be13e2e277f9f31e42df"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga5c7ed1341ef1be13e2e277f9f31e42df">apop_array_to_matrix</a> (const double **in, const int rows, const int cols)</td></tr>
<tr class="memitem:gaffca0627028a244e262098cf3cf19b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gaffca0627028a244e262098cf3cf19b28">apop_array_to_data</a> (const double **in, const int rows, const int cols)</td></tr>
<tr class="memitem:gae8ac57006d4673be7352bcd16debad7f"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gae8ac57006d4673be7352bcd16debad7f">apop_line_to_matrix</a> (double *line, int rows, int cols)</td></tr>
<tr class="memitem:gac92b5b4d0e985bcca2e6df1835195743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gac92b5b4d0e985bcca2e6df1835195743">apop_line_to_data</a> (double *in, int vsize, int rows, int cols)</td></tr>
<tr class="memitem:ga630de5d4fcbe9ef13373029f5d813a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a> (char const *text_file, int has_row_names, int has_col_names, int const *field_ends, char const *delimiters)</td></tr>
<tr class="memitem:gaa57d56a9a364a4f2955d27741bbbf137"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gaa57d56a9a364a4f2955d27741bbbf137">apop_text_to_db</a> (char const *text_file, char *tabname, int has_row_names, int has_col_names, char **field_names, int const *field_ends, <a class="el" href="structapop__data.html">apop_data</a> *field_params, char *table_params, char const *delimiters)</td></tr>
<tr class="memitem:a2feb17743f8b07b8ddcf457362cabefc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:a8c4bb25171301f09a35c36306a7b9783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:aee8c299b83b8500b8b6ecd30817353c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)</td></tr>
<tr class="memitem:ga7e31798ab418cbfc7488eaba27dad2af"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in, gsl_vector *out, char all_pages, char use_info_pages)</td></tr>
<tr class="memitem:gae3058b7f39d0442f13284464d1ba235d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> (const gsl_vector *in, <a class="el" href="structapop__data.html">apop_data</a> *d, char use_info_pages)</td></tr>
<tr class="memitem:a9801d051a0ea37b5f7516a70b4054188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9801d051a0ea37b5f7516a70b4054188"></a>
<a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double[])</td></tr>
<tr class="memitem:a0b73de331ecf350babafa9418795860d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b73de331ecf350babafa9418795860d"></a>
gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_fill_base</b> (gsl_vector *in, double[])</td></tr>
<tr class="memitem:a63836a07ebd4615956812f5bbb4dea4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63836a07ebd4615956812f5bbb4dea4c"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_fill_base</b> (gsl_matrix *in, double[])</td></tr>
<tr class="memitem:a47313d1f22af539e43f5ff02dd0e8f90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a47313d1f22af539e43f5ff02dd0e8f90">apop_data_set_row</a> (<a class="el" href="structapop__data.html">apop_data</a> *row, <a class="el" href="structapop__data.html">apop_data</a> *d, int row_number)</td></tr>
<tr class="memitem:gab29755a86b82dfe31cdd01d55431cc09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#gab29755a86b82dfe31cdd01d55431cc09">apop_model_free</a> (<a class="el" href="structapop__model.html">apop_model</a> *free_me)</td></tr>
<tr class="memitem:ga3af0274133637ffd31e9708b87783b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__output.html#ga3af0274133637ffd31e9708b87783b53">apop_model_print</a> (<a class="el" href="structapop__model.html">apop_model</a> *print_me)</td></tr>
<tr class="memitem:a4fa08e29db38e8dcc111899c942022d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a4fa08e29db38e8dcc111899c942022d9">apop_model_show</a> (<a class="el" href="structapop__model.html">apop_model</a> *print_me)</td></tr>
<tr class="memitem:ga14f2bd54421fd6629baccb8a41ecd304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga14f2bd54421fd6629baccb8a41ecd304">apop_model_copy</a> (<a class="el" href="structapop__model.html">apop_model</a> in)</td></tr>
<tr class="memitem:gaa86381a72949fd3ffafefa87e3f51a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)</td></tr>
<tr class="memitem:ga0a3be4075a89f7119be95a4718e01ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> m)</td></tr>
<tr class="memitem:ga228b013bc80f308900882312cab93eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga228b013bc80f308900882312cab93eb3">apop_score</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_vector *out, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:ga5e160c8d0a0ee660c89fb3f6de2af89c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga5e160c8d0a0ee660c89fb3f6de2af89c">apop_log_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:ga2510c7df8ccd834732ee208005738b0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:gaee16258d3e52671e254f3ce03bca7754"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:gaca737ed521192a76a307bbf825ab4a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:ga373ccc4cb87b162d62d07a2685ccd8ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:ga92355da54ab91a8dee22192ae68a37d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:ga867f0b8df261866bb18e9040871c51f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:a69adca14afc66100168f585e05b59dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> (double m, double v)</td></tr>
<tr class="memitem:af4c012bdc699245953babfdf92973826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4c012bdc699245953babfdf92973826"></a>
<a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_model_set_parameters_base</b> (<a class="el" href="structapop__model.html">apop_model</a> in, double ap[])</td></tr>
<tr class="memitem:aad65cf464db938a7fbd57de43dfe1c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad65cf464db938a7fbd57de43dfe1c87"></a>
<a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>apop_map</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, int inplace, char part, int all_pages)</td></tr>
<tr class="memitem:a871b9e67a6ae243f7420e6943e28e8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a871b9e67a6ae243f7420e6943e28e8a0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>apop_map_sum</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, char part, int all_pages)</td></tr>
<tr class="memitem:ga5da5091a11c37d3501d678b8ecec466f"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> (const gsl_matrix *m, double(*fn)(gsl_vector *))</td></tr>
<tr class="memitem:gaf30eadf8772ecb9a2689ddf104902ea4"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> (const gsl_vector *v, double(*fn)(double))</td></tr>
<tr class="memitem:ga5c4ae58b861199bbc1a460719942d98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> (gsl_matrix *m, void(*fn)(gsl_vector *))</td></tr>
<tr class="memitem:ga51964750c64d327e52e2230019e44f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> (gsl_vector *v, void(*fn)(double *))</td></tr>
<tr class="memitem:gab1df9cb7fdd56e48593d99f5122224d7"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr class="memitem:ga163589e9f5cb08f88f2032fc1229ec6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> (gsl_matrix *in, void(*fn)(double *))</td></tr>
<tr class="memitem:gaa1a135fcdd8ea6f9cbc0d518773d6c3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> (const gsl_vector *in, double(*fn)(double))</td></tr>
<tr class="memitem:ga4f0c51a046140b563c8e12a6032e9a16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> (const gsl_matrix *in, double(*fn)(gsl_vector *))</td></tr>
<tr class="memitem:gae04bc576579bfb2e14d5004d4af7bb88"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mapply.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> (const gsl_matrix *in, double(*fn)(double))</td></tr>
<tr class="memitem:a0a74a90e621d477af2a7a2255ca8cdb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a74a90e621d477af2a7a2255ca8cdb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_line_and_scatter</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *est, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:a066e0c8eaa28d68f9cb4c3e5212aa336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a066e0c8eaa28d68f9cb4c3e5212aa336"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_histogram</b> (gsl_vector *data, size_t bin_count, char *with, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:ae00636a6feba1c7d3629742d5a182881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae00636a6feba1c7d3629742d5a182881"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_lattice</b> (const <a class="el" href="structapop__data.html">apop_data</a> *d, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:a88193fe42cc0fef7b8e87328115c319b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88193fe42cc0fef7b8e87328115c319b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_qq</b> (gsl_vector *v, <a class="el" href="structapop__model.html">apop_model</a> *m, char *output_file, FILE *output_pipe, char output_type, char output_append, size_t bins, gsl_rng *r)</td></tr>
<tr class="memitem:ac138f27227da1e3f33c820d17a41309f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac138f27227da1e3f33c820d17a41309f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_plot_triangle</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:afa7da327c10091f6632d17d6a4c8feea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7da327c10091f6632d17d6a4c8feea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_matrix_print</b> (const gsl_matrix *data, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:a399ccbfc9d430c1a8b78cc83693afc1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399ccbfc9d430c1a8b78cc83693afc1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_vector_print</b> (gsl_vector *data, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:ad9a1d93b42c438103aaf14ed5f7398ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9a1d93b42c438103aaf14ed5f7398ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apop_data_print</b> (const <a class="el" href="structapop__data.html">apop_data</a> *data, char *output_file, FILE *output_pipe, char output_type, char output_append)</td></tr>
<tr class="memitem:gae7f619a8c83d791ce3d07bf4f6eecb32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apop__print.html#gae7f619a8c83d791ce3d07bf4f6eecb32">apop_matrix_show</a> (const gsl_matrix *data)</td></tr>
<tr class="memitem:ga8eafc3727869f5ec195809ad6686ba7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a> (const gsl_vector *data)</td></tr>
<tr class="memitem:ga9a30c437ec11a11e37e0db7f82386275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7975faa07196cf463ec261ff0ddc3ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__opts__type.html">apop_opts_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="types_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a></td></tr>
<tr class="memitem:a6935c4bb039f97e52e04bcca5dd33828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6935c4bb039f97e52e04bcca5dd33828"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_beta</b></td></tr>
<tr class="memitem:acf02c42f90ef9c5a8bf5efca8b959f19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf02c42f90ef9c5a8bf5efca8b959f19"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_bernoulli</b></td></tr>
<tr class="memitem:acfbda1a21f138b3a1fc9a02cb419be0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbda1a21f138b3a1fc9a02cb419be0d"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_binomial</b></td></tr>
<tr class="memitem:aa746fef1b8c83fc40e576dadd2b6517b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa746fef1b8c83fc40e576dadd2b6517b"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_chi_squared</b></td></tr>
<tr class="memitem:a043fe03908df14d82dce4b23fa4e815a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043fe03908df14d82dce4b23fa4e815a"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_dirichlet</b></td></tr>
<tr class="memitem:a1424d1e4a3c56bd302f68d8104a4390d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1424d1e4a3c56bd302f68d8104a4390d"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_exponential</b></td></tr>
<tr class="memitem:a9e86d75842bf5aabaf5d1bff148f5918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e86d75842bf5aabaf5d1bff148f5918"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_f_distribution</b></td></tr>
<tr class="memitem:a29fbdc31683788485459763bed3a766d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29fbdc31683788485459763bed3a766d"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_gamma</b></td></tr>
<tr class="memitem:acf7e253f788b36af22acc492110f703a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7e253f788b36af22acc492110f703a"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_histogram</b></td></tr>
<tr class="memitem:aeba1e70a8f84144d715896f196819615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba1e70a8f84144d715896f196819615"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_improper_uniform</b></td></tr>
<tr class="memitem:ae153c802eac68c7ae9947cc21a13ecec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae153c802eac68c7ae9947cc21a13ecec"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_iv</b></td></tr>
<tr class="memitem:a7939ff15b433e3d01ba4fdbff6f075a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7939ff15b433e3d01ba4fdbff6f075a6"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_kernel_density</b></td></tr>
<tr class="memitem:a25a759c59b8db69432992b772a626430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a759c59b8db69432992b772a626430"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_loess</b></td></tr>
<tr class="memitem:afa18434a7a42017a0a6b2e6ec53177ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa18434a7a42017a0a6b2e6ec53177ed"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_logit</b></td></tr>
<tr class="memitem:aa0105d7ec4cc71b1296741cb18f36461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0105d7ec4cc71b1296741cb18f36461"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_lognormal</b></td></tr>
<tr class="memitem:abe6160b1267ed2300409579604b2a942"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe6160b1267ed2300409579604b2a942"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_multinomial</b></td></tr>
<tr class="memitem:a7a58f1e9c305ccf3bd5005fd8e5a29ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a58f1e9c305ccf3bd5005fd8e5a29ab"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_multivariate_normal</b></td></tr>
<tr class="memitem:add47232b5e71b44138569ac7b590d766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add47232b5e71b44138569ac7b590d766"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_normal</b></td></tr>
<tr class="memitem:ae85806d496571cecf2eecfaaa2c22cdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae85806d496571cecf2eecfaaa2c22cdd"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_ols</b></td></tr>
<tr class="memitem:af94b0b32a24aa6a3acb4fc4447ea5914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af94b0b32a24aa6a3acb4fc4447ea5914"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_pmf</b></td></tr>
<tr class="memitem:af31168dd505017ae273d773d2fdebbca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af31168dd505017ae273d773d2fdebbca"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_poisson</b></td></tr>
<tr class="memitem:aa63d7c4b441250bc7f2d675a251ce279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa63d7c4b441250bc7f2d675a251ce279"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_probit</b></td></tr>
<tr class="memitem:af07580a49421d735403eda5d2046a809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07580a49421d735403eda5d2046a809"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_t_distribution</b></td></tr>
<tr class="memitem:ade0939f1e8544338d59f8a788b60c81f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade0939f1e8544338d59f8a788b60c81f"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_uniform</b></td></tr>
<tr class="memitem:adb60a42c4e81d6f16445c7eea76e4c64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb60a42c4e81d6f16445c7eea76e4c64"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_waring</b></td></tr>
<tr class="memitem:a7508480c00a276a233a2f587bf61256d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7508480c00a276a233a2f587bf61256d"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_wishart</b></td></tr>
<tr class="memitem:aa0efc71c25992de485af7e8a39891774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0efc71c25992de485af7e8a39891774"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_wls</b></td></tr>
<tr class="memitem:aaef1d266c391b7ec69515ae06c47496a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaef1d266c391b7ec69515ae06c47496a"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_yule</b></td></tr>
<tr class="memitem:a25244d70952aed1caca47f54de710fb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25244d70952aed1caca47f54de710fb0"></a>
<a class="el" href="structapop__model.html">apop_model</a>&#160;</td><td class="memItemRight" valign="bottom"><b>apop_zipf</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Macro Definition Documentation</h2>
<a class="anchor" id="aeca6159c82c21da0db82ae9ed0582dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_add_names</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a list of names to a data set.</p>
<ul>
<li>Use this with a list of names that you type in yourself, like <pre class="fragment">apop_data_add_names(mydata, 'c', "age", "sex", "height");
</pre> Notice the lack of curly braces around the list.</li>
</ul>
<ul>
<li>You may have an array of names, probably autogenerated, that you would like to add. In this case, make certain that the last element of the array is <code>NULL</code>, and call the base function: <pre class="fragment">char **[] colnames = {"age", "sex", "height", NULL};
apop_data_add_names_base(mydata, 'c', colnames);
</pre> If you forget the <code>NULL</code> marker, this has good odds of segfaulting. You may prefer to use a <code>for</code> loop that inserts each name in turn using <a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>.</li>
</ul>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="types_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>, although <a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a> will be more useful in most cases. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed914f400ade913970ebbe698176218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_fill_base((in), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a pre-allocated data set with values.</p>
<p>For example:</p>
<pre class="fragment">#include &lt;apop.h&gt;

int main(){
  apop_data *a =apop_data_alloc(2,2,2);
  double    eight   = 8.0;
    apop_data_fill(a, 8, 2.2, eight/2,
                      0, 6.0, eight);
    apop_data_show(a);
}
</pre><p>Warning: I need as many arguments as the size of the data set, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your matrix with garbage or a simple segfault.</p>
<p>Underlying this function is a base function that takes a single list, as opposed to a set of unassociated numbers as above:</p>
<pre class="fragment">#include &lt;apop.h&gt;

int main(){
  apop_data *a =apop_data_alloc(2,2,2);
  double    eight   = 8.0;
  double list[] = {8, 2.2, eight/2, 
                   0, 6.0, eight};
    apop_data_fill_base(a, list);
    apop_data_show(a);
}
</pre><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of at least as many floating-point values as there are blanks in the data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to the same data set that was input.</dd></dl>
<ul>
<li>I assume that <code>vector-&gt;size==matrix-&gt;size1</code>; otherwise I just use <code>matrix-&gt;size1</code>.</li>
</ul>
<ul>
<li>to allocate and fill on one line, because the allocated pointer is returned, and so there is no leak or loss to a form like this example, which generates a unit vector for three dimensions: <pre class="fragment">apop_data *unit_vector = apop_data_fill(apop_data_alloc(3), 1, 1, 1);
</pre></li>
</ul>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__conversions.html#gac92b5b4d0e985bcca2e6df1835195743">apop_line_to_data</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a459acfde11f2c39f5c32cff377f85b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">freeme</td><td>)</td>
          <td>&#160;&#160;&#160;do {<a class="el" href="types_8h.html#a876361709aae2aa852c60d2c21eff881">apop_data_free_base</a>(freeme); (freeme)= NULL; } while (0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an <a class="el" href="gentle.html#apop_data">apop_data</a> structure.</p>
<p>As with <code>free()</code>, it is safe to send in a <code>NULL</code> pointer (in which case the function does nothing).</p>
<p>If the <code>more</code> pointer is not <code>NULL</code>, I will free the pointed-to data set first. If you don't want to free data sets down the chain, set <code>more=NULL</code> before calling this.</p>
<ul>
<li>This is actually a macro (that calls <a class="el" href="types_8h.html#a876361709aae2aa852c60d2c21eff881">apop_data_free_base</a> to do the real work). It sets <code>freeme</code> to <code>NULL</code> when it's done, because there's nothing safe you can do with the freed location, and you can later safely test conditions like <code>if (data) ...</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5ea849ee3c044e95eafb7b79124ce844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_data_prune_columns</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep only the columns of a data set that you name.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">...</td><td>A list of names to retain (i.e. the columns that shouldn't be pruned out). For example, if you have run <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>, you have columns for several statistics, but may care about only one or two; see the example.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><div class="line"><span class="comment">/* This sample produces a dummy times table, gets a summary, and prunes the summary table.</span></div>
<div class="line"><span class="comment">If you are not a test script, uncomment the last line to display the pruned table.  */</span></div>
<div class="line"><span class="keywordtype">void</span> test_prune_cols(){</div>
<div class="line">    <span class="keywordtype">int</span> i, j;</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(0, 10, 4);</div>
<div class="line">    <span class="keywordflow">for</span> (i=0; i&lt; 10; i++)</div>
<div class="line">        <span class="keywordflow">for</span> (j=0; j&lt; 4; j++)</div>
<div class="line">            <a class="code" href="group__data__set__get.html#ga1e7ba48032cb438271d57818b85613f2">apop_data_set</a>(d, i, j, i*j);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *summary = <a class="code" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>(d);</div>
<div class="line">    <a class="code" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(summary, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);</div>
<div class="line">    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;mean&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);</div>
<div class="line">    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;median&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);</div>
<div class="line">    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;max&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span></div>
<div class="line">    assert(<a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;variance&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span></div>
<div class="line">    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=0, .colname=<span class="stringliteral">&quot;mean&quot;</span>)==0);</div>
<div class="line">    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=1, .colname=<span class="stringliteral">&quot;median&quot;</span>)==4);</div>
<div class="line">    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(summary, .row=2, .colname=<span class="stringliteral">&quot;median&quot;</span>)==8);</div>
<div class="line">    <span class="comment">//apop_data_show(summary);</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>I use case-insensitive regular expressions to find your column; see <a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> for details. </li>
<li>If your regex matches multiple columns, I'll only give you the first. </li>
<li>If I can't find a column matching one of your strings, I throw an error to the screen and continue. </li>
<li>This is a macro calling <a class="el" href="types_8h.html#ab668b25789f7e1ef812ae9f16dc776aa">apop_data_prune_columns_base</a>. It packages your list of columns into a list of strings, adds a <code>NULL</code> string at the end, and calls that function. </li>
</ul>

</div>
</div>
<a class="anchor" id="abbdfc523f5b269827db8cebf28216e28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_gaussian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> distribution, qv. </p>

</div>
</div>
<a class="anchor" id="a85b202c330343fed6056578ab4ba20ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_matrix_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_matrix_fill_base((in), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a pre-allocated <code>gsl_matrix</code> with values.</p>
<p>The values should be in row-major order (i.e., list the entire first row, followed by the second row, et cetera). If your data is column-major, then try calling <code>gsl_matrix_transpose</code> after this function.</p>
<p>See <code>apop_data_alloc</code> for a relevant example. See also <code>apop_vector_alloc</code>.</p>
<p>I need as many arguments as the size of the matrix. Too many will be ignored; too few will produce unpredictable results, which may include padding your matrix with garbage or a simple segfault.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_matrix</code> (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of exactly as many floating-point values as there are blanks in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to the same matrix that was input. </dd></dl>

</div>
</div>
<a class="anchor" id="a66a9ddae5814beb8ff3be06bdd6d78ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_vector_fill</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_vector_fill_base((in), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a pre-allocated <code>gsl_vector</code> with values.</p>
<p>See <code>apop_data_alloc</code> for a relevant example. See also <code>apop_matrix_alloc</code>.</p>
<p>Warning: I need as many arguments as the size of the vector, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your vector with garbage or a simple segfault.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A <code>gsl_vector</code> (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of exactly as many values as there are spaces in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to the same vector that was input. </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0c8c2a99fb8c6ec54822aca08591545e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__data.html">apop_data</a>  <a class="el" href="structapop__data.html">apop_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure represents a data set. It primarily joins together a gsl_vector, a gsl_matrix, and a table of strings, then gives them all row and column names. It tries to be minimally intrusive, so you can use it everywhere you would use a <code>gsl_matrix</code> or a <code>gsl_vector</code>.</p>
<p>Allocate using <code>apop_data_alloc</code>, free via <code>apop_data_free</code>, or more generally, see the <code>apop_data_</code>... section of the index (in the header links) for the many other functions that operate on this struct.</p>
<p>For example, let us say that you are running a regression: there is a vector for the dependent variable, and a matrix for the dependent variables. Think of them as a partitioned matrix, where the vector is column -1, and the first column of the matrix is column zero. Here is some code to print the entire matrix. Notice that the column counter <code>i</code> starts counting at -1.</p>
<pre class="fragment">for (j = 0; j&lt; data-&gt;matrix-&gt;size1; j++){
  printf("%s\t", data-&gt;names-&gt;row[j]);
  for (i = -1; i&lt; data-&gt;matrix-&gt;size2; i++)
      printf("%g\t", apop_data_get(data, j, i));
  printf("\n");
}
</pre><p>We're generally assuming that the data vector and data matrix have the same row count: <code>data-&gt;vector-&gt;size==data-&gt;matrix-&gt;size1</code> . This means that the <a class="el" href="structapop__name.html">apop_name</a> structure doesn't have separate vector_names and row_names elements: the rownames are assumed to apply for both. </p>

</div>
</div>
<a class="anchor" id="afe86ae10fc82d219906211e4f88e4cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="structapop__model.html">apop_model</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A statistical model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a69adca14afc66100168f585e05b59dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_beta_from_mean_var </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Beta distribution is useful for modeling because it is bounded between zero and one, and can be either unimodal (if the variance is low) or bimodal (if the variance is high), and can have either a slant toward the bottom or top of the range (depending on the mean).</p>
<p>The distribution has two parameters, typically named <img class="formulaInl" alt="$\alpha$" src="form_1.png"/> and <img class="formulaInl" alt="$\beta$" src="form_2.png"/>, which can be difficult to interpret. However, there is a one-to-one mapping between (alpha, beta) pairs and (mean, variance) pairs. Since we have good intuition about the meaning of means and variances, this function takes in a mean and variance, calculates alpha and beta behind the scenes, and returns a random draw from the appropriate Beta distribution.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mean the Beta distribution should have. Notice that m is in [0,1].</td></tr>
    <tr><td class="paramname">v</td><td>The variance which the Beta distribution should have. It is in (0, 1/12), where (1/12) is the variance of a Uniform(0,1) distribution. Funny things happen with variance near 1/12 and mean far from 1/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns an <code>apop_beta</code> model with its parameters appropriately set. </dd></dl>

</div>
</div>
<a class="anchor" id="aee8c299b83b8500b8b6ecd30817353c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_crosstab_to_db </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>row_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>col_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="types_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> for the storyline; this is the complement, which takes a crosstab and writes its values to the database.</p>
<p>For example, I would take </p>
<table  frame="box">
<tr>
<td></td><td>c0</td><td>c1 </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>r0</td><td>2</td><td>3 </td></tr>
<tr>
<td>r1</td><td>0</td><td>4 </td></tr>
</table>
<p>and do the following writes to the database:</p>
<pre class="fragment">insert into your_table values ('r0', 'c0', 2);
insert into your_table values ('r0', 'c1', 3);
insert into your_table values ('r1', 'c0', 3);
insert into your_table values ('r1', 'c1', 4);
</pre><ul>
<li>If your data set does not have names (or not enough names), I will use the scheme above, filling in names of the form <code>r0</code>, <code>r1</code>, ... <code>c0</code>, <code>c1</code>, .... Text columns get their own numbering system, <code>t0</code>, <code>t1</code>, ..., which is a little more robust than continuing the column count from the matrix.</li>
</ul>
<ul>
<li>I handle only the matrix and text. </li>
</ul>

</div>
</div>
<a class="anchor" id="a44b767b375fb18f61f939c6869955331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_add_named_elmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to add a named element to a data set. Many of Apophenia's testing procedures use this to easily produce a column of named parameters. It is public as a convenience.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure. Must not be <code>NULL</code>, but may be blank (as per allocation via <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> <code>( )</code> ). </td></tr>
    <tr><td class="paramname">name</td><td>The name to add </td></tr>
    <tr><td class="paramname">val</td><td>the value to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>I use the position of the name to know where to put the value. If there are two names in the data set, then I will put the new name in the third name slot and the data in the third slot in the zeroth column of the matrix. If you use this function from start to finish in building your list, then you'll be fine. </li>
<li>If the matrix is too short (or <code>NULL</code>), I will call <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> internally to make space. </li>
<li>The list is in the zeroth column of the matrix, because that fits well with the defaults for <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>. An example:</li>
</ul>
<pre class="fragment">apop_data *list = apop_data_alloc();
apop_data_add_named_elmt(list, "height", 165);
apop_data_add_named_elmt(list, "weight", 60);

double height = apop_data_get(list, .rowname="height");
</pre> 
</div>
</div>
<a class="anchor" id="a7e7e530a692571a403e5837fda5e0f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_add_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>newpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a page to a <a class="el" href="gentle.html#apop_data">apop_data</a> set. It gets a name so you can find it later.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>The input data set, to which a page will be added. </td></tr>
    <tr><td class="paramname">newpage</td><td>The page to append </td></tr>
    <tr><td class="paramname">title</td><td>The name of the new page. Remember, this is truncated at 100 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The new page. I post a warning if I am appending or appending to a <code>NULL</code> data set and <code>apop_opts.verbose &gt;=1 </code>.</dd></dl>
<ul>
<li>Some data is fundamentally multi-page; an optimization search over multi-page parameters would search the space given by all pages, for example. Also, pages may be appended as output or auxiliary information, such as covariances&mdash;an MLE would not search over these elements. Generally, any page with a name in XML-ish brackets, such as <code>&lt;Covariance&gt;</code>, will be considered informational and ignored by search routines, missing data routines, et cetera. This is achieved by a rule in <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> and <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a>.</li>
</ul>
<p>Here is a toy example that establishes a baseline data set, adds a page, modifies it, and then later retrieves it. </p>
<pre class="fragment">  apop_data *d = apop_data_alloc(10, 10, 10); //the base data set.
  apop_data *a_new_page = apop_data_add_page(d, apop_data_alloc(2,2), "new 2 x 2 page");
  gsl_vector_set_all(a_new_page-&gt;matrix, 3);

  //later:
  apop_data *retrieved = apop_data_get_page(d, "new"); //uses regexes, not literal match.
  apop_data_show(retrieved); //print a 2x2 grid of 3s.</pre> 
</div>
</div>
<a class="anchor" id="ac39d6a56933b6f084328ec5ecd5090d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_alloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data.</p>
<ul>
<li>The typical case is three arguments, like <code>apop_data_alloc(2,3,4)</code>: vector size, matrix rows, matrix cols. If the first argument is zero, you get a <code>NULL</code> vector. </li>
<li>Two arguments, <code>apop_data_alloc(2,3)</code>, would allocate just a matrix, leaving the vector <code>NULL</code>. </li>
<li>One argument, <code>apop_data_alloc(2)</code>, would allocate just a vector, leaving the matrix <code>NULL</code>. </li>
<li>Zero arguments, <code><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, will produce a basically blank set, with <code>out-&gt;matrix==out-&gt;vector==NULL</code>.</li>
</ul>
<p>For allocating the text part, see <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>.</p>
<p>The <code>weights</code> vector is set to <code>NULL</code>. If you need it, allocate it via </p>
<pre class="fragment">d-&gt;weights   = gsl_vector_alloc(row_ct); </pre><p>.</p>
<dl class="section see"><dt>See also:</dt><dd>{<a class="el" href="types_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a>}</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and ready.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a0460790f2d21f03856ed4a212a4132ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_calloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data; set everything in the allocated portion to zero. See <a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> for details.</p>
<dl class="section return"><dt>Returns:</dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and zeroed out. </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a></dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="add67e6838ce2521a1d756894dc9b5ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data is duplicated.</p>
<p>Basically a front-end for <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> for those who prefer this sort of syntax.</p>
<p>Unlike <a class="el" href="types_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>, I do follow the <code>more</code> pointer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a structure that this function will allocate and fill. If input is NULL, then this will be NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a876361709aae2aa852c60d2c21eff881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_free_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>freeme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the elements of the given <a class="el" href="gentle.html#apop_data">apop_data</a> set and then the <a class="el" href="gentle.html#apop_data">apop_data</a> set itself. Intended to be used by <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>, a macro that calls this to free elements, then sets the value to <code>NULL</code>. </p>

</div>
</div>
<a class="anchor" id="a044771db76f0afb410a8d4f05ac51ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_get_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It's good form to get a page from your data set by name, because you may not know the order for the pages, and the stepping through makes for dull code anyway (<code><a class="el" href="structapop__data.html">apop_data</a> *page = dataset; while (page-&gt;more) page= page-&gt;more;</code>).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use. No default; if <code>NULL</code>, gives a warning if <code>apop_opts.verbose &gt;=1</code> and returns <code>NULL</code>.</td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to retrieve. Default=<code>"Info"</code>, which is the name of the page of additional estimation information returned by estimation routines (log likelihood, status, AIC, BIC, confidence intervals, ...).</td></tr>
    <tr><td class="paramname">match</td><td>If <code>'c'</code>, case-insensitive match (via <code>strcasecmp</code>); if <code>'e'</code>, exact match, if <code>'r'</code> regular expression substring search (via <a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>). Default=<code>'r'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The page whose title matches what you gave me. If I don't find a match, return <code>NULL</code>.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="aa24d396c7fda38bc4ab03a3ba2db4943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data on the first page is duplicated. [To do multiple pages, call this via a <code>for</code> loop over the data set's pages.]</p>
<p>This function does not allocate the output structure or the vector, matrix, text, or weights elements&mdash;I assume you have already done this and got the dimensions right. I will assert that there is at least enough room in the destination for your data, and fail if the copy would write more elements than there are bins.</p>
<ul>
<li>If you want space allocated, use <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>. </li>
<li>I don't follow the <code>more</code> pointer, though <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> does. </li>
<li>You can use the subsetting macros, <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a> or <a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows</a>, to copy within a data set:</li>
</ul>
<pre class="fragment">//Copy the contents of row i of mydata to row j.
Apop_data_row(mydata, i, fromrow);
Apop_data_row(mydata, j, torow);
apop_data_memcpy(torow, fromrow);
</pre><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>a structure that this function will fill. Must be preallocated </td></tr>
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab668b25789f7e1ef812ae9f16dc776aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_prune_columns_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>colnames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep only the columns of a data set that you name. This is the function called internally by the <a class="el" href="types_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> macro. In most cases, you'll want to use that macro. An example of the two uses demonstrating the difference:</p>
<pre class="fragment">    apop_data_prune_columns(d, "mean", "median");

    char *list[] = {"mean", "median", NULL};
    apop_data_prune_columns_base(d, list);</pre><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">colnames</td><td>A null-terminated list of names to retain (i.e. the columns that shouldn't be pruned out). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c4bb25171301f09a35c36306a7b9783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rank_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One often finds data where the column indicates the value of the data point. There may be two columns, and a mark in the first indicates a miss while a mark in the second is a hit. Or say that we have the following list of observations:</p>
<pre class="fragment">2 3 3 2 1 1 2 1 1 2 1 1
</pre><p> Then we could write this as: </p>
<pre class="fragment">0  1  2  3
----------
0  6  4  2
</pre><p> because there are six 1s observed, four 2s observed, and two 3s observed. We call this rank format, because 1 (or zero) is typically the most common, 2 is second most common, et cetera.</p>
<p>This function takes in a list of observations, and aggregates them into a single row in rank format.</p>
<ul>
<li>For the complement, see <a class="el" href="types_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>.</li>
</ul>
<ul>
<li>You may be interested in <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> to convert real numbers or text into a matrix of categories.</li>
</ul>
<ul>
<li>The number of bins is simply the largest number found. So if there are bins {0, 1, 2} and your data set happens to consist of <code>0 0 1 1 0</code>, then I won't know to generate results with three bins where the last bin has probability zero.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/* A round trip: generate Zipf-distributed draws, summarize them to a single list of</span></div>
<div class="line"><span class="comment">rankings, then expand the rankings to a list of single entries. The sorted list at the end</span></div>
<div class="line"><span class="comment">of this should be identical to the (sorted) original list. */</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> rank_round_trip(gsl_rng *r){</div>
<div class="line">    <span class="keywordtype">int</span> i, length = 1e4;</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *a_zipf = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, 3.2);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *draws = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(length);</div>
<div class="line">    <span class="keywordflow">for</span> (i=0; i&lt; length; i++)</div>
<div class="line">        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a>(draws, i, -1), r, a_zipf);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *by_rankings = <a class="code" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>(draws);</div>
<div class="line">    <span class="comment">//The first row of the matrix is suitable for plotting.</span></div>
<div class="line">    <span class="comment">//apop_data_show(by_rankings);</span></div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a>(by_rankings-&gt;matrix) == length);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *re_expanded = <a class="code" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>(by_rankings);</div>
<div class="line">    gsl_sort_vector(draws-&gt;vector);</div>
<div class="line">    gsl_sort_vector(re_expanded-&gt;vector);</div>
<div class="line">    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(draws-&gt;vector, re_expanded-&gt;vector) &lt; 1e-5);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2feb17743f8b07b8ddcf457362cabefc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rank_expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The complement to this is <a class="el" href="types_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>; see that function's documentation for the story and an example.</p>
<p>This function takes in a data set where the zeroth column includes the count(s) of times that zero was observed, the first gives the count(s) of times that one was observed, et cetera. It outputs a data set whose vector element includes a list that has exactly the given frequency of zeros, ones, et cetera. </p>

</div>
</div>
<a class="anchor" id="a1312f6568cfe832f1e35f7f44482ffb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_rm_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the columns set to one in the <code>drop</code> vector. The returned data structure looks like it was modified in place, but the data matrix and the names are duplicated before being pared down, so if your data is taking up more than half of your memory, this may not work.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down. </td></tr>
    <tr><td class="paramname">drop</td><td>an array of ints. If use[7]==1, then column seven will be cut from the output. A reminder: <code>calloc(in-&gt;size2 , sizeof(int))</code> will fill your array with zeros on allocation, and <code>memset(use, 1, in-&gt;size2 * sizeof(int))</code> will quickly fill an array of ints with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac434c9d08b6a8304107d9c93afb81914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_rm_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>free_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the first page from an <a class="el" href="gentle.html#apop_data">apop_data</a> set that matches a given name.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data set, to which a page will be added. No default. If <code>NULL</code>, I return silently if <code> apop_opts.verbose &lt; 1 </code>; print an error otherwise. </td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to remove. Default: <code>"Info"</code> </td></tr>
    <tr><td class="paramname">free_p</td><td>If <code>'y'</code>, then <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> the page. Default: <code>'y'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>If not freed, a pointer to the <code><a class="el" href="structapop__data.html">apop_data</a></code> page that I just pulled out. Thus, you can use this to pull a single page from a data set. I set that page's <code>more</code> pointer to <code>NULL</code>, to minimize any confusion about more-than-linear linked list topologies. If <code>free_p=='y'</code> (the default) or the page is not found, return <code>NULL</code>.</dd></dl>
<ul>
<li>I don't check the first page, so there's no concern that the head of your list of pages will move. Again, the intent of the <code>-&gt;more</code> pointer in the <a class="el" href="gentle.html#apop_data">apop_data</a> set is not to fully implement a linked list, but primarily to allow you to staple auxiliary information to a main data set.</li>
</ul>
<ul>
<li>If I don't find the page you want, I return NULL, and print a message if <code>apop_opts.verbose &gt;= 1</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aea2c3d11ba0d9b5e8224628875cb81b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_data_rm_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ir&#160;</td>
          <td class="paramname"><em>do_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drop_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the columns set to one in the <code>drop</code> vector. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down </td></tr>
    <tr><td class="paramname">drop</td><td>a vector with as many elements as the max of the vector, matrix, or text parts of <code>in</code>, with a one marking those columns to be removed. </td></tr>
    <tr><td class="paramname">do_drop</td><td>A function that returns one for rows to drop and zero for rows to not drop. A sample function: <pre class="fragment">  int your_drop_function(apop_data *onerow, void *extra_param){
    return gsl_isnan(apop_data_get(onerow)) || !strcmp(onerow-&gt;text[0][0], "Uninteresting data point");
  }</pre> </td></tr>
    <tr><td class="paramname">drop_parameter</td><td>If your <code>do_drop</code> function requires additional input, put it here and it iwll be passed through. <a class="el" href="types_8h.html#aea2c3d11ba0d9b5e8224628875cb81b9">apop_data_rm_rows</a> uses <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a> to get a subview of the input data set of height one (and since all the default arguments default to zero, you don't have to write out things like <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a> <code>(onerow, .row=0, .col=0)</code>, which can help to keep things readable).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If all the rows are to be removed, then you will wind up with the same <a class="el" href="gentle.html#apop_data">apop_data</a> set, with <code>NULL</code> <code>vector</code>, <code>matrix</code>, <code>weight</code>, and text. Therefore, you may wish to check for <code>NULL</code> elements after use. I remove rownames, but leave the other names, in case you want to add new data rows. </li>
</ul>

</div>
</div>
<a class="anchor" id="a47313d1f22af539e43f5ff02dd0e8f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_data_set_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Now that you've used <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a> to pull a row from an <a class="el" href="gentle.html#apop_data">apop_data</a> set, this function lets you write that row to another position in the same data set or a different data set entirely.</p>
<p>The set written to must have the same form as the original: </p>
<ul>
<li>a vector element has to be present if one existed in the original, </li>
<li>same for the weights vector, </li>
<li>the matrix in the destination has to have as many columns as in the original, and </li>
<li>the text has to have a row long enough to hold the original </li>
<li>If the row to be written to already has a rowname, it is overwritten. If <code>d-&gt;names-&gt;rowct == row_number</code> (all rows up to <code>row_number</code> have row names), then extend the list of row names by one to add the new name. Else, don't add the row name. </li>
<li>Column names (of all types) aren't touched. Maybe use <code>apop_data_copy</code> or <code>apop_name_copy</code> if you need to copy these names.</li>
</ul>
<p>If any of the source elements are <code>NULL</code>, I won't bother to check that element in the destination.</p>
<dl class="section return"><dt>Returns:</dt><dd>0=OK, -1=error (probably a source/destination size mismatch).</dd></dl>
<ul>
<li>The error codes for out-of-bounds errors are thread-safe iff you are have a C11-compliant compiler (thanks to the <code>_Thread_local</code> keyword) or GCC (thanks to its <code>__thread</code> extension). </li>
</ul>

</div>
</div>
<a class="anchor" id="aef0284036801cb75d465a1738f65397e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>** apop_data_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>r_or_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split one input <a class="el" href="gentle.html#apop_data">apop_data</a> structure into two.</p>
<p>For the opposite operation, see <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to split </td></tr>
    <tr><td class="paramname">splitpoint</td><td>The index of what will be the first row/column of the second data set. E.g., if this is -1 and <code>r_or_c=='c'</code>, then the whole data set will be in the second data set; if this is the length of the matrix then the whole data set will be in the first data set. Another way to put it is that <code>splitpoint</code> will equal the number of rows/columns in the first matrix (unless it is -1, in which case the first matrix will have zero rows, or it is greater than the matrix's size, in which case it will have as many rows as the original). </td></tr>
    <tr><td class="paramname">r_or_c</td><td>If this is 'r' or 'R', then put some rows in the first data set and some in the second; of 'c' or 'C', split columns into first and second data sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An array of two <a class="el" href="gentle.html#apop_data">apop_data</a> sets. If one is empty then a <code>NULL</code> pointer will be returned in that position. For example, for a data set of 50 rows, <code><a class="el" href="structapop__data.html">apop_data</a> **out = apop_data_split(data, 100, 'r')</code> sets <code>out[0] = apop_data_copy(data)</code> and <code>out[1] = NULL</code>.</dd></dl>
<ul>
<li>When splitting at a row, the text is also split. </li>
<li><code>more</code> pointer is ignored. </li>
<li>The <code>apop_data-&gt;vector</code> is taken to be the -1st element of the matrix. </li>
<li>Weights will be preserved. If splitting by rows, then the top and bottom parts of the weights vector will be assigned to the top and bottom parts of the main data set. If splitting by columns, identical copies of the weights vector will be assigned to both parts. </li>
<li>Data is copied, so you may want to call <code><a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free(in)</a></code> after this. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2ffb5c5ba2bb240e930be08fc4fd56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the first data set either on top of or to the left of the second data set.</p>
<p>The fn returns a new data set, meaning that at the end of this function, until you <a class="el" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free()</a> the original data sets, you will be taking up twice as much memory. Plan accordingly.</p>
<p>For the opposite operation, see <a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">posn</td><td>If 'r', stack rows of m1's matrix above rows of m2's<br/>
 if 'c', stack columns of m1's matrix to left of m2's<br/>
 (default = 'r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'i'</code> <code>'y'</code> or 1, use <a class="el" href="types_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> and <a class="el" href="types_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>m1</code> in place; see the caveats on those function. Otherwise, allocate a new vector, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The stacked data, either in a new <a class="el" href="gentle.html#apop_data">apop_data</a> set or <code>m1</code> </dd></dl>
<ul>
<li>If m1 or m2 are NULL, this returns a copy of the other element, and if both are NULL, you get NULL back (except if <code>m2</code> is <code>NULL</code> and <code>inplace</code> is <code>'y'</code>, where you'll get the original <code>m1</code> pointer back) </li>
<li>Text is handled as you'd expect: If 'r', one set of text is stacked on top of the other [number of columns must match]; if 'c', one set of text is set next to the other [number of rows must match]. </li>
<li><code>more</code> is ignored. </li>
<li>If stacking rows on rows, the output vector is the input vectors stacked accordingly. If stacking columns by columns, the output vector is just a copy of the vector of m1 and m2-&gt;vector doesn't appear in the output at all. </li>
<li>The same rules for dealing with the vector(s) hold for the vector(s) of weights. </li>
<li>Names are a copy of the names for <code>m1</code>, with the names for <code>m2</code> appended to the row or column list, as appropriate.</li>
</ul>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a1115911d81fdc42999bfab81e986a8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose the matrix element of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set, including the row/column names. The vector and text elements of the input data set are completely ignored.</p>
<p>This is really just a friendly wrapper for <code>gsl_matrix_transpose_memcpy</code>; if you have a <code>gsl_matrix</code> with no names, you may prefer to just use that function.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A newly alloced <a class="el" href="gentle.html#apop_data">apop_data</a> set, with the appropriately transposed matrix. The vector and text elements will be <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aebe17fe6f2b0c49c0c90824b7a68ff90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_db_to_crosstab </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datacol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give the name of a table in the database, and names of three of its columns: the x-dimension, the y-dimension, and the data. the output is a 2D matrix with rows indexed by r1 and cols by r2.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">tabname</td><td>The database table I'm querying. Anything that will work inside a <code>from</code> clause is OK, such as a subquery in parens. </td></tr>
    <tr><td class="paramname">r1</td><td>The column of the data set that will indicate the rows of the output crosstab </td></tr>
    <tr><td class="paramname">r2</td><td>The column of the data set that will indicate the columns of the output crosstab </td></tr>
    <tr><td class="paramname">datacol</td><td>The column of the data set holding the data for the cells of the crosstab</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the query to get data to fill the table (select r1, r2, datacol from tabname) returns an empty data set, then I will return a <code>NULL</code> data set and if <code>apop_opts.verbosity &gt;= 1</code> print a warning.</li>
</ul>
<ul>
<li>This setup presumes that there is one value for each (row, col) coordinate in the data. You may want an aggregate instead. There are two ways to do this, both of which hack the fact that this function runs a simple <code>select</code> query to generate the data. One is to specify an ad hoc table to pull from:</li>
</ul>
<pre class="fragment">apop_data * out = apop_db_to_crosstab("(select row, col, count(*) ct from base_data group by row, col)", "row", "col",  "ct");
</pre><p>The other is to use the fact that the table name will be at the end of the query, so you can add conditions to the table:</p>
<pre class="fragment">apop_data * out = apop_db_to_crosstab("base_data group by row, col", "row", "col", "count(*)");
//which will expand to "select row, col, count(*) from base_data group by row, col"
</pre><dl class="section see"><dt>See also:</dt><dd><a class="el" href="types_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a></dd></dl>
<ul>
<li>If something fails along the way, return <code>NULL</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa06b6ab6ec9f78f305b1dacc8ec2efd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_realloc </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will resize a gsl_matrix to a new height or width.</p>
<p>Data in the matrix will be retained. If the new height or width is smaller than the old, then data in the later rows/columns will be cropped away (in a non&ndash;memory-leaking manner). If the new height or width is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill new rows/columns before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form&mdash;especially when used in a <code>for</code> loop that adds a column each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_matrix</code> is a versatile struct that can represent submatrices and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The already-allocated matrix to resize. If you give me <code>NULL</code>, this becomes equivalent to <code>gsl_matrix_alloc</code> </td></tr>
    <tr><td class="paramname">newheight,newwidth</td><td>The height and width you'd like the matrix to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>m, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="ac0674dcc81232e37c27f612499495bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_matrix_to_data </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_matrix</code>. The matrix is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The existing matrix you'd like to turn into an <a class="el" href="gentle.html#apop_data">apop_data</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure whose <code>matrix</code> pointer points to the input matrix. The rest of the struct is basically blank. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fa08e29db38e8dcc111899c942022d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_model_show </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>print_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="group__output.html#ga3af0274133637ffd31e9708b87783b53">apop_model_print</a>. Use that one. </p>

</div>
</div>
<a class="anchor" id="ae32d4f48cff7788b617d40155703ae64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_name_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>add_me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a name to the <a class="el" href="structapop__name.html">apop_name</a> structure. Puts it at the end of the given list.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An existing, allocated <a class="el" href="structapop__name.html">apop_name</a> structure. </td></tr>
    <tr><td class="paramname">add_me</td><td>A string. If <code>NULL</code>, do nothing; return -1. </td></tr>
    <tr><td class="paramname">type</td><td>'r': add a row name<br/>
 'c': add a column name<br/>
 't': add a text category name<br/>
 'h': add a title (or a header. 't' is taken).<br/>
 'v': add (or overwrite) the vector name<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns the number of rows/cols/depvars after you have added the new one. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ff289eb3d86e1ba5b06e5064a3286f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* apop_name_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a name structure </p>
<dl class="section return"><dt>Returns:</dt><dd>An allocated, empty name structure. In the very unlikely event that <code>malloc</code> fails, return <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad865208febeeb8cfce2f1d90e13db07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* apop_name_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy one <a class="el" href="structapop__name.html">apop_name</a> structure to another. That is, all data is duplicated. Usage:</p>
<pre class="fragment">apop_name *out  = apop_name_copy(in);
</pre><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a structure that this function will allocate and fill </dd></dl>

</div>
</div>
<a class="anchor" id="adb1398925a93b7c2c502af8fb2abc49e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_name_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the position of an element in a list of names.</p>
<p>The function uses case-insensitive regular expressions to search.</p>
<p>For example, "p.val.*" will match "P value", "p.value", and "p values".</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="structapop__name.html">apop_name</a> object to search. </td></tr>
    <tr><td class="paramname">in</td><td>the name you seek; see above. </td></tr>
    <tr><td class="paramname">type</td><td>'c', 'r', or 't'. Default is 'c'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The position of <code>findme</code>. If 'c', then this may be -1, meaning the vector name. If not found, returns -2.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile). </li>
</ul>

</div>
</div>
<a class="anchor" id="a62a9c548fc646f28518bb1edb84dafc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>free_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases an <a class="el" href="structapop__name.html">apop_name</a> structure. </p>

</div>
</div>
<a class="anchor" id="af7220e4b2fe43c56593af0ceb2c7001a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the given list of names to STDOUT </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The <a class="el" href="structapop__name.html">apop_name</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fd369dba75ec4782400cf7378e56ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_name_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>nadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>typeadd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append one list of names to another.</p>
<p>Notice that if the first list is empty, then this is a copy function. If the second is <code>NULL</code>, it is a no-op.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>The first set of names (no default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">nadd</td><td>The second set of names, which will be appended after the first. (no default, if <code>NULL</code>, a no-op) </td></tr>
    <tr><td class="paramname">type1</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then ignore <code>typeadd</code> and just overwrite the target vector name with the source name. (default = 'r') </td></tr>
    <tr><td class="paramname">typeadd</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then overwrite the target with the source vector name. (default = type1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9c6f645acce82319fb85eb9d75112ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_text_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a string to the text element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you send me a <code>NULL</code> string, I will write the string <code>"NaN"</code> in the given slot. If there is already something in that slot, that string is freed (preventing memory leaks).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set, that already has an allocated <code>text</code> element. </td></tr>
    <tr><td class="paramname">row</td><td>The row </td></tr>
    <tr><td class="paramname">col</td><td>The col </td></tr>
    <tr><td class="paramname">fmt</td><td>The text to write. </td></tr>
    <tr><td class="paramname">...</td><td>You can use a printf-style fmt and follow it with the usual variables to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>0=OK, -1=error (probably out-of-bounds)</dd></dl>
<ul>
<li>UTF-8 or ASCII text is correctly handled. </li>
<li>Apophenia follows a general rule of not reallocating behind your back: if your text matrix is currently of size (3,3) and you try to put an item in slot (4,4), then I display an error rather than reallocating the text matrix. </li>
<li>Resizing a text matrix is annoying in C, so note that <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> will reallocate to a new size if you need. For example, this code will fill the diagonals of the text array with a message, resizing as it goes: </li>
<li>The string added is a copy (via <code>printf</code>), not a pointer to the input(s). </li>
<li>If there had been a string at the grid point you are writing to, the old one is effectively lost when the new one is placed. So, I free the old string to prevent leaks. Remember this if you had other pointers aliasing that string, in which case you may as well avoid this function and just use <code> asprintf(&amp;(your_dataset-&gt;text[row][col]), "your string")</code>.</li>
</ul>
<pre class="fragment">apop_data *list = (something already allocated.);
for (int n=0; n &lt; 10; n++){
    apop_text_alloc(list, n+1, n+1);
    apop_text_add(list, n, n, "This is cell (%i, %i)", n, n);
}
</pre> 
</div>
</div>
<a class="anchor" id="a9fba0f07c262a433133f6f3362617da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_text_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This allocates an array of strings and puts it in the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If the <code>text</code> element already exists, then this is effectively a <code>realloc</code> function, reshaping to the size you specify.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. It's OK to send in <code>NULL</code>, in which case an <a class="el" href="structapop__data.html">apop_data</a> set with <code>NULL</code> <code>matrix</code> and <code>vector</code> elements is returned. </td></tr>
    <tr><td class="paramname">row</td><td>the number of rows of text. </td></tr>
    <tr><td class="paramname">col</td><td>the number of columns of text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to the relevant <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the input was not <code>NULL</code>, then this is a repeat of the input pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a65386d7b37c2eaf37d1eb4e3ae7a7554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_text_free </td>
          <td>(</td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>freeme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a matrix of chars* (i.e., a char***). This is the form of the text element of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, so you can use this for: </p>
<pre class="fragment"> apop_text_free(yourdata-&gt;text, yourdata-&gt;textsize[0], yourdata-&gt;textsize[1]);</pre><p> This is what <code>apop_data_free</code> uses internally. </p>

</div>
</div>
<a class="anchor" id="af4658a3ecc0acfd17f610bc162fa5556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_realloc </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will resize a gsl_vector to a new length.</p>
<p>Data in the vector will be retained. If the new height is smaller than the old, then data at the end of the vector will be cropped away (in a non&ndash;memory-leaking manner). If the new height is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill them before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form&mdash;especially when used in a <code>for</code> loop that adds an element each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_vector</code> is a versatile struct that can represent subvectors, matrix columns and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The already-allocated vector to resize. If you give me <code>NULL</code>, this is equivalent to <code>gsl_vector_alloc</code> </td></tr>
    <tr><td class="paramname">newheight</td><td>The height you'd like the vector to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>v, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="a4a69e915d2b6c40f9c69ec1842e2d689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_vector_to_data </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_vector</code>. The vector is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>an allocated, ready-to-use <a class="el" href="gentle.html#apop_data">apop_data</a> structure. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a7975faa07196cf463ec261ff0ddc3ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__opts__type.html">apop_opts_type</a> apop_opts</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Here are where the options are initially set. See the <a class="el" href="structapop__opts__type.html">apop_opts_type</a> documentation for details. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Oct 8 2012.</div></body></html>
