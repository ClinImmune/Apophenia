<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asst.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="asst_8h_source.html">Go to the source code of this file.</a></p>
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li><a class="anchor" id="adb031d6207a4bab47be1ca9c39509184"></a><!-- doxytag: member="asst.h::apop_test_ANOVA_independence" ref="adb031d6207a4bab47be1ca9c39509184" args="(d)" -->
#define <b>apop_test_ANOVA_independence</b>(d)&#160;&#160;&#160;<a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a>(d)
<li>#define <a class="el" href="asst_8h.html#a674b73c9b8813f35e41009428cbc80f9">Apop_notify</a>(verbosity,...)
<li>#define <b>Apop_maybe_abort</b>(level)
<li>#define <a class="el" href="asst_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(test, onfail, level,...)
<li><a class="anchor" id="a6b522120f0e4d4533bf180e1fde1ee39"></a><!-- doxytag: member="asst.h::apop_errorlevel" ref="a6b522120f0e4d4533bf180e1fde1ee39" args="" -->
#define <b>apop_errorlevel</b>&#160;&#160;&#160;-5
<li><a class="anchor" id="a8d32f03ca035f4d2ca0ef638b07cd5df"></a><!-- doxytag: member="asst.h::apop_return_data_error" ref="a8d32f03ca035f4d2ca0ef638b07cd5df" args="(E)" -->
#define <b>apop_return_data_error</b>(E)&#160;&#160;&#160;{<a class="el" href="structapop__data.html">apop_data</a> *out=<a class="el" href="types_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(); out-&gt;error='E'; return out;}
<li><a class="anchor" id="a482b1a29fd707240d4f99d6da0fa0ddf"></a><!-- doxytag: member="asst.h::Apop_assert_c" ref="a482b1a29fd707240d4f99d6da0fa0ddf" args="(test, returnval, level,...)" -->
#define <b>Apop_assert_c</b>(test, returnval, level,...)&#160;&#160;&#160;<a class="el" href="asst_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(!(test), return returnval, level, __VA_ARGS__)
<li><a class="anchor" id="aa6760fa3f2e261b93aaf25d80a11375c"></a><!-- doxytag: member="asst.h::Apop_assert" ref="aa6760fa3f2e261b93aaf25d80a11375c" args="(test,...)" -->
#define <b>Apop_assert</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), 0, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a56d7ffeae727765479223682a672f6dd"></a><!-- doxytag: member="asst.h::Apop_assert_n" ref="a56d7ffeae727765479223682a672f6dd" args="(test,...)" -->
#define <b>Apop_assert_n</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test),  , apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a55126db41995542d13819b8b9e9f794c"></a><!-- doxytag: member="asst.h::Apop_assert_nan" ref="a55126db41995542d13819b8b9e9f794c" args="(test,...)" -->
#define <b>Apop_assert_nan</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), GSL_NAN, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="afd6540d56da36cd8ed25aef36282f20e"></a><!-- doxytag: member="asst.h::Apop_assert_negone" ref="afd6540d56da36cd8ed25aef36282f20e" args="(test,...)" -->
#define <b>Apop_assert_negone</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), -1, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a2a6667ffc981f0b56c7d6c6e7f01572d"></a><!-- doxytag: member="asst.h::apop_ml_imputation" ref="a2a6667ffc981f0b56c7d6c6e7f01572d" args="(d, m)" -->
#define <b>apop_ml_imputation</b>(d, m)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a>(d, m)
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>double <a class="el" href="asst_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a> (int N, double s) __attribute__((__pure__))
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a> (<a class="el" href="structapop__data.html">apop_data</a> *d)
<li>int <a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> (const char *string, const char *regex, <a class="el" href="structapop__data.html">apop_data</a> **substrings, const char use_case)
<li><a class="anchor" id="a1d3c82855e1fb727a91dc4be17b7722d"></a><!-- doxytag: member="asst.h::apop_system" ref="a1d3c82855e1fb727a91dc4be17b7722d" args="(const char *fmt,...) __attribute__((format(printf" -->
int <b>apop_system</b> (const char *fmt,...) __attribute__((format(printf
<li>int gsl_vector * <a class="el" href="asst_8h.html#acfa62ab9157d4d92338a29093c7d1b30">apop_vector_moving_average</a> (gsl_vector *, size_t)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__histograms.html#gad999220164049ce7b22d2cd11bf74c26">apop_histograms_test_goodness_of_fit</a> (<a class="el" href="structapop__model.html">apop_model</a> *h0, <a class="el" href="structapop__model.html">apop_model</a> *h1)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__histograms.html#ga98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a> (<a class="el" href="structapop__model.html">apop_model</a> *m1, <a class="el" href="structapop__model.html">apop_model</a> *m2)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> (<a class="el" href="structapop__data.html">apop_data</a> *indata, <a class="el" href="structapop__data.html">apop_data</a> *binspec, int bin_count, char close_top_bin)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__histograms.html#ga12a8860fd05be2540b701fe7ec5acae4">apop_model_to_pmf</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, <a class="el" href="structapop__data.html">apop_data</a> *binspec, long int draws, int bin_count, gsl_rng *rng)
<li>char * <a class="el" href="asst_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a> (<a class="el" href="structapop__data.html">apop_data</a> const *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(<a class="el" href="structapop__data.html">apop_data</a> *, int, int, void *), void *prune_parameter)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="asst_8h.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char inplace)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="asst_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *meanvar)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="asst_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *prior, <a class="el" href="structapop__model.html">apop_model</a> *likelihood, gsl_rng *rng)
<li>double <a class="el" href="asst_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> (double statistic, char *distribution, double p1, double p2, char tail)
<li>double * <a class="el" href="asst_8h.html#afb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> (gsl_vector *data, char rounding)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="asst_8h.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int sortby, char asc)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="asst_8h.html#ac1bae5dffbbd4bc82c7369211c36f934">apop_rake</a> (char const *margin_table, char *const *var_list, int var_ct, char const *all_vars, char *const *contrasts, int contrast_ct, char const *structural_zeros, int max_iterations, double tolerance, char const *count_col, int run_number, char const *init_table, char const *init_count_col, double nudge, char const *table_name)
<li><a class="anchor" id="af1083347ab05b970089bc97287928fcb"></a><!-- doxytag: member="asst.h::asprintf" ref="af1083347ab05b970089bc97287928fcb" args="(char **res, const char *format,...) __attribute__((__format__(__printf__" -->
int <b>asprintf</b> (char **res, const char *format,...) __attribute__((__format__(__printf__
<li><a class="anchor" id="aa7d3fcd8b24054fe10faa86813d48aed"></a><!-- doxytag: member="asst.h::vasprintf" ref="aa7d3fcd8b24054fe10faa86813d48aed" args="(char **res, const char *format, va_list args) __attribute__((__format__(__printf__" -->
int int <b>vasprintf</b> (char **res, const char *format, va_list args) __attribute__((__format__(__printf__
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ad2e17aea4a8d6dbd5c1208dfe9730415"></a><!-- doxytag: member="asst.h::Apop_maybe_abort" ref="ad2e17aea4a8d6dbd5c1208dfe9730415" args="(level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_maybe_abort</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{<span class="keywordflow">if</span> ((level == -5 &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>!=<span class="charliteral">&#39;n&#39;</span>)                \
            || (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= level &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a> == <span class="charliteral">&#39;v&#39;</span>) \
            || (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>==<span class="charliteral">&#39;w&#39;</span>) ) \
                raise(SIGTRAP);}
</pre></div>
</div>
</div>
<a class="anchor" id="a674b73c9b8813f35e41009428cbc80f9"></a><!-- doxytag: member="asst.h::Apop_notify" ref="a674b73c9b8813f35e41009428cbc80f9" args="(verbosity,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="asst_8h.html#a674b73c9b8813f35e41009428cbc80f9">Apop_notify</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">verbosity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    if (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> != -1 &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= verbosity) {  \
        if (!<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a27e596063680b5b56ba5bf39fc2b6647">log_file</a>) <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file = stderr; \
        fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;%s: &quot;, __func__); fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, __VA_ARGS__); fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;\n&quot;);   \
        fflush(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file); \
} }
</pre></div><p>Notify the user of errors, warning, or debug info.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>At what verbosity level should the user be warned? E.g., if level==2, then print iff apop_opts.verbosity &gt;= 2. </td></tr>
    <tr><td class="paramname">...</td><td>The message to write to STDERR (presuming the verbosity level is high enough). This can be a printf-style format with following arguments. You can produce much more informative error messages this way, e.g., <code>apop_notify</code>(0, "Beta is %g but should be greater than zero.", beta);. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd17601e642688d033f62d346f3dace6"></a><!-- doxytag: member="asst.h::Apop_stopif" ref="abd17601e642688d033f62d346f3dace6" args="(test, onfail, level,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="asst_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">onfail, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
     if (test) {  \
        Apop_notify(level,  __VA_ARGS__);   \
        Apop_maybe_abort(level)  \
        onfail;  \
    } }
</pre></div><p>Execute an action and print a message to <code>stderr</code> (or the current <code>FILE</code> handle held by <code>apop_opts.log_file</code>). Intended for leaving a function on failure.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>The expression that, if true, triggers all the action. </td></tr>
    <tr><td class="paramname">onfail</td><td>If the assertion fails, do this. E.g., <code>out-&gt;error='x'; return GSL_NAN</code>. Notice that it is OK to include several lines of semicolon-separated code here, but if you have a lot to do, the most readable option may be <code>goto outro</code>, plus an appropriately-labeled section at the end of your function. </td></tr>
    <tr><td class="paramname">level</td><td>Print the warning message only if <a class="el" href="structapop__opts__type.html">apop_opts.verbose</a> is greater than or equal to this. Zero usually works, but for minor infractions use one. </td></tr>
    <tr><td class="paramname">...</td><td>The error message in printf form, plus any arguments to be inserted into the printf string. I'll provide the function name and a carriage return.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If <code>apop_opts.stop_on_warning</code> is nonzero and not <code>'v'</code>, then a failed test halts via <code>abort()</code>, even if the <code>apop_opts.verbose</code> level is set so that the warning message doesn't print to screen. Use this when running via debugger. </li>
<li>If <code>apop_opts.stop_on_warning</code> is <code>'v'</code>, then a failed test halts via <code>abort()</code> iff the verbosity level is high enough to print the error. </li>
</ul>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0316d98bbeb6ae13532a8c071019dbe6"></a><!-- doxytag: member="asst.h::apop_data_listwise_delete" ref="a0316d98bbeb6ae13532a8c071019dbe6" args="(apop_data *d, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="asst_8h.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If there is an NaN anywhere in the row of data (including the matrix, the vector, the weights, and the text) then delete the row from the data set.</p>
<ul>
<li>If every row has an NaN, then this returns <code>NULL</code>. </li>
<li>If <code>apop_opts.db_nan</code> is not <code>NULL</code>, then I will make case-insensitive comparisons to the text elements to check for bad data as well. </li>
<li>If <code>inplace</code> = 'y', then I'll free each element of the input data set and refill it with the pruned elements. I'll still take up (up to) twice the size of the data set in memory during the function. If every row has an NaN, then your <code><a class="el" href="structapop__data.html">apop_data</a></code> set will end up with <code>NULL</code> vector, matrix, .... if <code>inplace</code> = 'n', then the original data set is left unmolested. </li>
<li>I only look at the first page of data (i.e. the <code>more</code> element is ignored). </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data, with NaNs </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, clear out the pointer-to-<a class="el" href="gentle.html#apop_data">apop_data</a> that you sent in and refill with the pruned data. If <code>'n'</code>, leave the set alone and return a new data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A (potentially shorter) copy of the data set, without NaNs. If <code>inplace=='y'</code>, a pointer to the input, which was shortened in place. If the entire data set is cleared out, then this will be <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="acc90578a8086a2e6f7b1575300260f08"></a><!-- doxytag: member="asst.h::apop_data_pmf_compress" ref="acc90578a8086a2e6f7b1575300260f08" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Say that you have added a long list of observations to a single <a class="el" href="gentle.html#apop_data">apop_data</a> set, meaning that each row has weight one. There are a huge number of duplicates, perhaps because there are a handful of types that keep repeating:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
</table>
<p>You would like to reduce this to a set of distinct values, with their weights adjusted accordingly:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>3 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>4 </td></tr>
</table>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set that may have duplicate rows. As above, the data may be in text and/or numeric formats. If there is a <code>weights</code> vector, I will add those weights together as duplicates are merged. If there is no <code>weights</code> vector, I will create one, which is initially set to one for all values, and then aggregated as above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Your input is changed in place, via <a class="el" href="types_8h.html#aea2c3d11ba0d9b5e8224628875cb81b9">apop_data_rm_rows</a>, so use <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> before calling this function if you need to retain the original format. For your convenience, this function returns a pointer to your original data, which has now been pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="aa552a19d3b609864ea7a3e71c5ad13ac"></a><!-- doxytag: member="asst.h::apop_data_sort" ref="aa552a19d3b609864ea7a3e71c5ad13ac" args="(apop_data *data, int sortby, char asc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="asst_8h.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>asc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sorts the whole of a <code><a class="el" href="structapop__data.html">apop_data</a></code> set based on one column. Sorts in place, with little additional memory used.</p>
<p>Uses the <code>gsl_sort_vector_index</code> function internally, and that function just ignores NaNs; therefore this function just leaves NaNs exactly where they lay.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input set to be modified. (No default. If <code>NULL</code>, return <code>NULL</code> and emit a warning if <code>apop_opts.verbose &gt;= 1</code>.) </td></tr>
    <tr><td class="paramname">sortby</td><td>The column of data by which the sorting will take place. As usual, -1 indicates the vector element. (default: column zero of the matrix if there is a matrix; if there's a vector but no matrix, then -1). </td></tr>
    <tr><td class="paramname">asc</td><td>If 'd' or 'D', sort in descending order; else sort in ascending order. (Default: ascending) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the data set, so you can do things like <code>apop_data_show</code>(apop_data_sort(d, -1)).</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<p>The following example sorts the <code>test_data2</code> file (which you can copy from the tests/ directory of the Apophenia distribution) three different ways.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="preprocessor">#ifndef Testing</span>
<span class="preprocessor"></span><span class="preprocessor">#define showdata apop_data_show(d);</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#define showdata </span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(){
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>(<span class="stringliteral">&quot;test_data2&quot;</span>, 0 ,1);
    <a class="code" href="asst_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(!d, exit(1), 0, <span class="stringliteral">&quot;Please link or copy test_data2 from the tests directory &quot;</span>
                                <span class="stringliteral">&quot;to the directory in which you are running this test.&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; d-&gt;matrix-&gt;size1; i++){
        <span class="keywordtype">char</span> *rowname=NULL;
        asprintf(&amp;rowname, <span class="stringliteral">&quot;row %i&quot;</span>, i);
        <a class="code" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>(d-&gt;names, rowname, <span class="charliteral">&#39;r&#39;</span>);
        free(rowname);
    }

    <a class="code" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>(d-&gt;names, <span class="stringliteral">&quot;sorted ascending by first column&quot;</span>, <span class="charliteral">&#39;h&#39;</span>);
    <a class="code" href="apop__asst_8c.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a>(d, 0, <span class="charliteral">&#39;a&#39;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt; d-&gt;matrix-&gt;size2; i++){
        assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i,0) &gt;= <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i-1,0));
    }
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, 0,1)== 32 || <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, 0,1)== 9);
    showdata

    <a class="code" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>(d-&gt;names, <span class="stringliteral">&quot;\nsorted descending by first column&quot;</span>, <span class="charliteral">&#39;h&#39;</span>);
    <a class="code" href="apop__asst_8c.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a>(d, 0, <span class="charliteral">&#39;d&#39;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt; d-&gt;matrix-&gt;size2; i++){
        assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i,0) &lt;= <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i-1,0));
    }
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, 0,1)== 55); <span class="comment">//(35, 55)</span>
    showdata

    <a class="code" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>(d-&gt;names, <span class="stringliteral">&quot;\nsorted descending by second column&quot;</span>, <span class="charliteral">&#39;h&#39;</span>);
    <a class="code" href="apop__asst_8c.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a>(d, 1, <span class="charliteral">&#39;d&#39;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt; d-&gt;matrix-&gt;size2; i++){
        assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i,1) &lt;= <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, i-1,1));
    }
    assert(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(d, 0,0) == 19); <span class="comment">//(19, 60)</span>
    showdata
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a02cef4243593cf905fa54cb48d8b04c2"></a><!-- doxytag: member="asst.h::apop_data_to_bins" ref="a02cef4243593cf905fa54cb48d8b04c2" args="(apop_data *indata, apop_data *binspec, int bin_count, char close_top_bin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>close_top_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a histogram from data by putting data into bins of fixed width.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">indata</td><td>The input data that will be binned. This is copied and the copy will be modified. </td></tr>
    <tr><td class="paramname">close_top_bin</td><td>Normally, a bin covers the range from the point equal to its minimum to points strictly less than the minimum plus the width. if <code>'y'</code>, then the top bin includes points less than or equal to the upper bound. This solves the problem of displaying histograms where the top bin is just one point. </td></tr>
    <tr><td class="paramname">binspec</td><td>This is an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the same number of columns as <code>indata</code>. If you want a fixed size for the bins, then the first row of the bin spec is the bin width for each column. This allows you to specify a width for each dimension, or specify the same size for all with something like:</td></tr>
    <tr><td class="paramname">bin_count</td><td>If you don't provide a bin spec, I'll provide this many evenly-sized bins. Default: <img class="formulaInl" alt="$\sqrt(N)$" src="form_15.png"/>. <div class="fragment"><pre class="fragment">Apop_data_row(indata, 0, firstrow);
<a class="code" href="structapop__data.html">apop_data</a> *binspec = <a class="code" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(firstrow);
gsl_matrix_set_all(binspec-&gt;matrix, 10); <span class="comment">//bins of size 10 for all dim.s</span>
<a class="code" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(indata, binspec);
</pre></div> The presumption is that the first bin starts at zero in all cases. You can add a second row to the spec to give the offset for each dimension. Default: NULL. if no binspec and no binlist, then a grid with offset equal to the min of the column, and bin size such that it takes <img class="formulaInl" alt="$\sqrt{N}$" src="form_18.png"/> bins to cover the range to the max element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a binned <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you didn't give me a binspec, then I attach one to the output set as a page named <code>&lt;binspec&gt;</code>, so you can snap a second data set to the same grid using <div class="fragment"><pre class="fragment"><a class="code" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(first_set, NULL);
<a class="code" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(second_set, <a class="code" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(first_set, <span class="stringliteral">&quot;&lt;binspec&gt;&quot;</span>));
</pre></div></dd></dl>
<p>The text segment, if any, is not binned. I use <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> as the final step in the binning, and that does respect the text segment.</p>
<p>Here is a sample program highlighting the difference between <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> and <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> .</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="preprocessor">#ifdef Testing</span>
<span class="preprocessor"></span><span class="preprocessor">    #define printdata(dataset)  ;</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #define printdata(dataset)           \</span>
<span class="preprocessor">            printf(&quot;\n-----------\n\n&quot;); \</span>
<span class="preprocessor">            apop_data_print(dataset);   </span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(){
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(<a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(6), 6, 1);
    <a class="code" href="types_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(d,   1,   2,   3,   3,   1,   2);
    <a class="code" href="types_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(d,  <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);

    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Original data set&quot;</span>);
    printdata(d);

        <span class="comment">//binned, where bin ends are equidistant but not necessarily in the data</span>
    <a class="code" href="structapop__data.html">apop_data</a> *binned = <a class="code" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(d, NULL);
    asprintf(&amp;binned-&gt;names-&gt;title, <span class="stringliteral">&quot;Post binning&quot;</span>);
    printdata(binned);
    assert(<a class="code" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(binned-&gt;weights)==6);
    assert(fabs(<span class="comment">//equal distance between bins</span>
              (<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(binned, 1, -1) - <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(binned, 0, -1))
            - (<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(binned, 2, -1) - <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(binned, 1, -1))) &lt; 1e-5);

        <span class="comment">//compressed, where the data is as in the original, but weights </span>
        <span class="comment">//are redome to accommodate repeated observations.</span>
    <a class="code" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(d);
    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Post compression&quot;</span>);
    printdata(d);
    assert(<a class="code" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(d-&gt;weights)==6);

    <a class="code" href="structapop__model.html">apop_model</a> *d_as_pmf = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(d, <a class="code" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>);
    Apop_data_row(d, 0, firstrow); <span class="comment">//1A</span>
    assert(fabs(<a class="code" href="group__models.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a>(firstrow, d_as_pmf) - 2./6 &lt; 1e-5));
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a757dd4278aac9967f9e62c3ef3c8fc69"></a><!-- doxytag: member="asst.h::apop_generalized_harmonic" ref="a757dd4278aac9967f9e62c3ef3c8fc69" args="(int N, double s) __attribute__((__pure__))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="asst_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate <img class="formulaInl" alt="$\sum_{n=1}^N {1\over n^s}$" src="form_0.png"/></p>
<ul>
<li>There are no doubt efficient shortcuts do doing this, but I use brute force. [Though Knuth's Art of Programming v1 doesn't offer anything, which is strong indication of nonexistence.] To speed things along, I save the results so that they can just be looked up should you request the same calculation.</li>
</ul>
<ul>
<li>If <code>N</code> is zero or negative, return NaN. Notify the user if <code>apop_opts.verbosity &gt;=1</code></li>
</ul>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
    <span class="keywordtype">double</span> out = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(270, 0.0);
     assert (out == 270);
     out  = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(370, -1.0);
     assert (out == 370*371/2);
     out  = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(12, -1.0);
     assert (out == 12*13/2);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a2a184259c139f1fdd970ef6b43f6274e"></a><!-- doxytag: member="asst.h::apop_ml_impute" ref="a2a184259c139f1fdd970ef6b43f6274e" args="(apop_data *d, apop_model *meanvar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="asst_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>mvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Impute the most likely data points to replace NaNs in the data, and insert them into the given data. That is, the data set is modified in place.</p>
<p>How it works: this uses the machinery for <a class="el" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>. The only difference is that this searches over the data space and takes the parameter space as fixed, while basic fix params model searches parameters and takes data as fixed. So this function just does the necessary data-parameter switching to make that happen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set. It comes in with NaNs and leaves entirely filled in. </td></tr>
    <tr><td class="paramname">mvn</td><td>A parametrized <a class="el" href="structapop__model.html">apop_model</a> from which you expect the data was derived. if <code>NULL</code>, then I'll use the Multivariate Normal that best fits the data after listwise deletion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An estimated <code>apop_ml_impute_model</code>. Also, the data input will be filled in and ready to use. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1bae5dffbbd4bc82c7369211c36f934"></a><!-- doxytag: member="asst.h::apop_rake" ref="ac1bae5dffbbd4bc82c7369211c36f934" args="(char const *margin_table, char *const *var_list, int var_ct, char const *all_vars, char *const *contrasts, int contrast_ct, char const *structural_zeros, int max_iterations, double tolerance, char const *count_col, int run_number, char const *init_table, char const *init_count_col, double nudge, char const *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="asst_8h.html#ac1bae5dffbbd4bc82c7369211c36f934">apop_rake</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>margin_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>all_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>contrasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contrast_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>structural_zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>run_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nudge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fit a log-linear model via iterative proportional fitting, aka raking.</p>
<p>Raking has many uses. The <a href="http://modelingwithdata.org/arch/00000138.htm">Modeling with Data blog</a> presents a series of discussions of uses of raking, including some worked examples.</p>
<p>Or see Wikipedia for an overview of Log linear models, aka <a href="http://en.wikipedia.org/wiki/Poisson_regression">Poisson regressions</a>. One approach toward log-linear modeling is a regression form; let there be four categories, A, B, C, and D, from which we can produce a model positing, for example, that cell count is a function of a form like <img class="formulaInl" alt="$g_1(A) + g_2(BC) + g_3(CD)$" src="form_40.png"/>. In this case, we would assign a separate coefficient to every possible value of A, every possible value of (B, C), and every value of (C, D). Raking is the technique that searches for that large set of parameters.</p>
<p>The combinations of categories that are considered to be relevant are called <em>contrasts</em>, after ANOVA terminology of the 1940s.</p>
<p>The other constraint on the search are structural zeros, which are values that you know can never be non-zero, due to field-specific facts about the variables. For example, U.S. Social Security payments are available only to those age 65 or older, so "age &lt;65 and
gets_soc_security=1" is a structural zero.</p>
<p>Because there is one parameter for every combination, there may be millions of parameters to estimate, so the search to find the most likely value requires some attention to technique. For over half a century, the consensus method for searching has been raking, which iteratively draws each category closer to the mean in a somewhat simple manner (this was first developed circa 1940 and had to be feasible by hand), but which is guaranteed to eventually arrive at the maximum likelihood estimate for all cells.</p>
<p>Another complication is that the table is invariably sparse. One can easily construct tables with millions of cells, but the corresponding data set may have only a few thousand observations.</p>
<p>This function uses the database to resolve the sparseness problem. It constructs a query requesting all combinations of categories the could possibly be non-zero after raking, given all of the above constraints. Then, raking is done using only that subset. This means that the work is done on a number of cells proportional to the number of data points, not to the full cross of all categories. Set <code>apop_opts.verbose</code> to 2 or greater to show the query on <code>stderr</code>.</p>
<ul>
<li>One could use raking to generate `fully synthetic' data: start with observation-level data in a margin table. Begin the raking with a starting data set of all-ones. Then rake until the all-ones set transforms into something that conforms to the margins and (if any) structural zeros. You now have a data set which matches the marginal totals but does not use any other information from the observation-level data. If you do not specify an <code>.init_table</code>, then an all-ones default table will be used.</li>
</ul>
<ul>
<li>Set <code>apop_opts.verbose=3</code> to see the intermediate tables at the end of each round of raking.</li>
</ul>
<ul>
<li>If you want all cells to have nonzero value, then you can do that via pre-processing: <div class="fragment"><pre class="fragment"><a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;update data_table set count_col = 1e-3 where count_col = 0&quot;</span>);
</pre></div></li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">margin_table</td><td>The name of the table in the database to use for calculating the margins. The table should have one observation per row. No default. (This used to be called <code>table_name</code>; that name is now deprecated.)</td></tr>
    <tr><td class="paramname">var_list</td><td>The full list of variables to search. A list of strings, e.g., <code>(char *[]){"var1", "var2", ..., "var15"}</code></td></tr>
    <tr><td class="paramname">var_ct</td><td>The count of the full list of variables to search.</td></tr>
    <tr><td class="paramname">all_vars</td><td>deprecated.</td></tr>
    <tr><td class="paramname">contrasts</td><td>The contrasts describing your model. Like the <code>all_vars</code> input, each contrast is a pipe-delimited list of variable names. No default.</td></tr>
    <tr><td class="paramname">contrast_ct</td><td>The number of contrasts in the list of contrasts. No default.</td></tr>
    <tr><td class="paramname">structural_zeros</td><td>a SQL clause indicating combinations that can never take a nonzero value. This will go into a <code>where</code> clause, so anything you could put there is OK, e.g. "age &lt;65 and gets_soc_security=1 or age &lt;15 and married=1". Your margin data is not checked for structural zeros. Default: no structural zeros.</td></tr>
    <tr><td class="paramname">max_iterations</td><td>Number of rounds of raking at which the algorithm halts. Default: 1000.</td></tr>
    <tr><td class="paramname">tolerance</td><td>I calculate the change for each cell from round to round; if the largest cell change is smaller than this, I stop. Default: 1e-5.</td></tr>
    <tr><td class="paramname">count_col</td><td>This column gives the count of how many observations are represented by each row. If <code>NULL</code>, ech row represents one person. Default: <code>NULL</code>.</td></tr>
    <tr><td class="paramname">run_number</td><td>Because I write intermediate tables to the database, I need a way to distinguish distinct runs should you be threading several runs at once. If you aren't running several instances simultaneously, don't worry about this; if you are, do supply a value, since it's hard for the function to supply one in a race-proof manner. Default: internally-maintained values.</td></tr>
    <tr><td class="paramname">init_table</td><td>The default is to initially set all table elements to one and then rake from there. This is effectively the `fully synthetic' approach, which uses only the information in the margins and derives the data set closest to the all-ones data set that is consistent with the margins. Care is taken to maintan sparsity in this case. If you specify an <code>init_table</code>, then I will get the initial cell counts from it. Default: the fully-synthetic approach, using a starting point of an all-ones grid.</td></tr>
    <tr><td class="paramname">init_count_col</td><td>The column in <code>init_table</code> with the cell counts.</td></tr>
    <tr><td class="paramname">nudge</td><td>There is a common hack of adding a small value to every zero entry, because a zero entry will always scale to zero, while a small value could eventually scale to anything. Recall that this function works on sparse sets, so I first filter out those cells that could possibly have a nonzero value given the observations, then I add <code>nudge</code> to any zero cells within that subset.</td></tr>
    <tr><td class="paramname">table_name</td><td>Deprecated; replaced with <code>margin_table</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set where every row is a single combination of variable values and the <code>weights</code> vector gives the most likely value for each cell. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='i'</td><td>Input was somehow wrong. </td></tr>
    <tr><td class="paramname">out-&gt;error='c'</td><td>Raking did not converge, reached max. iteration count. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<ul>
<li>The interface is still beta, and subject to change---notably, handling of text categories will soon be added. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9ec5e7ed223c09bec044ced54f24fad"></a><!-- doxytag: member="asst.h::apop_regex" ref="aa9ec5e7ed223c09bec044ced54f24fad" args="(const char *string, const char *regex, apop_data **substrings, const char use_case)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td>
          <td class="paramname"><em>substrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>use_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function for regular expression searching</p>
<ul>
<li>There are three common flavors of regular expression: Basic, Extended, and Perl-compatible (BRE, ERE, PCRE). I use EREs, as per the specs of your C library, which should match POSIX's ERE specification.</li>
</ul>
<p>For example, "p.val" will match "P value", "p.value", "p values" (and even "tempeval", so be careful).</p>
<p>If you give a non-<code>NULL</code> address in which to place a table of paren-delimited substrings, I'll return them as a row in the text element of the returned <a class="el" href="gentle.html#apop_data">apop_data</a> set. I'll return <em>all</em> the matches, filling the first row with substrings from the first application of your regex, then filling the next row with another set of matches (if any), and so on to the end of the string. Useful when parsing a list of items, for example.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to search (no default) </td></tr>
    <tr><td class="paramname">regex</td><td>The regular expression (no default) </td></tr>
    <tr><td class="paramname">substrings</td><td>Parens in the regex indicate that I should return matching substrings. Give me the _address_ of an <a class="el" href="gentle.html#apop_data">apop_data</a>* set, and I will allocate and fill the text portion with matches. Default= <code>NULL</code>, meaning do not return substrings (even if parens exist in the regex). If no match, return an empty <a class="el" href="gentle.html#apop_data">apop_data</a> set, so <code>output-&gt;textsize[0]==0</code>. </td></tr>
    <tr><td class="paramname">use_case</td><td>Should I be case sensitive, <code>'y'</code> or <code>'n'</code>? (default = <code>'n'</code>, which is not the POSIX default.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Count of matches found. 0 == no match. <code>substrings</code> may be allocated and filled if needed.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile). </li>
<li>If <code>strings==NULL</code>, I return 0---no match---and if <code>substrings</code> is provided, set it to <code>NULL</code>.</li>
</ul>
<ul>
<li>Here is the test function. Notice that the substring-pulling function call passes <code>&amp;subs</code>, not plain <code>subs</code>. Also, the non-match has a zero-length blank in <code>subs-&gt;text[0][1]</code>.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>
<span class="keywordtype">int</span> main(){
    <span class="keywordtype">char</span> string1[] = <span class="stringliteral">&quot;Hello. I am a string.&quot;</span>;
    assert(<a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;hell&quot;</span>));
    <a class="code" href="structapop__data.html">apop_data</a> *subs;
    <a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;(e).*I.*(xxx)*(am)&quot;</span>, .substrings = &amp;subs);
    <span class="comment">//apop_data_show(subs);</span>
    assert(!strcmp(subs-&gt;text[0][0], <span class="stringliteral">&quot;e&quot;</span>));
    assert(!strlen(subs-&gt;text[0][1]));
    assert(!strcmp(subs-&gt;text[0][2], <span class="stringliteral">&quot;am&quot;</span>));
    <a class="code" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//Split a comma-delimited list, throwing out white space.</span>
    <span class="comment">//Notice that the regex includes only one instance of a non-comma blob </span>
    <span class="comment">//ending in a non-space followed by a comma, but the function keeps </span>
    <span class="comment">//applying it until the end of string.</span>
    <span class="keywordtype">char</span> string2[] = <span class="stringliteral">&quot; one, two , three ,four&quot;</span>;
    <a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string2, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);
    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;one&quot;</span>));
    assert(!strcmp(*subs-&gt;text[1], <span class="stringliteral">&quot;two&quot;</span>));
    assert(!strcmp(*subs-&gt;text[2], <span class="stringliteral">&quot;three&quot;</span>));
    assert(!strcmp(*subs-&gt;text[3], <span class="stringliteral">&quot;four&quot;</span>));
    <a class="code" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//Get a parenthetical. For EREs, \( \) match plain parens in the text.</span>
    <span class="keywordtype">char</span> string3[] = <span class="stringliteral">&quot; one (but secretly, two)&quot;</span>;
    <a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string3, <span class="stringliteral">&quot;(\\([^)]*\\))&quot;</span>, &amp;subs);
    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;(but secretly, two)&quot;</span>));
    <a class="code" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//NULL input string ==&gt; no-op.</span>
    <span class="keywordtype">int</span> match_count = <a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(NULL, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);
    assert(!match_count);
    assert(!subs);
}
</pre></div><ul>
<li>Each set of matches will be one row of the output data. E.g., given the regex <code>([A-Za-z])([0-9])</code>, the column zero of <code>outdata</code> will hold letters, and column one will hold numbers. Use <a class="el" href="types_8h.html#a06f38caecb66ec90b18b406b15068381">apop_data_transpose</a> to reverse this so that the letters are in <code>outdata-&gt;text[0]</code> and numbers in <code>outdata-&gt;text[1]</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a650d1ecf6f78c3bdb85c8fce71dfae05"></a><!-- doxytag: member="asst.h::apop_test" ref="a650d1ecf6f78c3bdb85c8fce71dfae05" args="(double statistic, char *distribution, double p1, double p2, char tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="asst_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a convenience function to do the lookup of a given statistic along a given distribution. You give me a statistic, its (hypothesized) distribution, and whether to use the upper tail, lower tail, or both. I will return the odds of a Type I error given the model---in statistician jargon, the <img class="formulaInl" alt="$p$" src="form_17.png"/>-value. [Type I error: odds of rejecting the null hypothesis when it is true.]</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="apop__tests_8c.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a>(1.3);
</pre></div><p>will return the density of the standard Normal distribution that is more than 1.3 from zero. If this function returns a small value, we can be confident that the statistic is significant. Or, </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="apop__tests_8c.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a>(1.3, <span class="stringliteral">&quot;t&quot;</span>, 10, tail=<span class="charliteral">&#39;u&#39;</span>);
</pre></div><p>will give the appropriate odds for an upper-tailed test using the <img class="formulaInl" alt="$t$" src="form_8.png"/>-distribution with 10 degrees of freedom (e.g., a <img class="formulaInl" alt="$t$" src="form_8.png"/>-test of the null hypothesis that the statistic is less than or equal to zero).</p>
<p>Several more distributions are supported; see below.</p>
<ul>
<li>For a two-tailed test (the default), this returns the density outside the range. I'll only do this for symmetric distributions. </li>
<li>For an upper-tail test ('u'), this returns the density above the cutoff </li>
<li>For a lower-tail test ('l'), this returns the density below the cutoff</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">statistic</td><td>The scalar value to be tested. </td></tr>
    <tr><td class="paramname">distribution</td><td>The name of the distribution; see below. </td></tr>
    <tr><td class="paramname">p1</td><td>The first parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">p2</td><td>The second parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">tail</td><td>'u' = upper tail; 'l' = lower tail; anything else = two-tailed. (default = two-tailed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The odds of a Type I error given the model (the <img class="formulaInl" alt="$p$" src="form_17.png"/>-value).</dd></dl>
<p>Here is a list of distributions you can use, and their parameters.</p>
<p><code>"normal"</code> or <code>"gaussian"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1)</li>
</ul>
<p><code>"lognormal"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1) </li>
<li>Remember, mu and sigma refer to the Normal one would get after exponentiation </li>
<li>One-tailed tests only</li>
</ul>
<p><code>"uniform"</code> </p>
<ul>
<li>p1=lower edge, p2=upper edge </li>
<li>default (0, 1) </li>
<li>two-tailed tests are run relative to the center, (p1+p2)/2.</li>
</ul>
<p><code>"t"</code> </p>
<ul>
<li>p1=df </li>
<li>no default</li>
</ul>
<p><code>"chi squared"</code>, <code>"chi"</code>, <code>"chisq"</code>: </p>
<ul>
<li>p1=df </li>
<li>no default </li>
<li>One-tailed tests only; default='u' ( <img class="formulaInl" alt="$p$" src="form_17.png"/>-value for typical cases)</li>
</ul>
<p><code>"f"</code> </p>
<ul>
<li>p1=df1, p2=df2 </li>
<li>no default </li>
<li>One-tailed tests only</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a6270ad55c566140e0d7962cb4d5daacc"></a><!-- doxytag: member="asst.h::apop_text_paste" ref="a6270ad55c566140e0d7962cb4d5daacc" args="(apop_data const *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(apop_data *, int, int, void *), void *prune_parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="asst_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_riip&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prune_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Join together a list or array of strings, with optional separators between the strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a grid of text to be combined into a single string </td></tr>
    <tr><td class="paramname">between</td><td>The text to put in between the rows of the table, such as ", ". (Default is a single space: " ") </td></tr>
    <tr><td class="paramname">before</td><td>The text to put at the head of the string. For the query example, this would be <code>.before="select "</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">after</td><td>The text to put at the tail of the string. For the query example, <code>.after=" from data_table"</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">between_cols</td><td>The text to insert between columns of text. See below for an example (Default is set to equal <code>.between</code>) </td></tr>
    <tr><td class="paramname">prune</td><td>If you don't want to use the entire text set, you can provide a function to indicate which elements should be pruned out. Some examples:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"><span class="comment">//Just use column 3</span>
<span class="keywordtype">int</span> is_not_col_3(<a class="code" href="structapop__data.html">apop_data</a> *indata, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, <span class="keywordtype">void</span> *ignore){
    <span class="keywordflow">return</span> col!=3;
}

<span class="comment">//Jump over blanks as if they don&#39;t exist.</span>
<span class="keywordtype">int</span> is_blank(<a class="code" href="structapop__data.html">apop_data</a> *indata, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, <span class="keywordtype">void</span> *ignore){
    <span class="keywordflow">return</span> strlen(indata-&gt;text[row][col])==0;
}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prune_parameter</td><td>A void pointer to pass to your <code>prune</code> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A single string with the elements of the <code>strings</code> table joined as per your specification. Allocated by the function, to be freed by you if desired.</dd></dl>
<ul>
<li>If the table of strings is <code>NULL</code> or has no text, I will print only the <code>.before</code> and <code>.after</code> parts with nothing in between. </li>
<li>if <code> apop_opts.verbose &gt;=3</code>, then print the pasted text to stderr. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<p>The sample snippet generates the SQL for a query using a list of column names (where the query begins with <code>select </code>, ends with <code>from datatab</code>, and has commas in between each element), re-processes the same list to produce the head of an HTML table, then produces the body of the table with the query result (pasting the <code>tr</code>s and <code> td</code>s into the right places).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;create table datatab(name, age, sex);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 23, &#39;m&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 32, &#39;f&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 41, &#39;f&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 14, &#39;m&#39;);&quot;</span>);

    <a class="code" href="structapop__data.html">apop_data</a> *cols = <a class="code" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 3, 1);
    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 0, 0, <span class="stringliteral">&quot;name&quot;</span>);
    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 1, 0, <span class="stringliteral">&quot;age&quot;</span>);
    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 2, 0, <span class="stringliteral">&quot;sex&quot;</span>);
    <span class="keywordtype">char</span> *query= <a class="code" href="apop__asst_8c.html#a28097fab95794bb0146de61f8461b843">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;select &quot;</span>, .between=<span class="stringliteral">&quot;, &quot;</span>);
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__queries.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;%s from datatab&quot;</span>, query);
    <span class="keywordtype">char</span> *html_head = <a class="code" href="apop__asst_8c.html#a28097fab95794bb0146de61f8461b843">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&quot;</span>,
                                .between=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>, .after=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>);
    <span class="keywordtype">char</span> *html_table = <a class="code" href="apop__asst_8c.html#a28097fab95794bb0146de61f8461b843">apop_text_paste</a>(d, .before=html_head, .after=<span class="stringliteral">&quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n&quot;</span>,
                                .between=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>, .between_cols=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);
    FILE *outfile = fopen(<span class="stringliteral">&quot;yourdata.html&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);                                                                                                                              fprintf(outfile, <span class="stringliteral">&quot;%s&quot;</span>, html_table);
    fclose(outfile);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ac7c0ddb63673ddd40ba69f7dc8bff800"></a><!-- doxytag: member="asst.h::apop_update" ref="ac7c0ddb63673ddd40ba69f7dc8bff800" args="(apop_data *data, apop_model *prior, apop_model *likelihood, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="asst_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take in a prior and likelihood distribution, and output a posterior distribution.</p>
<p>This function first checks a table of conjugate distributions for the pair you sent in. If the names match the table, then the function returns a closed-form model with updated parameters. If the parameters aren't in the table of conjugate priors/likelihoods, then it uses Markov Chain Monte Carlo to sample from the posterior distribution, and then outputs a histogram model for further analysis. Notably, the histogram can be used as the input to this function, so you can chain Bayesian updating procedures.</p>
<p>To change the default settings (periods, burnin...), add an <a class="el" href="structapop__update__settings.html">apop_update_settings</a> struct to the prior.</p>
<ul>
<li>If the likelihood model no parameters, I will allocate them. That means you can use one of the stock models that ship with Apophenia. If I need to run the model's prep routine to get the size of the parameters, then I'll make a copy of the likelihood model, run prep, and then allocate parameters for that copy of a model.</li>
</ul>
<ul>
<li>Consider the state of the <code>parameters</code> element of your likelihood model to be undefined when this exits. This may be settled at a later date.</li>
</ul>
<ul>
<li>If you set <code>apop_opts.verbose=2</code>, I will report the accept rate of the Gibbs sampler. It is a common rule of thumb to select a prior so that this is between 20% and 50%. Set <code>apop_opts.verbose=3</code> to see the proposal points, their likelihoods, and the acceptance odds.</li>
</ul>
<p>Here are the conjugate distributions currently defined:</p>
<table class="doxtable">
<tr>
<td>Prior </td><td>Likelihood </td><td>Notes   </td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">Binomial</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">Bernoulli</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#ga76b45a5681d30906572263eeef35aeff">Exponential</a> </td><td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td>Gamma likelihood represents the distribution of <img class="formulaInl" alt="$\lambda^{-1}$" src="form_90.png"/>, not plain <img class="formulaInl" alt="$\lambda$" src="form_91.png"/>   </td></tr>
<tr>
<td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td>Assumes prior with fixed <img class="formulaInl" alt="$\sigma$" src="form_66.png"/>; updates distribution for <img class="formulaInl" alt="$\mu$" src="form_69.png"/>  </td></tr>
<tr>
<td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td><a class="el" href="group__models.html#ga9c67838a4761452cc2c9113557f2a070">Poisson</a> </td><td>Uses sum and size of the data  </td></tr>
</table>
<ul>
<li>The conjugate table is stored using a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="structapop__model.html">apop_model</a> *(*apop_update_type)(<a class="code" href="structapop__data.html">apop_data</a> *, <a class="code" href="types_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a> , <a class="code" href="types_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a>);
<span class="preprocessor">#define apop_update_hash(m1, m2) ((size_t)(m1).draw + (size_t)((m2).log_likelihood ? (m2).log_likelihood : (m2).p)*33)</span>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data, that will be used by the likelihood function (default = <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">prior</td><td>The prior <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>draw</code> method. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">likelihood</td><td>The likelihood <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method (ll preferred). (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, already initialized (e.g., via <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>). (default: see <a class="el" href="autorng.html">Auto-allocated RNGs</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="structapop__model.html">apop_model</a> struct representing the posterior, with updated parameters.</dd></dl>
<p>Here is a test function that compares the output via conjugate table and via Gibbs sampling: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>
<span class="keywordtype">int</span> main(){
    gsl_rng *r = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(2468);
    <span class="keywordtype">double</span> binom_start = 0.6;
    <span class="keywordtype">double</span> beta_start_a = 0.3;
    <span class="keywordtype">double</span> beta_start_b = 0.5;
    <span class="keywordtype">int</span> i, draws = 1500;
    <span class="keywordtype">double</span> n = 4000;
    <span class="comment">//First, the easy estimation using the conjugate distribution table.</span>
    apop_model *bin = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, binom_start);
    apop_model *beta = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, beta_start_a, beta_start_b);
    apop_model *updated = <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(.prior= beta, .likelihood=bin,.rng=r);

    <span class="comment">//Now estimate via Gibbs sampling. </span>
    <span class="comment">//Requires a one-parameter binomial, with n fixed,</span>
    <span class="comment">//and a data set of n data points with the right p.</span>
    apop_model *bcopy = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, GSL_NAN);
    apop_data *bin_draws = <a class="code" href="types_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((1,2), n*(1-binom_start), n*binom_start);
    bin = <a class="code" href="stats_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(bcopy);
    <a class="code" href="group__settings.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>(beta, <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>, .burnin=.1, .periods=1e4);
    apop_model *out_h = <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(bin_draws, beta, bin, NULL);

    <span class="comment">//We now have a histogram of values for p. What&#39;s the closest beta</span>
    <span class="comment">//distribution?</span>
    apop_data *d = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(draws, 1);
    <span class="keywordflow">for</span>(i=0; i &lt; draws; i ++)
        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a>(d, i, 0), r, out_h);
    apop_model *out_beta = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(d, <a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>);
    <span class="comment">//Finally, we can compare the conjugate and Gibbs results:</span>
    <a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    <a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    <span class="keywordtype">double</span> error = <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, .metric=<span class="charliteral">&#39;m&#39;</span>);
    <span class="keywordtype">double</span> updated_size = <a class="code" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    Apop_assert(error/updated_size &lt; 0.01, <span class="stringliteral">&quot;The error is %g, which is too big.&quot;</span>, error/updated_size);
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="acfa62ab9157d4d92338a29093c7d1b30"></a><!-- doxytag: member="asst.h::apop_vector_moving_average" ref="acfa62ab9157d4d92338a29093c7d1b30" args="(gsl_vector *, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gsl_vector* <a class="el" href="asst_8h.html#acfa62ab9157d4d92338a29093c7d1b30">apop_vector_moving_average</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a new vector that is the moving average of the input vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector, unsmoothed </td></tr>
    <tr><td class="paramname">bandwidth</td><td>The number of elements to be smoothed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb838084f967543fa8a03e460180d53b"></a><!-- doxytag: member="asst.h::apop_vector_percentiles" ref="afb838084f967543fa8a03e460180d53b" args="(gsl_vector *data, char rounding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* <a class="el" href="asst_8h.html#afb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an array of size 101, where <code>returned_vector</code>[95] gives the value of the 95th percentile, for example. <code>Returned_vector</code>[100] is always the maximum value, and <code>returned_vector</code>[0] is always the min (regardless of rounding rule).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a <code>gsl_vector</code> of data. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rounding</td><td>This will either be <code>'u'</code>, <code>'d'</code>, or <code>'a'</code>. Unless your data is exactly a multiple of 101, some percentiles will be ambiguous. If <code>'u'</code>, then round up (use the next highest value); if <code>'d'</code> (or anything else), round down to the next lowest value; if <code>'a'</code>, take the mean of the two nearest points. If <code>'u'</code> or <code>'a'</code>, then you can say "5% or more  of the sample is below \c returned_vector[5]"; if <code>'d'</code> or <code>'a'</code>, then you can say "5% or more of the sample is above returned_vector[5]". (Default = <code>'d'</code>.)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>You may eventually want to <code>free()</code> the array returned by this function. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Sep 16 2013.</div></body></html>
