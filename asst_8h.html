<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>
<!-- Generated by Doxygen 1.8.1.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asst.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="asst_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adb031d6207a4bab47be1ca9c39509184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb031d6207a4bab47be1ca9c39509184"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_test_ANOVA_independence</b>(d)&#160;&#160;&#160;<a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a>(d)</td></tr>
<tr class="memitem:a674b73c9b8813f35e41009428cbc80f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a674b73c9b8813f35e41009428cbc80f9">Apop_notify</a>(verbosity,...)</td></tr>
<tr class="memitem:ad2e17aea4a8d6dbd5c1208dfe9730415"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_maybe_abort</b>(level)</td></tr>
<tr class="memitem:a482b1a29fd707240d4f99d6da0fa0ddf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>(test, returnval, level,...)</td></tr>
<tr class="memitem:a6b522120f0e4d4533bf180e1fde1ee39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b522120f0e4d4533bf180e1fde1ee39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_errorlevel</b>&#160;&#160;&#160;-5</td></tr>
<tr class="memitem:aa6760fa3f2e261b93aaf25d80a11375c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a>(test,...)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>((test), 0, apop_errorlevel, __VA_ARGS__)</td></tr>
<tr class="memitem:a56d7ffeae727765479223682a672f6dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d7ffeae727765479223682a672f6dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_assert_n</b>(test,...)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>((test),  , apop_errorlevel, __VA_ARGS__)</td></tr>
<tr class="memitem:a55126db41995542d13819b8b9e9f794c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55126db41995542d13819b8b9e9f794c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_assert_nan</b>(test,...)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>((test), GSL_NAN, apop_errorlevel, __VA_ARGS__)</td></tr>
<tr class="memitem:afd6540d56da36cd8ed25aef36282f20e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd6540d56da36cd8ed25aef36282f20e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_assert_negone</b>(test,...)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>((test), -1, apop_errorlevel, __VA_ARGS__)</td></tr>
<tr class="memitem:a962625d9637628388f84dbe640ea20a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a962625d9637628388f84dbe640ea20a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_assert_s</b>&#160;&#160;&#160;<a class="el" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a></td></tr>
<tr class="memitem:a6d56df1a9fff404cee5d4a63d1dbb632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d56df1a9fff404cee5d4a63d1dbb632"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_assert</b>&#160;&#160;&#160;<a class="el" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a></td></tr>
<tr class="memitem:a2ac12d469ac2de86e0c48679f5f1018b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ac12d469ac2de86e0c48679f5f1018b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Apop_assert_s</b>&#160;&#160;&#160;<a class="el" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a></td></tr>
<tr class="memitem:a5ff05ad3fd1e10895fff1bcbecc3d5e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff05ad3fd1e10895fff1bcbecc3d5e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_assert_c</b>&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a></td></tr>
<tr class="memitem:a2a6667ffc981f0b56c7d6c6e7f01572d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6667ffc981f0b56c7d6c6e7f01572d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>apop_ml_imputation</b>(d, m)&#160;&#160;&#160;<a class="el" href="asst_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a>(d, m)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a757dd4278aac9967f9e62c3ef3c8fc69"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a> (int N, double s) __attribute__((__pure__))</td></tr>
<tr class="memitem:ga12b92b7494f4e24d2f47244e3792d566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a> (<a class="el" href="structapop__data.html">apop_data</a> *d)</td></tr>
<tr class="memitem:aa9ec5e7ed223c09bec044ced54f24fad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> (const char *string, const char *regex, <a class="el" href="structapop__data.html">apop_data</a> **substrings, const char use_case)</td></tr>
<tr class="memitem:a1d3c82855e1fb727a91dc4be17b7722d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d3c82855e1fb727a91dc4be17b7722d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>apop_system</b> (const char *fmt,...) __attribute__((format(printf</td></tr>
<tr class="memitem:a8272352be4db925f9f519613c8b58ba9"><td class="memItemLeft" align="right" valign="top">int <a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a8272352be4db925f9f519613c8b58ba9">apop_crosstab_to_pmf</a> (<a class="el" href="structapop__data.html">apop_data</a> *d)</td></tr>
<tr class="memitem:a61185af7877b709c8b257b342c24edbc"><td class="memItemLeft" align="right" valign="top">gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a61185af7877b709c8b257b342c24edbc">apop_vector_moving_average</a> (gsl_vector *, size_t)</td></tr>
<tr class="memitem:a9d272b44efe1bb25c59bb398ecbfac8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a9d272b44efe1bb25c59bb398ecbfac8c">apop_histogram_moving_average</a> (<a class="el" href="structapop__model.html">apop_model</a> *m, size_t bandwidth)</td></tr>
<tr class="memitem:a47665d2c314071a572089137b95f36c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a47665d2c314071a572089137b95f36c5">apop_histogram_vector_reset</a> (<a class="el" href="structapop__model.html">apop_model</a> *, gsl_vector *)</td></tr>
<tr class="memitem:ab99340f82c48dd858329ff9c48d437fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#ab99340f82c48dd858329ff9c48d437fd">apop_histogram_model_reset</a> (<a class="el" href="structapop__model.html">apop_model</a> *base, <a class="el" href="structapop__model.html">apop_model</a> *m, long int draws, gsl_rng *rng)</td></tr>
<tr class="memitem:a2fe2a099150e242e974ed8f95142b3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a2fe2a099150e242e974ed8f95142b3a9">apop_histograms_test_goodness_of_fit</a> (<a class="el" href="structapop__model.html">apop_model</a> *h0, <a class="el" href="structapop__model.html">apop_model</a> *h1)</td></tr>
<tr class="memitem:a98ccaa9de7cb16e60a435c56eaf3400d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a> (<a class="el" href="structapop__model.html">apop_model</a> *m1, <a class="el" href="structapop__model.html">apop_model</a> *m2)</td></tr>
<tr class="memitem:ae94cfcf8da0b798028dfa59d85c42686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#ae94cfcf8da0b798028dfa59d85c42686">apop_histogram_normalize</a> (<a class="el" href="structapop__model.html">apop_model</a> *m)</td></tr>
<tr class="memitem:acc90578a8086a2e6f7b1575300260f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr class="memitem:a02cef4243593cf905fa54cb48d8b04c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> (<a class="el" href="structapop__data.html">apop_data</a> *indata, <a class="el" href="structapop__data.html">apop_data</a> *binspec, int bin_count, char close_top_bin)</td></tr>
<tr class="memitem:a12a8860fd05be2540b701fe7ec5acae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a12a8860fd05be2540b701fe7ec5acae4">apop_model_to_pmf</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, <a class="el" href="structapop__data.html">apop_data</a> *binspec, long int draws, int bin_count, gsl_rng *rng)</td></tr>
<tr class="memitem:ga9e82db6a61febe39f2037879eec6f285"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga9e82db6a61febe39f2037879eec6f285">apop_strip_dots</a> (char const *in, char strip_type)</td></tr>
<tr class="memitem:a0f64a390c945486f04975307a5f4b4a5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a0f64a390c945486f04975307a5f4b4a5">apop_text_paste</a> (<a class="el" href="structapop__data.html">apop_data</a> *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(<a class="el" href="structapop__data.html">apop_data</a> *, int, int, void *), void *prune_parameter)</td></tr>
<tr class="memitem:a0316d98bbeb6ae13532a8c071019dbe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char inplace)</td></tr>
<tr class="memitem:a2a184259c139f1fdd970ef6b43f6274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *meanvar)</td></tr>
<tr class="memitem:ac7c0ddb63673ddd40ba69f7dc8bff800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *prior, <a class="el" href="structapop__model.html">apop_model</a> *likelihood, gsl_rng *rng)</td></tr>
<tr class="memitem:a650d1ecf6f78c3bdb85c8fce71dfae05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> (double statistic, char *distribution, double p1, double p2, char tail)</td></tr>
<tr class="memitem:afb838084f967543fa8a03e460180d53b"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#afb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> (gsl_vector *data, char rounding)</td></tr>
<tr class="memitem:aa552a19d3b609864ea7a3e71c5ad13ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int sortby, char asc)</td></tr>
<tr class="memitem:a824f76304c9ec024bb874ddd7745d2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="asst_8h.html#a824f76304c9ec024bb874ddd7745d2f5">apop_rake</a> (char *table_name, char *all_vars, char **contrasts, int contrast_ct, char *structural_zeros, int max_iterations, double tolerance, char *count_col, int run_number, char *init_table, char *init_count_col, double nudge)</td></tr>
<tr class="memitem:af1083347ab05b970089bc97287928fcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1083347ab05b970089bc97287928fcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>asprintf</b> (char **res, const char *format,...) __attribute__((__format__(__printf__</td></tr>
<tr class="memitem:aa7d3fcd8b24054fe10faa86813d48aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d3fcd8b24054fe10faa86813d48aed"></a>
int int&#160;</td><td class="memItemRight" valign="bottom"><b>vasprintf</b> (char **res, const char *format, va_list args) __attribute__((__format__(__printf__</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Macro Definition Documentation</h2>
<a class="anchor" id="aa6760fa3f2e261b93aaf25d80a11375c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>((test), 0, apop_errorlevel, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is just a slightly more user-friendly version of the C-standard <code>assert()</code>. The program halts if the first argument evaluates to false, and the remaining arguments are a printf-style message to display to <code>stderr</code> in such an event.</p>
<p>This is how Apophenia does (almost) all of its assertions, and is made public as a convenience to you. You can see that it isn't hard to re-implement.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>An expression that, if false, halts the program </td></tr>
    <tr><td class="paramname">...</td><td>A printf-style message to display on <code>stderr</code> on halt. I'll provide the function name and a carriage return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="asst_8h.html#a482b1a29fd707240d4f99d6da0fa0ddf">Apop_assert_c</a>, which continues with a message rather than shutting down. </dd></dl>

</div>
</div>
<a class="anchor" id="a482b1a29fd707240d4f99d6da0fa0ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_assert_c</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">returnval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{\</div>
<div class="line">     if (!(test)) {  \</div>
<div class="line">        Apop_notify(level,  __VA_ARGS__);   \</div>
<div class="line">        Apop_maybe_abort(level)  \</div>
<div class="line">        return returnval;  \</div>
<div class="line">    } }</div>
</div><!-- fragment --><p>Tests whether a condition is true, and if it is not, prints an error to <code>stderr</code> and exits the function.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>The expression that you are asserting is nonzero. </td></tr>
    <tr><td class="paramname">returnval</td><td>If the assertion fails, return this. If your assertion is inside a function that returns nothing, then leave this blank, as in <code>apop_assert_c(a==b, , 0, "a should equal b");</code> </td></tr>
    <tr><td class="paramname">level</td><td>Print the warning message only if <a class="el" href="structapop__opts__type.html">apop_opts.verbose</a> is greater than or equal to this. Zero usually works, but for minor infractions use one. </td></tr>
    <tr><td class="paramname">...</td><td>The error message in printf form, plus any arguments to be inserted into the printf string. I'll provide the function name and a carriage return.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If apop_opts.stop_on_warning is nonzero and not <code>'v'</code>, then a failed test halts via <code>abort()</code>, even if the <code>apop_opts.verbose</code> level is set so that the warning message doesn't print to screen. Use this when running via debugger. </li>
<li>If apop_opts.stop_on_warning is <code>'v'</code>, then a failed test halts via <code>abort()</code> iff the verbosity level is high enough to print the error.</li>
</ul>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a>, which always halts on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e17aea4a8d6dbd5c1208dfe9730415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_maybe_abort</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{<span class="keywordflow">if</span> ((level == -5 &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>!=<span class="charliteral">&#39;n&#39;</span>)  \</div>
<div class="line">            || (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= level &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a> == <span class="charliteral">&#39;v&#39;</span>) \</div>
<div class="line">            || (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>==<span class="charliteral">&#39;w&#39;</span>) ) \</div>
<div class="line">                abort();} \</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a674b73c9b8813f35e41009428cbc80f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_notify</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">verbosity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{\</div>
<div class="line">    if (<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> != -1 &amp;&amp; <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= verbosity) {  \</div>
<div class="line">        if (!<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a27e596063680b5b56ba5bf39fc2b6647">log_file</a>) <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file = stderr; \</div>
<div class="line">        fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;%s: &quot;, __func__); fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, __VA_ARGS__); fprintf(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;\n&quot;);   \</div>
<div class="line">        fflush(<a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file); \</div>
<div class="line">} }</div>
</div><!-- fragment --><p>Notify the user of errors, warning, or debug info.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>At what verbosity level should the user be warned? E.g., if level==2, then print iff apop_opts.verbosity &gt;= 2. </td></tr>
    <tr><td class="paramname">...</td><td>The message to write to STDERR (presuming the verbosity level is high enough). This can be a printf-style format with following arguments. You can produce much more informative error messages this way, e.g., <code>apop_notify</code>(0, "Beta is %g but should be greater than zero.", beta);. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8272352be4db925f9f519613c8b58ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structapop__model.html">apop_model</a>* apop_crosstab_to_pmf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For usage, see the documentation for the <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>An input crosstab </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A PMF model which has a single line for each nonzero line of the crosstab.</dd></dl>
<ul>
<li>The <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> really keeps its information in the <code>data</code> element, where the list of observations and their weights are held. When an <a class="el" href="structapop__model.html">apop_model</a> is freed, the <code>data</code> element is untouched, but the <code>parameters</code> element is freed. This function generates a new data set that is basically internal to the model and should be freed with the model, and this is achieved by pointing both the <code>data</code> and <code>parameters</code> elements to the same data set. You probably won't ever touch the <code>data</code> set inside the model returned by this function, but bear in mind that, unlike the typical case, it will disappear after you free the model. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0316d98bbeb6ae13532a8c071019dbe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_listwise_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If there is an NaN anywhere in the row of data (including the matrix, the vector, the weights, and the text) then delete the row from the data set.</p>
<ul>
<li>If every row has an NaN, then this returns <code>NULL</code>. </li>
<li>If <code>apop_opts.db_nan</code> is not <code>NULL</code>, then I will use that as a regular expression to check the text elements for bad data as well. </li>
<li>If <code>inplace</code> = 'y', then I'll free each element of the input data set and refill it with the pruned elements. I'll still take up (up to) twice the size of the data set in memory during the function. If every row has an NaN, then your <code><a class="el" href="structapop__data.html">apop_data</a></code> set will have a lot of <code>NULL</code> elements. if <code>inplace</code> = 'n', then the original data set is left unmolested. </li>
<li>I only look at the first page of data (i.e. the <code>more</code> element is ignored). </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data, with NaNs </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, clear out the pointer-to-<a class="el" href="gentle.html#apop_data">apop_data</a> that you sent in and refill with the pruned data. If <code>'n'</code>, leave the set alone and return a new data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A (potentially shorter) copy of the data set, without NaNs. If <code>inplace=='y'</code>, redundant with the input. If the entire data set is cleared out, then this will be <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="acc90578a8086a2e6f7b1575300260f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_pmf_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Say that you have added a long list of observations to a single <a class="el" href="gentle.html#apop_data">apop_data</a> set, meaning that each row has weight one. There are a huge number of duplicates, perhaps because there are a handful of types that keep repeating:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
</table>
<p>You would like to reduce this to a set of distinct values, with their weights adjusted accordingly:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>3 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>4 </td></tr>
</table>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set that may have duplicate rows. As above, the data may be in text and/or numeric formats. If there is a <code>weights</code> vector, I will add those weights together as duplicates are merged. If there is no <code>weights</code> vector, I will create one, which is initially set to one for all values, and then aggregated as above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Your input is changed in place, via <a class="el" href="types_8h.html#aea2c3d11ba0d9b5e8224628875cb81b9">apop_data_rm_rows</a>, so use <a class="el" href="types_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> before copying this function if you need to retain the original format. For your convenience, this function returns a pointer to your original data, which has now been pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="aa552a19d3b609864ea7a3e71c5ad13ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>asc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sorts the whole of a <code><a class="el" href="structapop__data.html">apop_data</a></code> set based on one column. Sorts in place, with little additional memory used.</p>
<p>Uses the <code>gsl_sort_vector_index</code> function internally, and that function just ignores NaNs; therefore this function just leaves NaNs exactly where they lay.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input set to be modified. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">sortby</td><td>The column of data by which the sorting will take place. As usual, -1 indicates the vector element. (default: column zero of the matrix if there is a matrix; if there's a vector but no matrix, then -1). </td></tr>
    <tr><td class="paramname">asc</td><td>If 'd' or 'D', sort in descending order; else sort in ascending order. (Default: ascending) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to the data set, so you can do things like <code>apop_data_show</code>(apop_data_sort(d, -1)).</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a02cef4243593cf905fa54cb48d8b04c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_data_to_bins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>close_top_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a histogram from data by putting data into bins of fixed width.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">indata</td><td>The input data that will be binned. This is modified in place, so make a copy if you want to retain the original data. </td></tr>
    <tr><td class="paramname">close_top_bin</td><td>Normally, a bin covers the range from the point equal to its minimum to points strictly less than the minimum plus the width. if <code>'y'</code>, then the top bin includes points less than or equal to the upper bound. This solves the problem of displaying histograms where the top bin is just one point. </td></tr>
    <tr><td class="paramname">binspec</td><td>This is an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the same number of columns as <code>indata</code>. If you want a fixed size for the bins, then the first row of the bin spec is the bin width for each column. This allows you to specify a width for each dimension, or specify the same size for all with something like:</td></tr>
    <tr><td class="paramname">bin_count</td><td>If you don't provide a bin spec, I'll provide this many evenly-sized bins. Default: <img class="formulaInl" alt="$\sqrt(N)$" src="form_18.png"/>. <pre class="fragment">Apop_data_row(indata, 0, firstrow);
apop_data *binspec = apop_data_copy(firstrow);
gsl_matrix_set_all(binspec-&gt;matrix, 10); //bins of size 10 for all dim.s
apop_data_to_bins(indata, binspec);
</pre> The presumption is that the first bin starts at zero in all cases. You can add a second row to the spec to give the offset for each dimension. Default: NULL. if no binspec and no binlist, then a grid with offset equal to the min of the column, and bin size such that it takes <img class="formulaInl" alt="$\sqrt{N}$" src="form_21.png"/> bins to cover the range to the max element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A pointer to <code>indata</code>, now properly binned. If you didn't give me a binspec, then I attach one to your data set as a page named <code>&lt;binspec&gt;</code>, so you can snap a second data set to the same grid using <pre class="fragment">apop_data_to_bins(first_set, NULL);
apop_data_to_bins(second_set, apop_data_get_page(first_set, "&lt;binspec&gt;"));
</pre></dd></dl>
<p>The text segment, if any, is not binned. I use <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> as the final step in the binning, and that does respect the text segment. So given the standard one-unit grid, the data:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>1.1</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>2.1</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>2</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>1</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>1</td><td>Type 2</td><td>1 </td></tr>
</table>
<p>will bin into a histogram like:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>1</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>2</td><td>Type 1</td><td>2 </td></tr>
<tr>
<td>1</td><td>Type 1</td><td>1 </td></tr>
<tr>
<td>1</td><td>Type 2</td><td>1 </td></tr>
</table>

</div>
</div>
<a class="anchor" id="a757dd4278aac9967f9e62c3ef3c8fc69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_generalized_harmonic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate <img class="formulaInl" alt="$\sum_{n=1}^N {1\over n^s}$" src="form_0.png"/></p>
<ul>
<li>There are no doubt efficient shortcuts do doing this, but I use brute force. [Though Knuth's Art of Programming v1 doesn't offer anything, which is strong indication of nonexistence.] To speed things along, I save the results so that they can just be looked up should you request the same calculation.</li>
</ul>
<ul>
<li>If <code>N</code> is zero or negative, return NaN. Notify the user if <code>apop_opts.verbosity &gt;=1</code></li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_harmonic(){</div>
<div class="line"><span class="keywordtype">double</span> out  = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(270, 0.0);</div>
<div class="line">    assert (out == 270);</div>
<div class="line">    out = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(370, -1.0);</div>
<div class="line">    assert (out == 370*371/2);</div>
<div class="line">    out = <a class="code" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a>(12, -1.0);</div>
<div class="line">    assert (out == 12*13/2);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab99340f82c48dd858329ff9c48d437fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_histogram_model_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>draws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me an existing histogram (i.e., an <code><a class="el" href="structapop__model.html">apop_model</a></code>) and I'll create a new histogram with the same bins, but with data from <code>draws</code> random draws from the parametrized model you provide.</p>
<p>This function will normalize the output histogram to integrate to one.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>An <code><a class="el" href="structapop__model.html">apop_model</a></code> produced using a form like <code>apop_estimate(yourdata, apop_histogram)</code>. I.e. a histogram model to be used as a template. (No default) </td></tr>
    <tr><td class="paramname">m</td><td>The model to be drawn from. Because this function works via random draws, the model needs to have a <code>draw</code> method. (No default) </td></tr>
    <tr><td class="paramname">draws</td><td>The number of random draws to make. (arbitrary default = 100,000) </td></tr>
    <tr><td class="paramname">rng</td><td>The <code>gsl_rng</code> used to make random draws. (default: see note on <a class="el" href="autorng.html">Auto-allocated RNGs</a>)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9d272b44efe1bb25c59bb398ecbfac8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_histogram_moving_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new histogram that is the moving average of the input histogram. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A histogram, in <code><a class="el" href="structapop__model.html">apop_model</a></code> form. </td></tr>
    <tr><td class="paramname">bandwidth</td><td>The number of elements to be smoothed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae94cfcf8da0b798028dfa59d85c42686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_histogram_normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a histogram so it integrates to one (and is thus a proper PMF). </p>

</div>
</div>
<a class="anchor" id="a47665d2c314071a572089137b95f36c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_histogram_vector_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>template</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>indata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give me an existing histogram (as a filled-in copy of the <code>apop_histogram</code> model) and I'll create a new histogram with the same bins, but with data from the vector you provide</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">template</td><td>An <code><a class="el" href="structapop__model.html">apop_model</a></code> produced using a form like <code>apop_estimate(yourdata, apop_histogram)</code>. </td></tr>
    <tr><td class="paramname">indata</td><td>The new data to be binned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fe2a099150e242e974ed8f95142b3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_histograms_test_goodness_of_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test the goodness-of-fit between either two <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> models or two <a class="el" href="group__models.html#gafa54b2573ed0868774a9a78d07d07e62">apop_histogram</a> models.</p>
<p>I assume that the histograms are synced: for PMFs, you've used <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> to generate two histograms using the same binspec, or you've used <a class="el" href="asst_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> to guarantee that each observation value appears exactly once in each data set. For histograms, you've use <a class="el" href="asst_8h.html#a47665d2c314071a572089137b95f36c5">apop_histogram_vector_reset</a> or <a class="el" href="asst_8h.html#ab99340f82c48dd858329ff9c48d437fd">apop_histogram_model_reset</a> to ensure histograms in sync.</p>
<p>In any case, you are confident that all values in the <code>observed</code> set appear in the <code>expected</code> set with nonzero weight; otherwise this will return a <img class="formulaInl" alt="$\chi^2$" src="form_19.png"/> statistic of <code>GSL_POSINF</code>, indicating that it is impossible for the <code>observed</code> data to have been drawn from the <code>expected</code> distribution.</p>
<ul>
<li>If an observation row has weight zero, I skip it. if <code>apop_opts.verbose &gt;=1 </code> I will show a warning. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2a184259c139f1fdd970ef6b43f6274e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_ml_impute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>mvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Impute the most likely data points to replace NaNs in the data, and insert them into the given data. That is, the data set is modified in place.</p>
<p>How it works: this uses the machinery for <a class="el" href="stats_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>. The only difference is that this searches over the data space and takes the parameter space as fixed, while basic fix params model searches parameters and takes data as fixed. So this function just does the necessary data-parameter switching to make that happen.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set. It comes in with NaNs and leaves entirely filled in. </td></tr>
    <tr><td class="paramname">mvn</td><td>A parametrized <a class="el" href="structapop__model.html">apop_model</a> from which you expect the data was derived. if <code>NULL</code>, then I'll use the Multivariate Normal that best fits the data after listwise deletion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An estimated <code>apop_ml_impute_model</code>. Also, the data input will be filled in and ready to use. </dd></dl>

</div>
</div>
<a class="anchor" id="a12a8860fd05be2540b701fe7ec5acae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_model_to_pmf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>draws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make random draws from an <a class="el" href="structapop__model.html">apop_model</a>, and bin them using a binspec in the style of <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>. If you have a data set that used the same binspec, you now have synced histograms, which you can plot or sensibly test hypotheses about.</p>
<p>The output is normalized to integrate to one.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">binspec</td><td>A description of the bins in which to place the draws; see <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>. (default: as in <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>.) </td></tr>
    <tr><td class="paramname">model</td><td>The model to be drawn from. Because this function works via random draws, the model needs to have a <code>draw</code> method. (No default) </td></tr>
    <tr><td class="paramname">draws</td><td>The number of random draws to make. (arbitrary default = 10,000) </td></tr>
    <tr><td class="paramname">bin_count</td><td>If no bin spec, the number of bins to use (default: as per <a class="el" href="asst_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>, <img class="formulaInl" alt="$\sqrt(N)$" src="form_18.png"/>) </td></tr>
    <tr><td class="paramname">rng</td><td>The <code>gsl_rng</code> used to make random draws. (default: see note on <a class="el" href="autorng.html">Auto-allocated RNGs</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a824f76304c9ec024bb874ddd7745d2f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_rake </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>all_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>contrasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contrast_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>structural_zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>run_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>init_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>init_count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fit a log-linear model via iterative proportional fitting, aka raking.</p>
<p>See Wikipedia for an overview of Log linear models, aka <a href="http://en.wikipedia.org/wiki/Poisson_regression">Poisson regressions</a>. One approach toward log-linear modeling is a regression form; let there be four categories, A, B, C, and D, from which we can produce a model positing, for example, that cell count is a function of a form like <img class="formulaInl" alt="$g_1(A) + g_2(BC) + g_3(CD)$" src="form_31.png"/>. In this case, we would assign a separate coefficient to every possible value of A, every possible value of (B, C), and every value of (C, D). Raking is the technique that searches for that large set of parameters.</p>
<p>The combinations of categories that are considered to be relevant are called <em>contrasts</em>, after ANOVA terminology of the 1940s.</p>
<p>The other constraint on the search are structural zeros, which are values that you know can never be non-zero, due to field-specific facts about the variables. For example, U.S. Social Security payments are available only to those age 65 or older, so "age &lt;65 and
gets_soc_security=1" is a structural zero.</p>
<p>Because there is one parameter for every combination, there may be millions of parameters to estimate, so the search to find the most likely value requires some attention to technique. For over half a century, the consensus method for searching has been raking, which iteratively draws each category closer to the mean in a somewhat simple manner (this was first developed circa 1940 and had to be feasible by hand), but which is guaranteed to eventually arrive at the maximum likelihood estimate for all cells.</p>
<p>Another complication is that the table is invariably sparse. One can easily construct tables with millions of cells, but the corresponding data set may have only a few thousand observations.</p>
<p>This function uses the database to resolve the sparseness problem. It constructs a query requesting all combinations of categories the could possibly be non-zero after raking, given all of the above constraints. Then, raking is done using only that subset. This means that the work is done on a number of cells proportional to the number of data points, not to the full cross of all categories. Set <code>apop_opts.verbose</code> to 2 or greater to show the query on <code>stderr</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_name</td><td>The name of the table in the database. The table should have one observation per row. No default.</td></tr>
    <tr><td class="paramname">all_vars</td><td>The full list of variables to search. Provide these as a single, pipe-delimited string: e.g., "age | sex |income". Spaces are ignored. Default: if you are using SQLite, I will use all columns in the table (but the <code>.count_col</code> if any); if you are using mySQL, I haven't implemented this yet and you will have to provide a list.</td></tr>
    <tr><td class="paramname">contrasts</td><td>The contrasts describing your model. Like the <code>all_vars</code> input, each contrast is a pipe-delimited list of variable names. No default.</td></tr>
    <tr><td class="paramname">contrast_ct</td><td>The number of contrasts in the list of contrasts. No default.</td></tr>
    <tr><td class="paramname">structural_zeros</td><td>a SQL clause indicating combinations that can never take a nonzero value. This will go into a <code>where</code> clause, so anything you could put there is OK, e.g. "age &lt;65 and gets_soc_security=1 or age &lt;15 and married=1". Default: no structural zeros. </td></tr>
    <tr><td class="paramname">max_iterations</td><td>Number of rounds of raking at which the algorithm halts. Default: 1000.</td></tr>
    <tr><td class="paramname">tolerance</td><td>I calculate the change for each cell from round to round; if the largest cell change is smaller than this, I stop. Default: 1e-5.</td></tr>
    <tr><td class="paramname">count_col</td><td>This column gives the count of how many observations are represented by each row. If <code>NULL</code>, ech row represents one person. Default: <code>NULL</code>.</td></tr>
    <tr><td class="paramname">run_number</td><td>Because I write intermediate tables to the database, I need a way to distinguish distinct runs should you be threading several runs at once. If you aren't running several instances simultaneously, don't worry about this; if you are, do supply a value, since it's hard for the function to supply one in a race-proof manner. Default: internally-maintained values.</td></tr>
    <tr><td class="paramname">init_table</td><td>The default is to initially set all table elements to one and then rake from there. If you specify an <code>init_table</code>, then I will get the initial cell counts from it. Default: if you specify <code>init_count_col</code>, the default is <code>table_name</code>; if you do not the default is <code>NULL</code>. The use of a separate table for initial values is currently inadequately tested and use-at-your-own-risk.</td></tr>
    <tr><td class="paramname">init_count_col</td><td>The column in <code>init_table</code> with the cell counts.</td></tr>
    <tr><td class="paramname">nudge</td><td>There is a common hack of adding a small value to every zero entry, because a zero entry will always scale to zero, while a small value could eventually scale to anything. Recall that this function works on sparse sets, so I first filter out those cells that could possibly have a nonzero value given the observations, then I add <code>nudge</code> to any zero cells within that subset.</td></tr>
  </table>
  </dd>
</dl>
<p>If you want all cells to have nonzero value, then you can do that via pre-processing: </p>
<pre class="fragment">apop_query("update data_table set count_col = 1e-3 where count_col = 0");
</pre><dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set where every row is a single combination of variable values and the <code>weights</code> vector gives the most likely value for each cell.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<ul>
<li>The interface is still beta, and subject to change&mdash;notably, handling of text categories will soon be added.</li>
</ul>
<ul>
<li>Legal: this function is part of a larger work (C) Ben Klemens, but was partially written by a U.S. government employee during work hours. Some lawyers will tell you that the code is licensed via the same modified GPL v2 as the main work; others will tell you that it is public domain. </li>
</ul>

</div>
</div>
<a class="anchor" id="aa9ec5e7ed223c09bec044ced54f24fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_regex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td>
          <td class="paramname"><em>substrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>use_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for regular expression searching</p>
<ul>
<li>There are three common flavors of regular expression: Basic, Extended, and Perl-compatible (BRE, ERE, PCRE). I use EREs, as per the specs of your C library, which should match POSIX's ERE specification.</li>
</ul>
<p>For example, "p.val" will match "P value", "p.value", "p values" (and even "tempeval", so be careful).</p>
<p>If you give a non-<code>NULL</code> address in which to place a table of paren-delimited substrings, I'll return them as a row in the text element of the returned <a class="el" href="gentle.html#apop_data">apop_data</a> set. I'll return <em>all</em> the matches, filling the first row with substrings from the first application of your regex, then filling the next row with another set of matches (if any), and so on to the end of the string. Useful when parsing a list of items, for example.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to search (no default; if <code>NULL</code>, I return 0&mdash;no match) </td></tr>
    <tr><td class="paramname">regex</td><td>The regular expression (no default) </td></tr>
    <tr><td class="paramname">substrings</td><td>Parens in the regex indicate that I should return matching substrings. Give me the _address_ of an <a class="el" href="gentle.html#apop_data">apop_data</a>* set, and I will allocate and fill the text portion with matches. Default= <code>NULL</code>, meaning do not return substrings (even if parens exist in the regex). If no match, return an empty <a class="el" href="gentle.html#apop_data">apop_data</a> set, so <code>output-&gt;textsize[0]==0</code>. </td></tr>
    <tr><td class="paramname">use_case</td><td>Should I be case sensitive, <code>'y'</code> or <code>'n'</code>? (default = <code>'n'</code>, which is not the POSIX default.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>1 == match; 0 == no match. <code>substrings</code> may be allocated and filled if needed.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile).</li>
</ul>
<ul>
<li>Here is the test function. Notice that the substring-pulling function call passes <code>&amp;subs</code>, not plain <code>subs</code>. Also, the non-match has a zero-length blank in <code>subs-&gt;text[0][1]</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_regex(){</div>
<div class="line">    <span class="keywordtype">char</span> string1[] = <span class="stringliteral">&quot;Hello. I am a string.&quot;</span>;</div>
<div class="line">    assert(<a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;hell&quot;</span>));</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *subs;</div>
<div class="line">    <a class="code" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;(e).*I.*(xxx)*(am)&quot;</span>, .substrings = &amp;subs);</div>
<div class="line">    <span class="comment">//apop_data_show(subs);</span></div>
<div class="line">    assert(!strcmp(subs-&gt;text[0][0], <span class="stringliteral">&quot;e&quot;</span>));</div>
<div class="line">    assert(!strlen(subs-&gt;text[0][1]));</div>
<div class="line">    assert(!strcmp(subs-&gt;text[0][2], <span class="stringliteral">&quot;am&quot;</span>));</div>
<div class="line">    <a class="code" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a650d1ecf6f78c3bdb85c8fce71dfae05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_test </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a convenience function to do the lookup of a given statistic along a given distribution. You give me a statistic, its (hypothesized) distribution, and whether to use the upper tail, lower tail, or both. I will return the odds of a Type I error given the model&mdash;in statistician jargon, the <img class="formulaInl" alt="$p$" src="form_20.png"/>-value. [Type I error: odds of rejecting the null hypothesis when it is true.]</p>
<p>For example, </p>
<pre class="fragment">   apop_test(1.3);</pre><p>will return the density of the standard Normal distribution that is more than 1.3 from zero. If this function returns a small value, we can be confident that the statistic is significant. Or, </p>
<pre class="fragment">   apop_test(1.3, "t", 10, tail='u');</pre><p>will give the appropriate odds for an upper-tailed test using the <img class="formulaInl" alt="$t$" src="form_9.png"/>-distribution with 10 degrees of freedom (e.g., a <img class="formulaInl" alt="$t$" src="form_9.png"/>-test of the null hypothesis that the statistic is less than or equal to zero).</p>
<p>Several more distributions are supported; see below.</p>
<ul>
<li>For a two-tailed test (the default), this returns the density outside the range. I'll only do this for symmetric distributions. </li>
<li>For an upper-tail test ('u'), this returns the density above the cutoff </li>
<li>For a lower-tail test ('l'), this returns the density below the cutoff</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">statistic</td><td>The scalar value to be tested. </td></tr>
    <tr><td class="paramname">distribution</td><td>The name of the distribution; see below. </td></tr>
    <tr><td class="paramname">p1</td><td>The first parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">p2</td><td>The second parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">tail</td><td>'u' = upper tail; 'l' = lower tail; anything else = two-tailed. (default = two-tailed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The odds of a Type I error given the model (the <img class="formulaInl" alt="$p$" src="form_20.png"/>-value).</dd></dl>
<p>Here is a list of distributions you can use, and their parameters.</p>
<p><code>"normal"</code> or <code>"gaussian"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1)</li>
</ul>
<p><code>"lognormal"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1) </li>
<li>Remember, mu and sigma refer to the Normal one would get after exponentiation </li>
<li>One-tailed tests only</li>
</ul>
<p><code>"uniform"</code> </p>
<ul>
<li>p1=lower edge, p2=upper edge </li>
<li>default (0, 1) </li>
<li>two-tailed tests are run relative to the center, (p1+p2)/2.</li>
</ul>
<p><code>"t"</code> </p>
<ul>
<li>p1=df </li>
<li>no default</li>
</ul>
<p><code>"chi squared"</code>, <code>"chi"</code>, <code>"chisq"</code>: </p>
<ul>
<li>p1=df </li>
<li>no default </li>
<li>One-tailed tests only; default='u' ( <img class="formulaInl" alt="$p$" src="form_20.png"/>-value for typical cases)</li>
</ul>
<p><code>"f"</code> </p>
<ul>
<li>p1=df1, p2=df2 </li>
<li>no default </li>
<li>One-tailed tests only</li>
</ul>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a98ccaa9de7cb16e60a435c56eaf3400d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* apop_test_kolmogorov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the Kolmogorov-Smirnov test to determine whether two distributions are identical.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1,m2</td><td>Two models, most likely of <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> type. I will ue the cdf method, so if your function doesn't have one, expect this to run the slow default. I run it for each row of each data set, so if your model has a <code>NULL</code> at the data, I won't know what to do.</td></tr>
  </table>
  </dd>
</dl>
<p>I will also give special handling to two synced <a class="el" href="group__models.html#gafa54b2573ed0868774a9a78d07d07e62">apop_histograms</a> (probably produced via <a class="el" href="asst_8h.html#a47665d2c314071a572089137b95f36c5">apop_histogram_vector_reset</a> or <a class="el" href="asst_8h.html#ab99340f82c48dd858329ff9c48d437fd">apop_histogram_model_reset</a>), using the histogram bins to define how the CDF is built.</p>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set including the <img class="formulaInl" alt="$p$" src="form_20.png"/>-value from the Kolmogorov test that the two distributions are equal.</dd></dl>
<pre class="fragment"> apop_data_sort(data1);
 apop_data_sort(data2);
 apop_model *m1 = apop_estimate(data1, apop_pmf);
 apop_model *m2 = apop_estimate(data2, apop_pmf);
 apop_data *ktest = apop_test_kolmogorov(m1, m2);
 //The sort of output you could pull out:
 double k_statistic = apop_data_get(ktest, .rowname="max distance");
 double pval = apop_data_get(ktest, .rowname="p value, 2 tail");
 double confidence_of_inequality = apop_data_get(ktest, .rowname="confidence, 2 tail");</pre><ul>
<li>I assume that the data sets are sorted. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f64a390c945486f04975307a5f4b4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* apop_text_paste </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_riip&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prune_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join together a list or array of strings, with optional separators between the strings.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a grid of text to be combined into a single string </td></tr>
    <tr><td class="paramname">between</td><td>The text to put in between the rows of the table, such as ", ". (Default is a single space: " ") </td></tr>
    <tr><td class="paramname">before</td><td>The text to put at the head of the string. For the query example, this would be <code>.before="select "</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">after</td><td>The text to put at the tail of the string. For the query example, <code>.after=" from data_table"</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">between_cols</td><td>The text to insert between columns of text. See below for an example (Default is set to equal <code>.between</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A single string with the elements of the <code>strings</code> table joined as per your specification. Allocated by the function, to be freed by you if desired.</dd></dl>
<ul>
<li>If the table of strings is <code>NULL</code> or has no text, I will print only the <code>.before</code> and <code>.after</code> parts with nothing in between. </li>
<li>if <code> apop_opts.verbose &gt;=2</code>, then print the pasted text to stderr. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<p>The sample snippet generates the SQL for a query using a list of column names (where the query begins with <code>select </code>, ends with <code>from datatab</code>, and has commas in between each element), re-processes the same list to produce the head of an HTML table, then produces the body of the table with the query result (pasting the <code>tr</code>s and <code> td</code>s into the right places).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;apop.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;create table datatab(name, age, sex);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 23, &#39;m&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 32, &#39;f&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 41, &#39;f&#39;);&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 14, &#39;m&#39;);&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *cols = <a class="code" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 3, 1);</div>
<div class="line">    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 0, 0, <span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 1, 0, <span class="stringliteral">&quot;age&quot;</span>);</div>
<div class="line">    <a class="code" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 2, 0, <span class="stringliteral">&quot;sex&quot;</span>);</div>
<div class="line">    <span class="keywordtype">char</span> *query= <a class="code" href="apop__asst_8c.html#a98e7d8ea0621e231298d5ceee61a5dc1">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;select &quot;</span>, .between=<span class="stringliteral">&quot;, &quot;</span>);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__queries.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;%s from datatab&quot;</span>, query);</div>
<div class="line">    <span class="keywordtype">char</span> *html_head = <a class="code" href="apop__asst_8c.html#a98e7d8ea0621e231298d5ceee61a5dc1">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&quot;</span>,</div>
<div class="line">                                .between=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>, .after=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>);</div>
<div class="line">    <span class="keywordtype">char</span> *html_table = <a class="code" href="apop__asst_8c.html#a98e7d8ea0621e231298d5ceee61a5dc1">apop_text_paste</a>(d, .before=html_head, .after=<span class="stringliteral">&quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n&quot;</span>,</div>
<div class="line">                                .between=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>, .between_cols=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);</div>
<div class="line">    FILE *outfile = fopen(<span class="stringliteral">&quot;yourdata.html&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);                                                                                                                              fprintf(outfile, <span class="stringliteral">&quot;%s&quot;</span>, html_table);</div>
<div class="line">    fclose(outfile);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac7c0ddb63673ddd40ba69f7dc8bff800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* apop_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take in a prior and likelihood distribution, and output a posterior distribution.</p>
<p>This function first checks a table of conjugate distributions for the pair you sent in. If the names match the table, then the function returns a closed-form model with updated parameters. If the parameters aren't in the table of conjugate priors/likelihoods, then it uses Markov Chain Monte Carlo to sample from the posterior distribution, and then outputs a histogram model for further analysis. Notably, the histogram can be used as the input to this function, so you can chain Bayesian updating procedures.</p>
<p>To change the default settings (MCMC starting point, periods, burnin...), add an <a class="el" href="structapop__update__settings.html">apop_update_settings</a> struct to the prior.</p>
<ul>
<li>If the likelihood model no parameters, I will allocate them. That means you can use one of the stock models that ship with Apophenia. If I need to run the model's prep routine to get the size of the parameters, then I'll make a copy of the likelihood model, run prep, and then allocate parameters for that copy of a model.</li>
</ul>
<ul>
<li>Consider the state of the <code>parameters</code> element of your likelihood model to be undefined when this exits. This may be settled at a later date.</li>
</ul>
<p>Here are the conjugate distributions currently defined:</p>
<table class="doxtable">
<tr>
<td>Prior </td><td>Likelihood </td><td>Notes   </td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">Binomial</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">Bernoulli</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#ga76b45a5681d30906572263eeef35aeff">Exponential</a> </td><td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td>Gamma likelihood represents the distribution of <img class="formulaInl" alt="$\lambda^{-1}$" src="form_81.png"/>, not plain <img class="formulaInl" alt="$\lambda$" src="form_82.png"/>   </td></tr>
<tr>
<td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td>Assumes prior with fixed <img class="formulaInl" alt="$\sigma$" src="form_59.png"/>; updates distribution for <img class="formulaInl" alt="$\mu$" src="form_42.png"/>  </td></tr>
<tr>
<td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td><a class="el" href="group__models.html#ga9c67838a4761452cc2c9113557f2a070">Poisson</a> </td><td>Uses sum and size of the data  </td></tr>
</table>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data, that will be used by the likelihood function (default = <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">prior</td><td>The prior <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>draw</code> method. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">likelihood</td><td>The likelihood <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method (ll preferred). (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, already initialized (e.g., via <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>). (default: see <a class="el" href="autorng.html">Auto-allocated RNGs</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>an <a class="el" href="structapop__model.html">apop_model</a> struct representing the posterior, with updated parameters. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>The table of conjugate prior/posteriors (in its static <code>check_conjugacy</code> subfuction), is a little short, and can always be longer.</dd></dl>
<p>Here is a test function that compares the output via conjugate gradient table and via Gibbs sampling: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> test_updating(gsl_rng *r){</div>
<div class="line">    <span class="keywordtype">double</span> binom_start = 0.6;</div>
<div class="line">    <span class="keywordtype">double</span> beta_start_a = 0.3;</div>
<div class="line">    <span class="keywordtype">double</span> beta_start_b = 0.5;</div>
<div class="line">    <span class="keywordtype">int</span> i, draws = 1500;</div>
<div class="line">    <span class="keywordtype">double</span> n = 4000;</div>
<div class="line">    <span class="comment">//First, the easy estimation using the conjugate distribution table.</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *bin = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, binom_start);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *beta = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, beta_start_a, beta_start_b);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *updated = <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(.prior= beta, .likelihood=bin,.rng=r);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//Now estimate via Gibbs sampling. </span></div>
<div class="line">    <span class="comment">//Requires a one-parameter binomial, with n fixed,</span></div>
<div class="line">    <span class="comment">//and a data set of n data points with the right p.</span></div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *bcopy = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, GSL_NAN);</div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *bin_draws = <a class="code" href="types_8h.html#a4ed914f400ade913970ebbe698176218">apop_data_fill</a>(<a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(1,2), n*(1-binom_start), n*binom_start);</div>
<div class="line">    bin = <a class="code" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(bcopy);</div>
<div class="line">    apop_model_add_group(beta, <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>, .burnin=.1, .periods=1e4);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *out_h = <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(bin_draws, beta, bin, NULL);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//We now have a histogram of values for p. What&#39;s the closest beta</span></div>
<div class="line">    <span class="comment">//distribution?</span></div>
<div class="line">    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(0, draws, 1);</div>
<div class="line">    <span class="keywordflow">for</span>(i=0; i &lt; draws; i ++)</div>
<div class="line">        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga036a0ed6241af89643566086d5cb5373">apop_data_ptr</a>(d, i, 0), r, out_h);</div>
<div class="line">    <a class="code" href="structapop__model.html">apop_model</a> *out_beta = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(d, <a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>);</div>
<div class="line">    <span class="comment">//Finally, we can compare the conjugate and Gibbs results:</span></div>
<div class="line">    <a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);</div>
<div class="line">    <a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);</div>
<div class="line">    <span class="keywordtype">double</span> error = <a class="code" href="group__convenience__fns.html#gac3b9f35ed990dd35f34ba1f072da3dd5">apop_vector_grid_distance</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);</div>
<div class="line">    <span class="keywordtype">double</span> updated_size = <a class="code" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);</div>
<div class="line">    <a class="code" href="asst_8h.html#aa6760fa3f2e261b93aaf25d80a11375c">Apop_assert</a>(error/updated_size &lt; 0.01, <span class="stringliteral">&quot;The error is %g, which is too big.&quot;</span>, error/updated_size);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a61185af7877b709c8b257b342c24edbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_moving_average </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new vector that is the moving average of the input vector. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector, unsmoothed </td></tr>
    <tr><td class="paramname">bandwidth</td><td>The number of elements to be smoothed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb838084f967543fa8a03e460180d53b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* apop_vector_percentiles </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of size 101, where <code>returned_vector</code>[95] gives the value of the 95th percentile, for example. <code>Returned_vector</code>[100] is always the maximum value, and <code>returned_vector</code>[0] is always the min (regardless of rounding rule).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a gsl_vector of data. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rounding</td><td>This will either be 'u', 'd', or 'a'. Unless your data is exactly a multiple of 101, some percentiles will be ambiguous. If 'u', then round up (use the next highest value); if 'd' (or anything else), round down to the next lowest value; if 'a', take the mean of the two nearest points. If 'u' or 'a', then you can say "5% or more  of the sample is below \c returned_vector[5]"; if 'd' or 'a', then you can say "5% or more of the sample is above returned_vector[5]". (Default = 'd'.)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>You may eventually want to <code>free()</code> the array returned by this function. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Oct 8 2012.</div></body></html>
