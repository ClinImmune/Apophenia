<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.4 -->
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">apop_stats.c File Reference</div>  </div>
</div>
<div class="contents">
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>long double <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gac9d269f1dc62b038c0da72085cac1c28">apop_vector_skew</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gaebb237b320230c50b7569a805fc5bab7">apop_vector_skew_pop</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#ga3cc380538e85584710434da659d9f750">apop_vector_kurtosis_pop</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> (const gsl_vector *in, const double mean)
<li>double <a class="el" href="group__vector__moments.html#ga381f79a935cd436e32fa382db31932b5">apop_vector_cov</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>double <a class="el" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>double <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)
<li>double <a class="el" href="group__convenience__fns.html#gac3b9f35ed990dd35f34ba1f072da3dd5">apop_vector_grid_distance</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>void <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> (gsl_vector *in, gsl_vector **out, const char normalization_type)
<li>void <a class="el" href="apop__stats_8c.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> (gsl_matrix *data, const char row_or_col, const char normalization)
<li>long double <a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)
<li>double <a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *indata)
<li>double <a class="el" href="apop__stats_8c.html#ad141d1bf48aaed451964fefe7dd2be55">apop_vector_weighted_mean</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="apop__stats_8c.html#af287d7c166a17d35bcdce5e7c8515fce">apop_vector_weighted_var</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="apop__stats_8c.html#ab2c0cb715352abd662783b6f1bb4d84e">apop_vector_weighted_skew</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="apop__stats_8c.html#aca7a5cac76bd44584d88781c5b3cbb23">apop_vector_weighted_kurt</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="apop__stats_8c.html#a8378b4ca18cefbae9c4234585e1e9b6b">apop_vector_weighted_cov</a> (const gsl_vector *v1, const gsl_vector *v2, const gsl_vector *w)
<li>gsl_matrix * <a class="el" href="apop__stats_8c.html#a8ab4dde598ac3710072eb58384512153">apop_matrix_covariance</a> (gsl_matrix *in, const char normalize)
<li>gsl_matrix * <a class="el" href="apop__stats_8c.html#a46a40bc32015eb68e605835d82c3134b">apop_matrix_correlation</a> (gsl_matrix *in, const char normalize)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__stats_8c.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> (const <a class="el" href="struct__apop__data.html">apop_data</a> *in)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__stats_8c.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> (const <a class="el" href="struct__apop__data.html">apop_data</a> *in)
<li>double <a class="el" href="apop__stats_8c.html#a4489b3994f099ed40ccd77df6143728e">apop_kl_divergence</a> (<a class="el" href="struct__apop__model.html">apop_model</a> *top, <a class="el" href="struct__apop__model.html">apop_model</a> *bottom, int draw_ct, gsl_rng *rng)
<li>double <a class="el" href="apop__stats_8c.html#a463920325a6102396515d80e57e6c519">apop_multivariate_gamma</a> (double a, double p)
<li>double <a class="el" href="apop__stats_8c.html#a565a9c7bf2cb5b171cf0fce622d54bca">apop_multivariate_lngamma</a> (double a, double p)
<li>int <a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> (gsl_matrix *m, char semi)
<li><a class="anchor" id="afc6ff60871ebd99031ac8355e427ab60"></a><!-- doxytag: member="apop_stats.c::vfabs" ref="afc6ff60871ebd99031ac8355e427ab60" args="(double *x)" -->
void <b>vfabs</b> (double *x)
<li>double <a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> (gsl_matrix *m)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Basic moments and some distributions. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="afa3ab967f57f8ad3cfb99a4a82cfae02"></a><!-- doxytag: member="apop_stats.c::apop_data_correlation" ref="afa3ab967f57f8ad3cfb99a4a82cfae02" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_correlation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_65.png"/> relating each column with each other.</p>
<p>This is the <a class="el" href="gentle.html#apop_data">apop_data</a> version of <a class="el" href="stats_8h.html#a46a40bc32015eb68e605835d82c3134b">apop_matrix_correlation</a>; if you don't have column names or weights, (or want the option for the faster, data-destroying version), use that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. If you give me a weights vector, I'll use it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. </dd></dl>

</div>
</div>
<a class="anchor" id="aeae37a5bf11cddee59e272b083a4efc7"></a><!-- doxytag: member="apop_stats.c::apop_data_covariance" ref="aeae37a5bf11cddee59e272b083a4efc7" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_covariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variance/covariance matrix relating each column of the matrix to each other column.</p>
<p>This is the <a class="el" href="gentle.html#apop_data">apop_data</a> version of <a class="el" href="stats_8h.html#a8ab4dde598ac3710072eb58384512153">apop_matrix_covariance</a>; if you don't have column names or weights, or would like to use the speed-saving and data-destroying normalization option, use that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the weights vector is set, I'll take it into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set the variance/covariance matrix relating each column with each other. </dd></dl>

</div>
</div>
<a class="anchor" id="a4489b3994f099ed40ccd77df6143728e"></a><!-- doxytag: member="apop_stats.c::apop_kl_divergence" ref="a4489b3994f099ed40ccd77df6143728e" args="(apop_model *top, apop_model *bottom, int draw_ct, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_kl_divergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draw_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kullback-Leibler divergence.</p>
<p>This measure of the divergence of one distribution from another has the form <img class="formulaInl" alt="$ D(p,q) = \sum_i \ln(p_i/q_i) p_i $" src="form_66.png"/>. Notice that it is not a distance, because there is an asymmetry between <img class="formulaInl" alt="$p$" src="form_18.png"/> and <img class="formulaInl" alt="$q$" src="form_67.png"/>, so one can expect that <img class="formulaInl" alt="$D(p, q) \neq D(q, p)$" src="form_68.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">top</td><td>the <img class="formulaInl" alt="$p$" src="form_18.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">bottom</td><td>the <img class="formulaInl" alt="$q$" src="form_67.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">draw_ct</td><td>If I do the calculation via random draws, how many? (Default = 1e5) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>. If NULL, I'll take care of the RNG; see <a class="el" href="autorng.html">Auto-allocated RNGs</a>. (Default = <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function can take empirical histogram-type models---<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> and <a class="el" href="group__models.html#gafa54b2573ed0868774a9a78d07d07e62">apop_histogram</a> ---or continuous models like <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a> or <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>.</p>
<p>If there is an empirical model (I'll try <code>bottom</code> first, under the presumption that you are measuring the divergence of data from a `true' distribution), then I'll step through it for the points in the summation.</p>
<ul>
<li>If you have two empirical distributions, that they must be synced: if <img class="formulaInl" alt="$p_i>0$" src="form_69.png"/> but <img class="formulaInl" alt="$q_i=0$" src="form_70.png"/>, then the function returns <code>GSL_NEGINF</code>. If <code>apop_opts.verbose &gt;=1</code> I print a message as well.</li>
</ul>
<p>If neither distribution is empirical, then I'll take <code>draw_ct</code> random draws from <code>bottom</code> and evaluate at those points.</p>
<ul>
<li>Set <code>apop_opts.verbose = 3</code> for observation-by-observation info.</li>
</ul>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a46a40bc32015eb68e605835d82c3134b"></a><!-- doxytag: member="apop_stats.c::apop_matrix_correlation" ref="a46a40bc32015eb68e605835d82c3134b" args="(gsl_matrix *in, const char normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_correlation </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_65.png"/> relating each column with each other.</p>
<p>This is the <code>gsl_matrix</code> version of <a class="el" href="stats_8h.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a>; if you have column names, use that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">normalize</td><td>'n' or 'N' = subtract the mean from each column, thus changing the input data but speeding up the computation.<br/>
 anything else (like 0)= don't modify the input data (default = no modification)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a8ab4dde598ac3710072eb58384512153"></a><!-- doxytag: member="apop_stats.c::apop_matrix_covariance" ref="a8ab4dde598ac3710072eb58384512153" args="(gsl_matrix *in, const char normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* apop_matrix_covariance </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variance/covariance matrix relating each column with each other.</p>
<p>This is the <code>gsl_matrix</code> version of <a class="el" href="stats_8h.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a>; if you have column names, use that one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">normalize</td><td>'n', 'N', or 1 = subtract the mean from each column, thus changing the input data but speeding up the computation.<br/>
 anything else (like 0)= don't modify the input data (default = no modification)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. This is the sample version---dividing by <img class="formulaInl" alt="$n-1$" src="form_52.png"/>, not <img class="formulaInl" alt="$n$" src="form_8.png"/>. It uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="afc7707d44884aa63c298510a0662956a"></a><!-- doxytag: member="apop_stats.c::apop_matrix_is_positive_semidefinite" ref="afc7707d44884aa63c298510a0662956a" args="(gsl_matrix *m, char semi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apop_matrix_is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>semi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test whether the input matrix is positive semidefinite.</p>
<p>A covariance matrix will always be PSD, so this function can tell you whether your matrix is a valid covariance matrix.</p>
<p>Consider the 1x1 matrix in the upper left of the input, then the 2x2 matrix in the upper left, on up to the full matrix. If the matrix is PSD, then each of these has a positive determinant. This function thus calculates <img class="formulaInl" alt="$N$" src="form_3.png"/> determinants for an <img class="formulaInl" alt="$N$" src="form_3.png"/>x <img class="formulaInl" alt="$N$" src="form_3.png"/> matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to test. If <code>NULL</code>, I will return zero---not PSD. </td></tr>
    <tr><td class="paramname">semi</td><td>If anything but 's', check for positive definite, not semidefinite. (default 's')</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="stats_8h.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a>, which will change the input to something PSD.</p>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="af6290c453c3012c1d0a6987688ebe795"></a><!-- doxytag: member="apop_stats.c::apop_matrix_normalize" ref="af6290c453c3012c1d0a6987688ebe795" args="(gsl_matrix *data, const char row_or_col, const char normalization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_matrix_normalize </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>row_or_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize each row or column in the given matrix, one by one.</p>
<p>Basically just a convenience fn to iterate through the columns or rows and run <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> for you.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to normalize. </td></tr>
    <tr><td class="paramname">row_or_col</td><td>Either 'r' or 'c'. </td></tr>
    <tr><td class="paramname">normalization</td><td>see <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1fc93322ffcb4e20cfc0b9af9e2aea0"></a><!-- doxytag: member="apop_stats.c::apop_matrix_to_positive_semidefinite" ref="af1fc93322ffcb4e20cfc0b9af9e2aea0" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_matrix_to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First, this function passes tests, but is under development.</p>
<p>It takes in a matrix and converts it to the `closest' positive semidefinite matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>On input, any matrix; on output, a positive semidefinite matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the original and new matrices.</dd></dl>
<ul>
<li>See also the test function <a class="el" href="stats_8h.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a>. </li>
<li>This function can be used as (the core of) a model constraint.</li>
</ul>
<p>Adapted from the R Matrix package's nearPD, which is Copyright (2007) Jens Oehlschlägel [and is GPL]. </p>

</div>
</div>
<a class="anchor" id="a463920325a6102396515d80e57e6c519"></a><!-- doxytag: member="apop_stats.c::apop_multivariate_gamma" ref="a463920325a6102396515d80e57e6c519" args="(double a, double p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_multivariate_gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The multivariate generalization of the Gamma distribution. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_p(a)= \pi^{p(p-1)/4}\prod_{j=1}^p \Gamma\left[ a+(1-j)/2\right]. \]" src="form_73.png"/>
</p>
<p>Because <img class="formulaInl" alt="$\Gamma(x)$" src="form_74.png"/> is undefined for <img class="formulaInl" alt="$x\in\{0, -1, -2, ...\}$" src="form_75.png"/>, this function returns { GSL_NAN} when <img class="formulaInl" alt="$a+(1-j)/2$" src="form_76.png"/> takes on one of those values.</p>
<p>See also <a class="el" href="stats_8h.html#a565a9c7bf2cb5b171cf0fce622d54bca">apop_multivariate_lngamma</a>, which is more numerically stable in most cases. </p>

</div>
</div>
<a class="anchor" id="a565a9c7bf2cb5b171cf0fce622d54bca"></a><!-- doxytag: member="apop_stats.c::apop_multivariate_lngamma" ref="a565a9c7bf2cb5b171cf0fce622d54bca" args="(double a, double p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_multivariate_lngamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The log of the multivariate generalization of the Gamma; see also <a class="el" href="stats_8h.html#a463920325a6102396515d80e57e6c519">apop_multivariate_gamma</a>. </p>

</div>
</div>
<a class="anchor" id="a194ad92b1bc632ba1d13d9958c7b5b4d"></a><!-- doxytag: member="apop_stats.c::apop_vector_normalize" ref="a194ad92b1bc632ba1d13d9958c7b5b4d" args="(gsl_vector *in, gsl_vector **out, const char normalization_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_vector_normalize </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will normalize a vector, either such that it has mean zero and variance one, or such that it ranges between zero and one, or sums to one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A gsl_vector which you have already allocated and filled. <code>NULL</code> input gives <code>NULL</code> output. (No default)</td></tr>
    <tr><td class="paramname">out</td><td>If normalizing in place, <code>NULL</code>. If not, the address of a <code>gsl_vector</code>. Do not allocate. (default = <code>NULL</code>.)</td></tr>
    <tr><td class="paramname">normalization_type</td><td>'p': normalized vector will sum to one. E.g., start with a set of observations in bins, end with the percentage of observations in each bin. (the default)<br/>
 'r': normalized vector will range between zero and one. Replace each X with (X-min) / (max - min).<br/>
 's': normalized vector will have mean zero and variance one. Replace each X with <img class="formulaInl" alt="$(X-\mu) / \sigma$" src="form_62.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_63.png"/> is the sample standard deviation.<br/>
 'm': normalize to mean zero: Replace each X with <img class="formulaInl" alt="$(X-\mu)$" src="form_64.png"/><br/>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
gsl_vector  *in, *out;

in = gsl_vector_calloc(3);
gsl_vector_set(in, 1, 1);
gsl_vector_set(in, 2, 2);

printf(<span class="stringliteral">&quot;The original vector:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;s&#39;</span>);
printf(<span class="stringliteral">&quot;Standardized with mean zero and variance one:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;r&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized range with max one and min zero:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, NULL, <span class="charliteral">&#39;p&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized into percentages:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);
}
</pre></div><p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a8378b4ca18cefbae9c4234585e1e9b6b"></a><!-- doxytag: member="apop_stats.c::apop_vector_weighted_cov" ref="a8378b4ca18cefbae9c4234585e1e9b6b" args="(const gsl_vector *v1, const gsl_vector *v2, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_weighted_cov </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample covariance of a pair of weighted vectors. This only makes sense if the weightings are identical, so the function takes only one weighting vector for both.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>The data vectors </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample covariance </dd></dl>

</div>
</div>
<a class="anchor" id="aca7a5cac76bd44584d88781c5b3cbb23"></a><!-- doxytag: member="apop_stats.c::apop_vector_weighted_kurt" ref="aca7a5cac76bd44584d88781c5b3cbb23" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_weighted_kurt </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the population kurtosis of a weighted vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted kurtosis. No sample adjustment given weights. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><code>apop_vector_weighted_skew</code> and <code>apop_vector_weighted_kurt</code> are lazily written. </dd></dl>

</div>
</div>
<a class="anchor" id="ad141d1bf48aaed451964fefe7dd2be55"></a><!-- doxytag: member="apop_stats.c::apop_vector_weighted_mean" ref="ad141d1bf48aaed451964fefe7dd2be55" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_weighted_mean </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the weighted mean.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted mean </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c0cb715352abd662783b6f1bb4d84e"></a><!-- doxytag: member="apop_stats.c::apop_vector_weighted_skew" ref="ab2c0cb715352abd662783b6f1bb4d84e" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_weighted_skew </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the population skew of a weighted vector.</p>
<p>Note: Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_52.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_8.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted skew. No sample adjustment given weights. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd><code>apop_vector_weighted_skew</code> and <code>apop_vector_weighted_kurt</code> are lazily written. </dd></dl>

</div>
</div>
<a class="anchor" id="af287d7c166a17d35bcdce5e7c8515fce"></a><!-- doxytag: member="apop_stats.c::apop_vector_weighted_var" ref="af287d7c166a17d35bcdce5e7c8515fce" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apop_vector_weighted_var </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample variance of a weighted vector.</p>
<p>Note: Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_52.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_8.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample variance. </dd></dl>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Fri Mar 2 2012.</div></body></html>
