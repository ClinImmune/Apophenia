<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>
<!-- Generated by Doxygen 1.8.1.1 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implementation of optional arguments </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Optional and named arguments are among the most commonly commented-on features of Apophenia, so this page goes into full detail about the implementation.</p>
<p>To use these features, see the all-you-really-need summary at the <a class="el" href="designated.html">Designated initializers</a> page. For a background and rationale, see the blog entry at <a href="http://modelingwithdata.org/arch/00000022.htm">http://modelingwithdata.org/arch/00000022.htm</a> .</p>
<p>I'll assume you've read both links before continuing.</p>
<p>OK, now that you've read the how-to-use and the discussion of how optional and named arguments can be constructed in C, this page will show how they are done in Apophenia. The level of details should be sufficient to implement them in your own code if you so desire.</p>
<p>There are three components to the process of generating optional arguments as implemented here: </p>
<ul>
<li>Produce a <code>struct</code> whose elements match the arguments to the function. </li>
<li>Write a wrapper function that takes in the struct, unpacks it, and calls the original function. </li>
<li>Write a macro that makes the user think the wrapper function is the real thing.</li>
</ul>
<p>None of these steps are really rocket science, but there is a huge amount of redundancy. Apophenia includes some macros that reduce the boilerplate redundancy significantly. There are two layers: the C-standard code, and the script that produces the C-standard code.</p>
<p>We'll begin with the C-standard header file: </p>
<pre class="fragment">#ifdef APOP_NO_VARIADIC
 void apop_vector_increment(gsl_vector * v, int i, double amt);
#else
 void apop_vector_increment_base(gsl_vector * v, int i, double amt);
 apop_varad_declare(void, apop_vector_increment, gsl_vector * v; int i; double amt);
#define apop_vector_increment(...) apop_varad_link(apop_vector_increment, __VA_ARGS__)
#endif
</pre><p>First, there is an if/else that allows the system to degrade gracefully if you are sending C code to a parser like swig, whose goals differ too much from straight C compilation for this to work. Just set <code>APOP_NO_VARIADIC</code> to produce a plain function with no variadic support.</p>
<p>Else, we begin the above steps. The <code>apop_varad_declare</code> line expands to the following:</p>
<pre class="fragment">typedef struct { 
    gsl_vector * v; int i; double amt ; 
} variadic_type_apop_vector_increment; 

void variadic_apop_vector_increment(variadic_type_apop_vector_increment varad_in);</pre><p>So there's the ad-hoc struct and the declaration for the wrapper function. Notice how the arguments to the macro had semicolons, like a struct declaration, rather than commas, because the macro does indeed wrap the arguments into a struct.</p>
<p>Here is what the <code>apop_varad_link</code> would expand to: </p>
<pre class="fragment">#define apop_vector_increment(...) variadic_apop_increment_base((variadic_type_apop_vector_increment) {__VA_ARGS__})</pre><p> That gives us part three: a macro that lets the user think that they are making a typical function call with a set of arguments, but wraps what they type into a struct.</p>
<p>Now for the code file where the function is declared. Again, there is is an <code>APOP_NO_VARIADIC</code> wrapper. Inside the interesting part, we find the wrapper function to unpack the struct that comes in.</p>
<pre class="fragment">\#ifdef APOP_NO_VARIADIC 
 void apop_vector_increment(gsl_vector * v, int i, double amt){
\#else
apop_varad_head( void , apop_vector_increment){
    gsl_vector * apop_varad_var(v, NULL);
    Apop_assert(v, "You sent me a NULL vector.");
    int apop_varad_var(i, 0);
    double apop_varad_var(amt, 1);
    apop_vector_increment_base(v, i, amt);
}

 void apop_vector_increment_base(gsl_vector * v, int i, double amt){
#endif
	v-&gt;data[i * v-&gt;stride]	+= amt;
}
</pre><p>The <code>apop_varad_head</code> macro just reduces redundancy, and will expand to </p>
<pre class="fragment">void variadic_apop_vector_increment (variadic_type_variadic_apop_vector_increment varad_in)
</pre><p>The function with this header thus takes in a single struct, and for every variable, there is a line like </p>
<pre class="fragment">    double apop_varad_var(amt, 1);
</pre><p> which simply expands to: </p>
<pre class="fragment">    double amt = varad_in.amt ? varad_in.amt : 1;
</pre><p> Thus, the macro declares each not-in-struct variable, and so there will need to be one such declaration line for each argument. Apart from requiring declarations, you can be creative: include sanity checks, post-vary the variables of the inputs, unpack without the macro, and so on. That is, this parent function does all of the bookkeeping, checking, and introductory shunting, so the base function can just do the math. Finally, the introductory section will call the base function.</p>
<p>The setup goes out of its way to leave the <code>_base</code> function in the public namespace, so that those who would prefer speed to bounds-checking can simply call that function directly, using standard notation. You could eliminate this feature by just merging the two functions.</p>
<p><b>The sed script</b></p>
<p>The above is all you need to make this work: the varad.h file, and the above structures. But there is still a lot of redundancy, which can't be eliminated by the plain C preprocessor.</p>
<p>Thus, in Apophenia's code base (the one you'll get from checking out the git repository, not the gzipped distribution that has already been post-processed) you will find a pre-preprocessing script that converts a few markers to the above form. Here is the code that will expand to the above C-standard code:</p>
<pre class="fragment">//header file
APOP_VAR_DECLARE void apop_vector_increment(gsl_vector * v, int i, double amt);

//code file
APOP_VAR_HEAD void apop_vector_increment(gsl_vector * v, int i, double amt){
    gsl_vector * apop_varad_var(v, NULL);
    Apop_assert(v, "You sent me a NULL vector.");
    int apop_varad_var(i, 0);
    double apop_varad_var(amt, 1);
APOP_VAR_END_HEAD
	v-&gt;data[i * v-&gt;stride]	+= amt;
}
</pre><p>It is obviously much shorter. The declaration line is actually a C-standard declaration with the <code>APOP_VAR_DECLARE</code> preface, so you don't have to remember when to use semicolons. The function itself looks like a single function, but there is again a marker before the declaration line, and the introductory material is separated from the main matter by the <code>APOP_VAR_END_HEAD</code> line. Done right, drawing a line between the introductory checks or initializations and the main function can really improve readability.</p>
<p>The sed script inserts a <code>return function_base(...)</code> at the end of the header function, so you don't have to. If you want to call the funtion before the last line, you can do so explicitly, as in the expansion above, and add a bare <code>return;</code> to guarantee that the call to the base function that the sed script will insert won't ever be reached.</p>
<p>One final detail: it is valid to have types with commas in them&mdash;function arguments. Because commas get turned to semicolons, and sed isn't a real parser, there is an exception built in: you will have to replace commas with exclamation marks in the header file (only). E.g.,</p>
<pre class="fragment">APOP_VAR_DECLARE apop_data * f_of_f(apop_data *in, void *param, int n, double (*fn_d)(double ! void * !int));
</pre><p>Sed is POSIX standard, so even if you can't read the script, you have the program needed to run it. For example, if you name it <code>prep_variadics.sed</code>, then run </p>
<pre class="fragment">./prep_variadics.sed &lt; myfile.pre.c &gt; myfile.c
</pre> </div></div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Oct 8 2012.</div></body></html>
