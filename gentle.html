<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>
     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="../index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.3 -->
</div>
<div class="header">
  <div class="headertitle">
<h1>A quick overview </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This is a "gentle introduction" to the Apophenia library. It is intended to give you some initial bearings on the typical workflow and the concepts and tricks that the manual pages assume you have met.</p>
<p>This introduction assumes you already have some familiarity with C, how to compile a program, and how to use a debugger.</p>
<p>An outline of this overview:</p>
<ul>
<li>Apophenia fills a space between traditional C libraries and stats packages. </li>
<li>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure represents a data set (of course). Data sets are inherently complex, but there are many functions that act on <a class="el" href="gentle.html#apop_data">apop_data</a> sets to make life easier. </li>
<li>The <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> encapsulates the sort of actions one would take with a model, like estimating model parameters or predicting values based on new inputs. </li>
<li>Databases are great, and a perfect fit for the sort of paradigm here. Apophenia provides functions to make it easy to jump between database tables and <a class="el" href="gentle.html#apop_data">apop_data</a> sets.</li>
</ul>
<dl class="user"><dt><b>The opening example</b></dt><dd></dd></dl>
<p>To my knowledge, Apophenia is the only open source system for doing statistical analysis that is not a walled-garden stats package. Its data structures, syntax, and use reflect its unique position.</p>
<p>You could use Apophenia for simple stats-package--like fitting of models, where the user gathers data, cleans it, and runs a series of regressions. Or you could use the library as input to the design of other systems, like fitting a model and then using the fitted model to generate agents in your simulation, or designing hierarchical models built from simpler base models. You will see below that Apophenia provides many of the conveniences that stats package users are used to in simply fitting a model, while still being structured in a manner that facilitates and encourages building new types of model.</p>
<p>The workflow of a typical fitting-a-model project using Apophenia's tools goes something like this:</p>
<ul>
<li>Read the raw data into the database using <a class="el" href="group__conversions.html#ga054d7123f2c801c06a2d1f00f35e7fe2">apop_text_to_db</a>. </li>
<li>Use SQL queries handled by <a class="el" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a> to massage the data as needed. </li>
<li>Use <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> to pull some of the data into an in-memory <a class="el" href="gentle.html#apop_data">apop_data</a> set. </li>
<li>Call a model estimation such as <div class="fragment"><pre class="fragment"> <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> (data_set, <a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>)
</pre></div> or <div class="fragment"><pre class="fragment"> <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> (data_set, <a class="code" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a>)
</pre></div> to fit parameters to the data. This will return an <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> with parameter estimates. </li>
<li>Interrogate the returned estimate, by dumping it to the screen with <a class="el" href="apop__model_8c.html#a4fa08e29db38e8dcc111899c942022d9">apop_model_show</a>, sending its parameters and variance-covariance matrices to additional tests (the <code>estimate</code> step runs a few for you), or send the model's output to be input to another model.</li>
</ul>
<p>Here is a concrete example of most of the above steps, which you can compile and run. By the time you get to the end of this introduction, you will have a good idea of what every line of code is doing and why.</p>
<p>The program: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
    <a class="code" href="group__conversions.html#ga054d7123f2c801c06a2d1f00f35e7fe2">apop_text_to_db</a>(.text_file=<span class="stringliteral">&quot;data&quot;</span>, .tabname=<span class="stringliteral">&quot;d&quot;</span>);
    <a class="code" href="struct__apop__data.html">apop_data</a> *data = <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;select * from d&quot;</span>);
    <a class="code" href="struct__apop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(data, <a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>);
    <a class="code" href="apop__model_8c.html#a4fa08e29db38e8dcc111899c942022d9">apop_model_show</a>(est);
}
</pre></div><p>To run this, you will need a file named <code>data</code> in comma-separated form. The first column is the dependent variable; the remaining columns are the independent: </p>
<div class="fragment"><pre class="fragment">
Y, X_1, X_2, X_3
2,3,4,5
1,2,9,3
4,7,9,0
2,4,8,16
1,4,2,9
9,8,7,6
</pre></div><p>If you saved the code to <code>sample.c</code>, then you can compile it with </p>
<div class="fragment"><pre class="fragment">
gcc sample.c -std=gnu99 -lapophenia -lgsl -lgslcblas -lsqlite3 -o run_me
</pre></div><p>and then run it with <code>./run_me</code>. This compile line will work on any system with all the requisite tools, but for full-time work with this or any other C library, you will probably want to write a <a class="el" href="makefile.html">Makefile</a> .</p>
<p>The results should be unremarkable---this is just an ordinary regression on too few data points---but it does give us some lines of code to dissect.</p>
<p>The first two lines in <code>main()</code> make use of a database. I'll discuss the value of the database step more at the end of this page, but for now, note that there are there are several functions, <a class="el" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>, and <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a> being the ones you will most frequently be using, that will allow you to talk to and pull data from either an SQLite or mySQL database.</p>
<dl class="user"><dt><b>Designated initializers</b></dt><dd></dd></dl>
<p>If anything, this line in the above sample program---</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__conversions.html#ga054d7123f2c801c06a2d1f00f35e7fe2">apop_text_to_db</a>(.text_file=<span class="stringliteral">&quot;data&quot;</span>, .tabname=<span class="stringliteral">&quot;d&quot;</span>);
</pre></div><p>---demonstrates Apophenia's intent to balance the traditional stats package with the C library. Most C code doesn't implement variable-length argument lists or named arguments, though its only real drawback is that it bucks tradition. But this form of function appears often in the Apophenia library. It makes coding easier, less error-prone, and more pleasant.</p>
<p>To give another example, the <a class="el" href="gentle.html#apop_data">apop_data</a> set has the usual row and column numbers, but also row and column names. So you should be able to refer to a cell by any combination of name or number; for the data set you read in above, which doesn't have row names but does have column names, all of the following work:</p>
<div class="fragment"><pre class="fragment">x = <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(data, 2, 3); <span class="comment">//x == 0</span>
x = <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(data, .row=2, .colname=<span class="stringliteral">&quot;X_3&quot;</span>); <span class="comment">// x == 0</span>
<a class="code" href="group__data__set__get.html#gaef6b2716da81f7d35765dc4ace8a6759">apop_data_set</a>(data, 2, 3, 18);
<a class="code" href="group__data__set__get.html#gaef6b2716da81f7d35765dc4ace8a6759">apop_data_set</a>(data, .colname=<span class="stringliteral">&quot;X_3&quot;</span>, .row=2, .val= 18);
</pre></div><p><a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> offers another nice example of the utility of this mechanism.</p>
<p>Those of you coming from stats packages will enjoy working in C without having to give up all the conveniences of stats packages, such as the awesomeness of not having to think about arguments that will take their default value. C traditionalists may be surprised by this unfamiliar form, but can rest assured that the Apophenia internals build this with entirely standards-compliant C. Everybody can see the <a class="el" href="designated.html">Designated initializers</a> page for details.</p>
<h2><a class="anchor" id="apop_data"></a>
apop_data</h2>
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> set naturally represents a data set. It turns out that a lot of real-world data processing is about quotidian annoyances about text versus numeric data or dealing with missing values, and the the <a class="el" href="gentle.html#apop_data">apop_data</a> set and its many support functions are intended to make data processing in C easy.</p>
<p>The structure basically includes six parts:</p>
<ul>
<li>a vector </li>
<li>a matrix </li>
<li>a grid of text elements </li>
<li>a vector of weights </li>
<li>names for everything: row names, a vector name, matrix column names, text names. </li>
<li>a link to a second page of data</li>
</ul>
<p>This is not a generic and abstract ideal, but is really the sort of mess that data sets look like. For example, here is some dummy data for a weighted OLS regression. It includes an outcome variable in the vector, dependent variables in the matrix and text grid, replicate weights, and column names in bold labeling the variables:</p>
<table  frame="box">
<tr>
<td>Rowname</td><td>Vector</td><td>Matrix</td><td>Text</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"><table  frame="box">
<tr>
<td></td></tr>
<tr>
<td>"Steven" </td></tr>
<tr>
<td>"Sandra" </td></tr>
<tr>
<td>"Joe"</td><td></td></tr>
</table>
</td><td align="center"><table  frame="box">
<tr>
<th>Outcome  </th></tr>
<tr>
<td align="center">1 </td></tr>
<tr>
<td align="center">0 </td></tr>
<tr>
<td align="center">1  </td></tr>
</table>
</td><td align="center"><table  frame="box">
<tr>
<th>Age</th><th>Weight (kg)</th><th>Height (cm)  </th></tr>
<tr>
<td>32</td><td>65</td><td>175 </td></tr>
<tr>
<td>41</td><td>61</td><td>165 </td></tr>
<tr>
<td>40</td><td>73</td><td>181  </td></tr>
</table>
</td><td align="center"><table  frame="box">
<tr>
<th>Sex</th><th>State  </th></tr>
<tr>
<td>Male</td><td>Alaska</td><td></td></tr>
<tr>
<td>Female</td><td>Alabama </td></tr>
<tr>
<td>Male</td><td>Alabama  </td></tr>
</table>
</td><td align="center"><table  frame="box">
<tr>
<td></td></tr>
<tr>
<td>1 </td></tr>
<tr>
<td>3.2 </td></tr>
<tr>
<td>2.4  </td></tr>
</table>
</td></tr>
</table>
<p>As per the example above, Apophenia will generally assume that one row across all of these elements describes a single observation or data point.</p>
<p>Also, <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a> and <a class="el" href="group__data__set__get.html#gaef6b2716da81f7d35765dc4ace8a6759">apop_data_set</a> consider the vector to be the -1st column, so using the data set in the figure, <a class="el" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a><code>(sample_set, .row=0, .col=-1) == 1</code>.</p>
<dl class="user"><dt><b>Reading in data</b></dt><dd></dd></dl>
<p>As per the example, use <a class="el" href="group__conversions.html#gab733686e945987662318425d2e158191">apop_text_to_data</a> or <a class="el" href="group__conversions.html#ga054d7123f2c801c06a2d1f00f35e7fe2">apop_text_to_db</a> and then <a class="el" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>.</p>
<dl class="user"><dt><b>Subsets</b></dt><dd></dd></dl>
<p>There are many macros to get subsets of the data. Each generates what is considered to be a disposable view: once the variable goes out of scope (by the usual C rules of scoping), it is no longer valid. However, these structures are all wrappers for pointers to the base data, so all operations on the data view affect the base data.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
  <a class="code" href="struct__apop__data.html">apop_data</a> *d = <a class="code" href="group__conversions.html#gab733686e945987662318425d2e158191">apop_text_to_data</a>(<span class="stringliteral">&quot;data&quot;</span>);

  <span class="comment">//tally row zero of the data set&#39;s matrix by viewing it as a vector:</span>
  <a class="code" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a>(d, 0, one_row);
  <span class="keywordtype">double</span> sigma = <a class="code" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(one_row);
  printf(<span class="stringliteral">&quot;Sum of the first row: %g\n&quot;</span>, sigma);

  <span class="comment">//view the first column as a vector; take its mean</span>
  <a class="code" href="stats_8h.html#a79fc915cc70adb705029a8b9322abd7d">Apop_col</a>(d, 0, one_col);
  <span class="keywordtype">double</span> mu = <a class="code" href="group__vector__moments.html#ga92c6abe8ada7ed8121c6881bcc6daf93">apop_vector_mean</a>(one_col);
  printf(<span class="stringliteral">&quot;Mean of the first col: %g\n&quot;</span>, mu);

  <span class="comment">//get a sub-data set of rows 3 through 8; print to screen</span>
  <a class="code" href="stats_8h.html#a922aeef48df4a7fcc78831719212726c">Apop_data_rows</a>(d, 3, 8, six_elmts);
  <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(six_elmts);
}
</pre></div><p>As noted, all of these slicing routines are macros, because they generate several background variables in the current scope (something a function can't do). Traditional custom is to put macro names in all caps, like <code>APOP_DATA_ROWS</code>, which to modern sensibilities looks like yelling. The custom has a logic: there are ways to hang yourself with macros, so it is worth distinguishing them typographically. Apophenia lets you choose the level of careful/pedantic you prefer: any of <code>APOP_ROW</code>, <code>Apop_row</code>, or <code>apop_row</code> are valid. The documentation always uses a single capital.</p>
<p>Notice that all of the slicing macros return nothing, so there is nothing to do with one but put it on a line by itself. This limits the number of misuses.</p>
<dl class="user"><dt><b>Basic manipulations</b></dt><dd></dd></dl>
<p>The outline page (which you can get to via a link next to the snowflake header at the top of every page on this site) lists a number of other manipulations of data sets, such as <a class="el" href="asst_8h.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> for quick-and-dirty removal of observations with <code>NaN</code>s, <a class="el" href="types_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> / <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> to cleave apart or cleave together data sets, or <a class="el" href="asst_8h.html#aa552a19d3b609864ea7a3e71c5ad13ac">apop_data_sort</a> to sort all elements by a single column.</p>
<dl class="user"><dt><b>Apply and map</b></dt><dd></dd></dl>
<p>If you have an operation of the form <em>for each element of my data set, call this function</em>, then you can use <a class="el" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a> to do it. You could basically do everything you can do with an apply/map function via a <code>for</code> loop, but the apply/map approach is clearer and more fun. Also, if you set the global <code>apop_opts.thread_count = n</code> for any <code>n</code> greater than 1, then the work of mapping will be split across multiple CPU threads. See the outline <img class="formulaInl" alt="$>$" src="form_27.png"/> data sets <img class="formulaInl" alt="$>$" src="form_27.png"/> map/apply section for a number of examples.</p>
<dl class="user"><dt><b>Text</b></dt><dd></dd></dl>
<p>Text in C is annoying. C already treats strings as pointer-to-characters, so a grid of text data is a pointer-to-pointer-to-pointer-to-character, which is as confusing as can be.</p>
<p>The text grid in the <a class="el" href="gentle.html#apop_data">apop_data</a> structure actually takes this form, but functions are provided so that most or all the pointer work is handled for you. The <a class="el" href="types_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> function is really a realloc function: you can use it to resize the text grid as necessary. The <a class="el" href="types_8h.html#a40ccb3d6e5ee93b0300d92784e3d9a6a">apop_text_add</a> function will do the pointer work in copying a single string to the grid. Functions that act on entire data sets, like <a class="el" href="apop__data_8c.html#aaff5f940f77fe79a03b25d3a98d556d0">apop_data_rm_rows</a>, handle the text part as well.</p>
<p>For reading individual elements, refer to the <img class="formulaInl" alt="$(i,j)$" src="form_95.png"/>th text element via <code>your_data-&gt;text[i][j]</code>.</p>
<dl class="user"><dt><b>The whole structure</b></dt><dd></dd></dl>
<p>In case you're wondering, here is a diagram of all of Apophenia's structures and how they relate. It is taken from this <a href="http://modelingwithdata.org/pdfs/cheatsheet.pdf">cheat sheet</a> (2 page PDF), which will be useful to you if only because it lists some of the functions that act on GSL vectors and matrices that are useful (in fact, essential) but out of the scope of the Apophenia documentation.</p>
<div align="center">
<img src="http://apophenia.sourceforge.net/doc/structs.png" alt="structs.png"/>
</div>
 <p>All of the elements of the <a class="el" href="gentle.html#apop_data">apop_data</a> structure are laid out at middle-left. You have already met the vector, matrix, and weights, which are all a <code>gsl_vector</code> or <code>gsl_matrix</code>.</p>
<p>The diagram shows the <a class="el" href="structapop__name.html">apop_name</a> structure, which has received little mention so far because names basically take care of themselves. Just use <a class="el" href="types_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a> to add names to your data set and <a class="el" href="types_8h.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> to copy from one data set to another.</p>
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure has a <code>more</code> element, for when your data is best expressed in more than one page of data. Use <a class="el" href="types_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a>, <a class="el" href="types_8h.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a>, and <a class="el" href="types_8h.html#ab7e7e7ca41b68af571d61b874ea388be">apop_data_get_page</a>. Output routines will sometimes append an extra page of auxiliary information to a data set, such as pages named <code>&lt;Covariance&gt;</code> or <code>&lt;Factors&gt;</code>. The angle-brackets indicate a page that describes the data set but is not a part of it (so an MLE search would ignore that page, for example).</p>
<p>Now let us move up the structure diagram to the <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> structure.</p>
<h2><a class="anchor" id="gentle_model"></a>
apop_model</h2>
<p>Even restricting ourselves to the most basic operations, there are a lot of things that we want to do with our models: estimating the parameters of a model (like the mean and variance of a Normal distribution) from data, or drawing random numbers, or showing the expected value, or showing the expected value of one part of the data given fixed values for the rest of it. The <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> is intended to encapsulate most of these desires into one object, so that models can easily be swapped around, modified to create new models, compared, and so on.</p>
<p>From the figure above, you can see that the <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> structure is pretty big, including a number of informational items, key being the <code>parameters</code>, <code>data</code>, and <code>info</code> elements, a list of settings to be discussed below, and a set of procedures for many operations. Its contents are not (entirely) arbitrary: the theoretical basis for what is and is not included in an <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a>, as well as its overall intent, are described in this <a href="http://ben.klemens.org/klemens-model_objects.pdf">academic paper</a>.</p>
<p>But now that you've seen the internals, note that there are helper functions that will use those internals; you can call the helper functions and never think about the internals as a model user. For example, the <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> helper function means you never have to look at the model's <code>estimate</code> method (if it even has one), and you will simply pass the model to a function, as with the above form:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__apop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(data, <a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>);
</pre></div><ul>
<li>Apophenia ships with a broad set of models, like <a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>, <a class="el" href="group__models.html#ga3199e483f340d6cedaa6488565c42c78">apop_dirichlet</a>, <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a>, and <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> (probability mass function). You would estimate the parameters of any of them using the form above, with the appropriate model in the second slot of the <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> call. </li>
<li>The models that ship with Apophenia, like <a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>, include the procedures and some metadata, but are of course not yet estimated using a one data set (i.e., <code>parameters == NULL</code>). The line above generated a new model, <code>est</code>, which is identical to the base OLS model but has estimated parameters (and covariances, and basic hypothesis tests, a log likelihood, AIC, BIC, et cetera). </li>
<li>You will mostly use the models by passing them as inputs to functions like <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>, <a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>, or <a class="el" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a>; more examples below. After <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>, most require a parameterized model like <code>est</code>. After all, it doesn't make sense to draw from a Normal distribution until you've specified its mean and standard deviation. </li>
<li>You can use <a class="el" href="apop__model_8c.html#a4fa08e29db38e8dcc111899c942022d9">apop_model_show</a> to print the various elements to screen. </li>
<li>Writing your own models won't be covered in this introduction, but it can be pretty easy to copy and modify the procedures of an existing model to fit your needs. When in doubt, delete a procedure, because any procedures that are missing will have defaults filled when used by functions like <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> (which uses <a class="el" href="group__mle.html#ga29975e75eec9ff9f48e836971a32c925">apop_maximum_likelihood</a>) or <a class="el" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> (which uses integration via random draws). </li>
<li>There's a simple rule of thumb for remembering the order of the arguments to most of Apophenia's functions, including <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a> : the data comes first.</li>
</ul>
<dl class="user"><dt><b>Settings</b></dt><dd></dd></dl>
<p>Every model, and every method one would apply to a model, is prone to have a list of settings: how many bins in the histogram, at what tolerance does the maximum likelihood search end, what percent of the Gibbs sampling run should be thrown out as a burn-in period. These can become an overwhelming mess if not controlled.</p>
<p>Apophenia organizes settings in settings groups, which are then attached to models. In the following snippet, we specify a Beta distribution prior, and attach a settings group to it with information about how Bayesian updating should be done with this specific copy of the Beta. For a likelihood, we generate an empirical distribution---a PMF---from an input data set; you will often use the <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> to turn a data set into an distribution. When we call <a class="el" href="asst_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> on the last line, it already has all of the above info on hand.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__model.html">apop_model</a> *beta = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, 0.5, 0.25);
<a class="code" href="group__settings.html#ga553b02de4ace5e6f16a8b26da777f9b9">Apop_model_add_group</a>(beta, <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>, .burnin = 0.2, .periods =1e5);
<a class="code" href="struct__apop__model.html">apop_model</a> *my_pmf = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(your_data, <a class="code" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>);
<a class="code" href="struct__apop__model.html">apop_model</a> *posterior = <a class="code" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(.prior= beta, .likelihood = my_pmf);
</pre></div><p>You will encounter model settings often when doing nontrivial work with models. All can be set using a form like above, and each settings group has a reference page to give you the full list of options. There is a full discussion of settings groups on the outline page under the Models heading.</p>
<dl class="user"><dt><b>Databases and models</b></dt><dd></dd></dl>
<p>Returning to the introductory example, you saw that (1) the library expects you to keep your data in a database, pulling out the data as needed, and (2) that the workflow is built around <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> structures.</p>
<p>Starting with (2), if a stats package has something called a <em>model</em>, then it is probably of the form Y = [an additive function of <b>X</b>], such as <img class="formulaInl" alt="$y = x_1 + \log(x_2) + x_3^2$" src="form_96.png"/>. Trying new models means trying different functional forms for the right-hand side, such as including <img class="formulaInl" alt="$x_1$" src="form_97.png"/> in some cases and excluding it in others. Conversely, Apophenia is designed to facilitate trying new models in the broader sense of switching out a linear model for a hierarchical, or a Bayesian model for a simulation. A formula syntax makes little sense over such a broad range of models.</p>
<p>As a result, the right-hand side is not part of the <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a>. Instead, the data is assumed to be correctly formatted, scaled, or logged before being passed to the model. This is where part (1), the database, comes in, because it provides a proxy for the sort of formula specification language above: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> *testme= <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;select y, x1, log(x2), pow(x3,2) from data&quot;</span>);
<a class="code" href="struct__apop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(testme, <a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>);
</pre></div><p>Generating factors and dummies is also considered data prep, not model internals. See <a class="el" href="stats_8h.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> and <a class="el" href="deprecated_8h.html#a3771d1cda273eade98c4fa6ddb7d8c3d">apop_text_to_factors</a>.</p>
<p>Now that you have <code>est</code>, an estimated model, you can interrogate it. This is really where Apophenia and its encapsulated model objects shine, because you can do more than just admire the parameter estimates on the screen: you can take your estimated data set and fill in or generate new data, use it as an input to the parent distribution of a hierarchical model, et cetera. Some simple examples:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//If you have a new data set, you can fill in predicted values:</span>
<a class="code" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a>(new_data_set, est);
<a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(new_data_set)

 <span class="comment">//Fill a matrix with random draws. The draw function needs an RNG from</span>
 <span class="comment">//the GNU Scientific Library, and a pointer-to-double.</span>
gsl_rng *r = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(218);
for (<span class="keywordtype">int</span> i=0; i&lt; matrix-&gt;size1; i++){
    <a class="code" href="stats_8h.html#acb72baab9748cb810584df0096397209">Apop_matrix_col</a>(matrix, i, one_col);
    <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(one_col-&gt;data, r, est);
}
</pre></div><dl class="user"><dt><b>Testing</b></dt><dd></dd></dl>
<p>Here is the model for all testing within Apophenia:</p>
<ul>
<li>Calculate a statistic. </li>
<li>Describe the distribution of that statistic. </li>
<li>Work out how much of the distribution is (above|below|closer to zero than) the statistic.</li>
</ul>
<p>There are a handful of named tests that produce a known statistic and then compare to a known distribution, like <a class="el" href="asst_8h.html#a98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a> or <a class="el" href="stats_8h.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a>. For traditional distributions (Normal, <img class="formulaInl" alt="$t$" src="form_9.png"/>, <img class="formulaInl" alt="$\chi^2$" src="form_17.png"/>), use the <a class="el" href="asst_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> convenience function.</p>
<p>But if you've gotten this far with your models, then you'll want to apply the above three-step process to your model parameters. First I'll give an overview of the three steps, then another working example.</p>
<ul>
<li>Model parameters are a statistic, and you know that <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a><code>(your_data, your_model)</code> will output a model with a <code>parameters</code> element. </li>
<li>Now, the distribution of a parameter is also a model, so <a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> will also return an <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a>. </li>
<li><a class="el" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> takes in a model and a data point, and returns the area under the data point.</li>
</ul>
<p>Defaults for the parameter models are filled in via bootstrapping or resampling, meaning that if your model's parameters are decidedly off the Normal path, you can still test claims about the parameters.</p>
<p>The introductory example ran a standard OLS regression, whose output includes some standard hypothesis tests; to conclude, let us go the long way and replicate those results via the general <a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> mechanism. The results here will of course be identical, but the more general mechanism can be used in situations where the standard models don't apply.</p>
<p>Here is the extended program; the first part is identical to the program above. The second half uses many of the above tricks: one of the inputs to <a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> (which row of the parameter set to use) is sent by adding a settings group, we pull that row into a separate data set using <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a>, and we set its vector value by referring to it as the -1st element.</p>
<p>The story of the code is as above: we estimate a model, query that model for the distribution associated with the parameters, and then use that subsidiary model to find the area under the curve up to the parameter itself and zero. This is more than sufficient to test the hypothesis.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
    <a class="code" href="group__conversions.html#ga054d7123f2c801c06a2d1f00f35e7fe2">apop_text_to_db</a>(.text_file=<span class="stringliteral">&quot;data&quot;</span>, .tabname=<span class="stringliteral">&quot;d&quot;</span>);
    <a class="code" href="struct__apop__data.html">apop_data</a> *data = <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;select * from d&quot;</span>);
    <a class="code" href="struct__apop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(data, <a class="code" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>);
    <a class="code" href="apop__model_8c.html#a4fa08e29db38e8dcc111899c942022d9">apop_model_show</a>(est);

    apop_model_add_group(est, apop_pm, .index =1);  
    <a class="code" href="struct__apop__model.html">apop_model</a> *first_param_distribution = <a class="code" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a>(data, est);
    <a class="code" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a>(est-&gt;<a class="code" href="struct__apop__model.html#a211b10fea629f6fa5c9e76bf5ed3b5f4">parameters</a>, 1, param);
    <span class="keywordtype">double</span> area_under_p = <a class="code" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a>(param, first_param_distribution);
    <a class="code" href="group__data__set__get.html#gaef6b2716da81f7d35765dc4ace8a6759">apop_data_set</a>(param, 0, -1, 0);
    <span class="keywordtype">double</span> area_under_zero = <a class="code" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a>(param, first_param_distribution);
    printf(<span class="stringliteral">&quot;reject the null for x_1 with %g percent confidence.\n&quot;</span>,
                                 2*fabs(area_under_p-area_under_zero));
}
</pre></div><p>Note that the procedure did not assume the model parameters had a certain form. It queried the model for the distribution of parameter <code>x_1</code>, and if the model didn't have a closed-form answer then a distribution via bootstrap would be provided. Then that model was queried for its CDF. [The procedure does assume a symmetric distribution. Fixing this is left as an exercise for the reader.] For a model like OLS, this is entirely overkill, which is why OLS provides the basic hypothesis tests automatically. But for more advanced models where the distribution of parameters is unknown or has no closed-form solution, this may be the only recourse.</p>
<p>This introduction has shown you the <a class="el" href="gentle.html#apop_data">apop_data</a> set and some of the functions associated, which might be useful even if you aren't formally doing statistical work but do have to deal with data with real-world elements like column names and mixed numeric/text values. You've seen how Apophenia encapsulates as many of a model's characteristics as possible into a single <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> object, which you can send with data to functions like <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>, <a class="el" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a>, or <a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>. Once you've got your data in the right form, you can use this to simply estimate model parameters, or as an input to later analysis. </p>
</div></div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Wed Oct 19 2011.</div></body></html>
